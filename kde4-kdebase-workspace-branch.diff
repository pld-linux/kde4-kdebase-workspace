--- workspace/kcontrol/dateandtime/helper.cpp	(.../tags/KDE/4.5.1/kdebase)	(wersja 1170567)
+++ workspace/kcontrol/dateandtime/helper.cpp	(.../branches/KDE/4.5/kdebase)	(wersja 1170567)
@@ -58,7 +58,7 @@
   if(!config_file.exists()) {
     config_file.open(QIODevice::WriteOnly);
     config_file.close();
-    config_file.setPermissions(QFile::ReadOther);
+    config_file.setPermissions(QFile::ReadOwner | QFile::WriteOwner | QFile::ReadGroup | QFile::ReadOther);
   }
   KConfig _config(config_file.fileName(), KConfig::SimpleConfig);
   KConfigGroup config(&_config, "NTP");
--- workspace/kcontrol/keyboard/keyboard_hardware.cpp	(.../tags/KDE/4.5.1/kdebase)	(wersja 1170567)
+++ workspace/kcontrol/keyboard/keyboard_hardware.cpp	(.../branches/KDE/4.5/kdebase)	(wersja 1170567)
@@ -16,19 +16,20 @@
  *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
 
-#include <config-workspace.h>
-#include <config-X11.h>
-
+#include <kdebug.h>
 #include <kconfiggroup.h>
 #include <ksharedconfig.h>
 
 #include <QtGui/QX11Info>
+#include <QtGui/QCursor>	// WTF? - otherwise compiler complains
 
 #include <X11/Xlib.h>
 
 #include <math.h>
 
+#include "x11_helper.h"
 
+
 /*
  Originally comes from NumLockX http://dforce.sh.cvut.cz/~seli/en/numlockx
 
@@ -60,131 +61,114 @@
 #include <X11/XKBlib.h>
 #include <X11/keysym.h>
 
-/* the XKB stuff is based on code created by Oswald Buddenhagen <ossi@kde.org> */
-int xkb_init()
-    {
-    int xkb_opcode, xkb_event, xkb_error;
-    int xkb_lmaj = XkbMajorVersion;
-    int xkb_lmin = XkbMinorVersion;
-    return XkbLibraryVersion( &xkb_lmaj, &xkb_lmin )
-			&& XkbQueryExtension( QX11Info::display(), &xkb_opcode, &xkb_event, &xkb_error,
-			       &xkb_lmaj, &xkb_lmin );
-    }
 
+static
 unsigned int xkb_mask_modifier( XkbDescPtr xkb, const char *name )
-    {
-    int i;
-    if( !xkb || !xkb->names )
-	return 0;
-    for( i = 0;
-         i < XkbNumVirtualMods;
-	 i++ )
-	{
-	char* modStr = XGetAtomName( xkb->dpy, xkb->names->vmods[i] );
-	if( modStr != NULL && strcmp(name, modStr) == 0 )
-	    {
-	    unsigned int mask;
-	    XkbVirtualModsToReal( xkb, 1 << i, &mask );
-	    return mask;
-	    }
+{
+	if( !xkb || !xkb->names )
+		return 0;
+
+	for(int i = 0; i < XkbNumVirtualMods; i++ ) {
+		char* modStr = XGetAtomName( xkb->dpy, xkb->names->vmods[i] );
+		if( modStr != NULL && strcmp(name, modStr) == 0 ) {
+			unsigned int mask;
+			XkbVirtualModsToReal( xkb, 1 << i, &mask );
+			return mask;
+		}
 	}
-    return 0;
-    }
+	return 0;
+}
 
+static
 unsigned int xkb_numlock_mask()
-    {
-    XkbDescPtr xkb;
-    if(( xkb = XkbGetKeyboard( QX11Info::display(), XkbAllComponentsMask, XkbUseCoreKbd )) != NULL )
-	{
-        unsigned int mask = xkb_mask_modifier( xkb, "NumLock" );
-        XkbFreeKeyboard( xkb, 0, True );
-        return mask;
-        }
-    return 0;
-    }
+{
+	XkbDescPtr xkb;
+	if(( xkb = XkbGetKeyboard( QX11Info::display(), XkbAllComponentsMask, XkbUseCoreKbd )) != NULL ) {
+		unsigned int mask = xkb_mask_modifier( xkb, "NumLock" );
+		XkbFreeKeyboard( xkb, 0, True );
+		return mask;
+	}
+	else {
+		kError() << "Failed to set numlock: failed to get keyboard";
+	}
+	return 0;
+}
 
-int xkb_set_on()
-    {
-    unsigned int mask;
-    if( !xkb_init())
+static
+int xkb_set_numlock(int set)
+{
+    unsigned int mask = xkb_numlock_mask();
+    if( mask == 0 ) {
+    	kError() << "Failed to set numlock: numlock mask is 0";
         return 0;
-    mask = xkb_numlock_mask();
-    if( mask == 0 )
-        return 0;
-    XkbLockModifiers ( QX11Info::display(), XkbUseCoreKbd, mask, mask);
-    return 1;
     }
 
-int xkb_set_off()
-    {
-    unsigned int mask;
-    if( !xkb_init())
-        return 0;
-    mask = xkb_numlock_mask();
-    if( mask == 0 )
-        return 0;
-    XkbLockModifiers ( QX11Info::display(), XkbUseCoreKbd, mask, 0);
-    return 1;
-    }
+    unsigned int values = set ? mask : 0;
+    return XkbLockModifiers ( QX11Info::display(), XkbUseCoreKbd, mask, values);
+}
 
-void numlock_set_on()
-    {
-    if( xkb_set_on())
-        return;
-    }
+static
+void numlockx_change_numlock_state( bool set )
+{
+	if( !X11Helper::xkbSupported(NULL) ) {
+    	kError() << "Failed to set numlock: xkb is not supported";
+    	return;
+	}
 
-void numlock_set_off()
-    {
-    if( xkb_set_off())
-        return;
-    }
+	if( ! xkb_set_numlock(set) ) {
+    	kError() << "Failed to set numlock: XkbLockModifiers request hasn't been sent";
+	}
+}
 
-void numlockx_change_numlock_state( bool set_P )
-    {
-    if( set_P )
-        numlock_set_on();
-    else
-        numlock_set_off();
-    }
-
 // This code is taken from xset utility from XFree 4.3 (http://www.xfree86.org/)
 
+static
 void set_repeatrate(int delay, double rate)
 {
-  Display* dpy = QX11Info::display();
-  int xkbmajor = XkbMajorVersion, xkbminor = XkbMinorVersion;
-  int xkbopcode, xkbevent, xkberror;
+	if( !X11Helper::xkbSupported(NULL) ) {
+		kError() << "Failed to set keyboard repeat rate: xkb is not supported";
+		return;
+	}
 
-  if (XkbQueryExtension(dpy, &xkbopcode, &xkbevent, &xkberror, &xkbmajor,
-				&xkbminor)) {
-     XkbDescPtr xkb = XkbAllocKeyboard();
-     if (xkb) {
-        int res = XkbGetControls(dpy, XkbRepeatKeysMask, xkb);
-        xkb->ctrls->repeat_delay = delay;
-        xkb->ctrls->repeat_interval = (int)floor(1000/rate + 0.5);
-        res = XkbSetControls(dpy, XkbRepeatKeysMask, xkb);
-        return;
-     }
-  }
+	XkbDescPtr xkb = XkbAllocKeyboard();
+	if (xkb) {
+		Display* dpy = QX11Info::display();
+		int res = XkbGetControls(dpy, XkbRepeatKeysMask, xkb);
+		xkb->ctrls->repeat_delay = delay;
+		xkb->ctrls->repeat_interval = (int)floor(1000/rate + 0.5);
+		res = XkbSetControls(dpy, XkbRepeatKeysMask, xkb);
+		return;
+	}
 }
 
-void init_keyboard_hardware()
+static
+void set_volume(int click_percent, bool auto_repeat_mode)
 {
-    KConfigGroup config(KSharedConfig::openConfig( "kcminputrc" ), "Keyboard");
-
 	XKeyboardState   kbd;
 	XKeyboardControl kbdc;
 
 	XGetKeyboardControl(QX11Info::display(), &kbd);
-	bool key = config.readEntry("KeyboardRepeating", true);
-	kbdc.key_click_percent = config.readEntry("ClickVolume", kbd.key_click_percent);
-	kbdc.auto_repeat_mode = (key ? AutoRepeatModeOn : AutoRepeatModeOff);
 
+	if( click_percent != -1 ) {
+		kbdc.key_click_percent = click_percent;
+	}
+	kbdc.auto_repeat_mode = (auto_repeat_mode ? AutoRepeatModeOn : AutoRepeatModeOff);
+
 	XChangeKeyboardControl(QX11Info::display(),
 						   KBKeyClickPercent | KBAutoRepeatMode,
 						   &kbdc);
+}
 
-	if( key ) {
+void init_keyboard_hardware()
+{
+    KConfigGroup config(KSharedConfig::openConfig( "kcminputrc" ), "Keyboard");
+
+	bool key_repeat = config.readEntry("KeyboardRepeating", true);
+	int click_percent = config.readEntry("ClickVolume", -1);
+
+	set_volume(click_percent, key_repeat);
+
+	if( key_repeat ) {
 		int delay_ = config.readEntry("RepeatDelay", 250);
 		double rate_ = config.readEntry("RepeatRate", 30.);
 		set_repeatrate(delay_, rate_);
@@ -192,6 +176,7 @@
 
 
 	int numlockState = config.readEntry( "NumLock", 2 );
-	if( numlockState != 2 )
+	if( numlockState != 2 ) {
 		numlockx_change_numlock_state( numlockState == 0 );
+	}
 }
--- workspace/kcontrol/keyboard/xkb_helper.h	(.../tags/KDE/4.5.1/kdebase)	(wersja 1170567)
+++ workspace/kcontrol/keyboard/xkb_helper.h	(.../branches/KDE/4.5/kdebase)	(wersja 1170567)
@@ -24,7 +24,6 @@
 
 class XkbHelper {
 public:
-	static bool initializeKeyboardLayouts();
 	static bool initializeKeyboardLayouts(KeyboardConfig& config);
 
 //private:
--- workspace/kcontrol/keyboard/xkb_helper.cpp	(.../tags/KDE/4.5.1/kdebase)	(wersja 1170567)
+++ workspace/kcontrol/keyboard/xkb_helper.cpp	(.../branches/KDE/4.5/kdebase)	(wersja 1170567)
@@ -30,6 +30,7 @@
 
 #include "keyboard_config.h"
 
+
 static const char* SETXKBMAP_EXEC = "setxkbmap";
 
 static bool setxkbmapNotFound = false;
@@ -71,19 +72,19 @@
     }
 }
 
-bool XkbHelper::initializeKeyboardLayouts()
-{
-	getSetxkbmapExe();
-	if( ! setxkbmapNotFound ) {
+//bool XkbHelper::initializeKeyboardLayouts()
+//{
+//	getSetxkbmapExe();
+//	if( ! setxkbmapNotFound ) {
+//
+//		KeyboardConfig config;
+//		config.load();
+//
+//		return XkbHelper::initializeKeyboardLayouts(config);
+//	}
+//	return false;
+//}
 
-		KeyboardConfig config;
-		config.load();
-
-		return XkbHelper::initializeKeyboardLayouts(config);
-	}
-	return false;
-}
-
 bool XkbHelper::initializeKeyboardLayouts(KeyboardConfig& config)
 {
 	QStringList setxkbmapCommandArguments;
--- workspace/kcontrol/keyboard/xinput_helper.cpp	(.../tags/KDE/4.5.1/kdebase)	(wersja 1170567)
+++ workspace/kcontrol/keyboard/xinput_helper.cpp	(.../branches/KDE/4.5/kdebase)	(wersja 1170567)
@@ -91,16 +91,18 @@
 			int ndevices;
 			XDeviceInfo	*devices = XListInputDevices(xdpne->display, &ndevices);
 			if( devices != NULL ) {
-				kDebug() << "New device id:" << xdpne->deviceid;
+//				kDebug() << "New device id:" << xdpne->deviceid;
 				for(int i=0; i<ndevices; i++) {
-					kDebug() << "id:" << devices[i].id << "name:" << devices[i].name << "used as:" << devices[i].use;
+//					kDebug() << "id:" << devices[i].id << "name:" << devices[i].name << "used as:" << devices[i].use;
 					if( devices[i].id == xdpne->deviceid ) {
 						if( devices[i].use == IsXKeyboard || devices[i].use == IsXExtensionKeyboard ) {
 							newDeviceType = DEVICE_KEYBOARD;
+							kDebug() << "new keyboard device, id:" << devices[i].id << "name:" << devices[i].name << "used as:" << devices[i].use;
 							break;
 						}
 						if( devices[i].use == IsXPointer || devices[i].use == IsXExtensionPointer ) {
 							newDeviceType = DEVICE_POINTER;
+							kDebug() << "new pointer device, id:" << devices[i].id << "name:" << devices[i].name << "used as:" << devices[i].use;
 							break;
 						}
 					}
--- workspace/kcontrol/keyboard/kcm_keyboard_widget.cpp	(.../tags/KDE/4.5.1/kdebase)	(wersja 1170567)
+++ workspace/kcontrol/keyboard/kcm_keyboard_widget.cpp	(.../branches/KDE/4.5/kdebase)	(wersja 1170567)
@@ -70,9 +70,16 @@
 	connect(kcmMiscWidget, SIGNAL(changed(bool)), this, SIGNAL(changed(bool)));
 	//TODO: connect save/load
 
-    initializeKeyboardModelUI();
-    initializeXkbOptionsUI();
-    initializeLayoutsUI();
+    if( rules != NULL ) {
+        initializeKeyboardModelUI();
+    	initializeXkbOptionsUI();
+    	initializeLayoutsUI();
+    }
+    else {
+		uiWidget->tabLayouts->setEnabled(false);
+		uiWidget->tabAdvanced->setEnabled(false);
+		uiWidget->keyboardModelComboBox->setEnabled(false);
+    }
 }
 
 KCMKeyboardWidget::~KCMKeyboardWidget()
@@ -82,7 +89,10 @@
 
 void KCMKeyboardWidget::save()
 {
-    KAction* action = static_cast<KAction*>(actionCollection->action(0));
+	if( rules == NULL )
+		return;
+
+	KAction* action = static_cast<KAction*>(actionCollection->action(0));
     KShortcut shortcut(uiWidget->kdeKeySequence->keySequence());
     action->setGlobalShortcut(shortcut, KAction::ActiveShortcut, KAction::NoAutoloading);
     kDebug() << "Saving keyboard layout KDE shortcut" << shortcut.toString();
@@ -92,6 +102,9 @@
 
 void KCMKeyboardWidget::updateUI()
 {
+	if( rules == NULL )
+		return;
+
 	uiWidget->layoutsTableView->setModel(uiWidget->layoutsTableView->model());
 	((LayoutsTableModel*)uiWidget->layoutsTableView->model())->refresh();
 
@@ -106,6 +119,9 @@
 
 void KCMKeyboardWidget::uiChanged()
 {
+	if( rules == NULL )
+		return;
+
 	((LayoutsTableModel*)uiWidget->layoutsTableView->model())->refresh();
 // this collapses the tree so use more fine-grained updates
 //	((LayoutsTableModel*)uiWidget->xkbOptionsTreeView->model())->refresh();
@@ -465,9 +481,16 @@
 		button->setText(i18nc("no shortcuts defined", "None"));
 	break;
 	case 1: {
+		const QString& option = grpOptions.first();
 		const OptionGroupInfo* optionGroupInfo = rules->getOptionGroupInfo(groupName);
-		const OptionInfo* optionInfo = optionGroupInfo->getOptionInfo(grpOptions.first());
-		button->setText(optionInfo->description);
+		const OptionInfo* optionInfo = optionGroupInfo->getOptionInfo(option);
+		if( optionInfo == NULL || optionInfo->description == NULL ) {
+			kError() << "Could not find option info for " << option;
+			button->setText(grpOptions.first());
+		}
+		else {
+			button->setText(optionInfo->description);
+		}
 	}
 	break;
 	default:
--- workspace/kinfocenter/Categories/deviceinfocategory.desktop	(.../tags/KDE/4.5.1/kdebase)	(wersja 1170567)
+++ workspace/kinfocenter/Categories/deviceinfocategory.desktop	(.../branches/KDE/4.5/kdebase)	(wersja 1170567)
@@ -5,7 +5,9 @@
 Icon=folder-documents
 
 Name=Lost And Found
+Name[ca]=Perdut i trobat
 Name[da]=Hittegods
+Name[de]=Nicht zuzuordnen
 Name[es]=Objetos perdidos
 Name[et]=Kaotatud ja leitud
 Name[ga]=Earraí Caillte
--- workspace/kinfocenter/Categories/networkinfocategory.desktop	(.../tags/KDE/4.5.1/kdebase)	(wersja 1170567)
+++ workspace/kinfocenter/Categories/networkinfocategory.desktop	(.../branches/KDE/4.5/kdebase)	(wersja 1170567)
@@ -5,7 +5,9 @@
 Icon=folder-documents
 
 Name=Network Information
+Name[ca]=Informació de la xarxa
 Name[da]=Netværksinformation
+Name[de]=Netzwerkinformationen
 Name[es]=Información de la red
 Name[et]=Võrguteave
 Name[ga]=Faisnéis Líonra
--- workspace/kinfocenter/Categories/graphicalinfocategory.desktop	(.../tags/KDE/4.5.1/kdebase)	(wersja 1170567)
+++ workspace/kinfocenter/Categories/graphicalinfocategory.desktop	(.../branches/KDE/4.5/kdebase)	(wersja 1170567)
@@ -5,7 +5,9 @@
 Icon=folder-documents
 
 Name=Graphical Information
+Name[ca]=Informació gràfica
 Name[da]=Grafikinformation
+Name[de]=Grafische Informationen
 Name[es]=Información gráfica
 Name[et]=Monitoriteave
 Name[ga]=Faisnéis Ghrafach
--- workspace/kinfocenter/Categories/kinfocentercategory.desktop	(.../tags/KDE/4.5.1/kdebase)	(wersja 1170567)
+++ workspace/kinfocenter/Categories/kinfocentercategory.desktop	(.../branches/KDE/4.5/kdebase)	(wersja 1170567)
@@ -2,6 +2,7 @@
 Type=ServiceType
 X-KDE-ServiceType=KInfoCenterCategory
 Name=KInfoCenter Category
+Name[ca]=Categoria del KInfoCenter
 Name[da]=KInfoCenter-kategori
 Name[es]=Categoría de KInfoCenter
 Name[et]=KDE infokeskuse kategooria
--- workspace/kwin/effects/desktopgrid/desktopgrid.cpp	(.../tags/KDE/4.5.1/kdebase)	(wersja 1170567)
+++ workspace/kwin/effects/desktopgrid/desktopgrid.cpp	(.../branches/KDE/4.5/kdebase)	(wersja 1170567)
@@ -586,7 +586,7 @@
             }
         if( d != highlightedDesktop ) // Highlight desktop
             {
-            if ( (me->buttons() & Qt::LeftButton) && !wasWindowMove )
+            if ( (me->buttons() & Qt::LeftButton) && !wasWindowMove && d <= effects->numberOfDesktops() )
                 {
                 EffectWindowList windows = effects->stackingOrder();
                 EffectWindowList stack;
@@ -640,7 +640,7 @@
             EffectWindow* w = isDesktop ? NULL : windowAt( me->pos());
             if ( w != NULL )
                 isDesktop = w->isDesktop();
-            if( w != NULL && ( w->isMovable() || w->isMovableAcrossScreens() ))
+            if( w != NULL && ( w->isMovable() || w->isMovableAcrossScreens() || isUsingPresentWindows() ))
                 { // Prepare it for moving
                 windowMoveDiff = w->pos() - unscalePos( me->pos(), NULL );
                 windowMove = w;
@@ -747,6 +747,10 @@
 
 void DesktopGridEffect::grabbedKeyboardEvent( QKeyEvent* e )
     {
+    if( timeline.value() != 1 ) // Block user input during animations
+        return;
+    if( windowMove != NULL )
+        return;
     if( e->type() == QEvent::KeyPress )
         {
         // check for global shortcuts
@@ -1250,6 +1254,11 @@
         case LayoutPager:
             orientation = Qt::Horizontal;
             gridSize = effects->desktopGridSize();
+            // sanity check: pager may report incorrect size in case of one desktop
+            if( numDesktops == 1 )
+                {
+                gridSize = QSize( 1, 1 );
+                }
             break;
         case LayoutAutomatic:
             y = sqrt( float( numDesktops ) ) + 0.5;
--- workspace/kwin/effects/blur/blur.cpp	(.../tags/KDE/4.5.1/kdebase)	(wersja 1170567)
+++ workspace/kwin/effects/blur/blur.cpp	(.../branches/KDE/4.5/kdebase)	(wersja 1170567)
@@ -224,7 +224,7 @@
     const QRect screen(0, 0, displayWidth(), displayHeight());
     bool scaled = !qFuzzyCompare(data.xScale, 1.0) && !qFuzzyCompare(data.yScale, 1.0);
     bool translated = data.xTranslate || data.yTranslate;
-    bool transformed = scaled || translated;
+    bool transformed = scaled || translated || mask & PAINT_WINDOW_TRANSFORMED;
     bool hasAlpha = w->hasAlpha() || (w->hasDecoration() && effects->decorationsHaveAlpha());
     bool valid = target->valid() && shader->isValid();
 
--- workspace/kwin/effects/dialogparent/dialogparent.desktop	(.../tags/KDE/4.5.1/kdebase)	(wersja 1170567)
+++ workspace/kwin/effects/dialogparent/dialogparent.desktop	(.../branches/KDE/4.5/kdebase)	(wersja 1170567)
@@ -113,7 +113,7 @@
 Comment[mr]=वर्तमान सक्रीय संवादचे मुख्य चौकट काळसर करतो
 Comment[nb]=Gjør mor-vinduet til den aktive dialogen mørkere
 Comment[nds]=Maakt dat Moderfinstern vun den aktiven Dialoog düüsterer
-Comment[nl]=Maakt het venster dat bij het actieve dialoog hoort donkerder
+Comment[nl]=Maakt het venster dat bij de ouder van de actieve dialoog hoort donkerder
 Comment[nn]=Gjer foreldrevindauget til det aktive dialogvindauget mørkare
 Comment[pa]=ਮੌਜੂਦਾ ਐਕਟਿਵ ਡਾਈਲਾਗ ਉੱਤੇ ਮੁੱਢਲੇ ਵਿੰਡੋ ਦਾ ਪਰਛਾਵਾਂ
 Comment[pl]=Przyciemnia okna rodzica aktywnego okna dialogowego
--- workspace/kwin/clients/aurorae/src/lib/auroraetab.cpp	(.../tags/KDE/4.5.1/kdebase)	(wersja 1170567)
+++ workspace/kwin/clients/aurorae/src/lib/auroraetab.cpp	(.../branches/KDE/4.5/kdebase)	(wersja 1170567)
@@ -57,11 +57,22 @@
 
 void AuroraeTab::activeChanged()
 {
+    if (scene() == NULL) {
+        return;
+    }
     const ThemeConfig &config = m_theme->themeConfig();
     if (!config.useTextShadow()) {
         return;
     }
-    const bool active = static_cast<AuroraeScene*>(scene())->isActive();
+    AuroraeScene *s = static_cast<AuroraeScene*>(scene());
+    if (s->tabCount() > 1) {
+        // graphics effect seems to be not side effect free and drops scheduled updates
+        // rendering tabs unreadable, therefore disabled.
+        m_effect->setEnabled(false);
+    } else {
+        m_effect->setEnabled(true);
+    }
+    const bool active = s->isActive();
     m_effect->setXOffset(config.textShadowOffsetX());
     m_effect->setYOffset(config.textShadowOffsetY());
     m_effect->setColor(active ? config.activeTextShadowColor() : config.inactiveTextShadowColor());
--- workspace/kwin/clients/aurorae/src/lib/auroraescene.cpp	(.../tags/KDE/4.5.1/kdebase)	(wersja 1170567)
+++ workspace/kwin/clients/aurorae/src/lib/auroraescene.cpp	(.../branches/KDE/4.5/kdebase)	(wersja 1170567)
@@ -820,6 +820,12 @@
     static_cast<QGraphicsLinearLayout*>(m_title->layout())->addItem(tab);
     tab->setSizePolicy(QSizePolicy::Expanding, QSizePolicy::Expanding);
     m_title->layout()->invalidate();
+    // have to call active changed on each tab to update shadow effect
+    foreach (QGraphicsItem *item, items()) {
+        if (AuroraeTab *tab = dynamic_cast<AuroraeTab*>(item)) {
+            tab->activeChanged();
+        }
+    }
 }
 
 void AuroraeScene::addTabs(const QStringList &captions)
@@ -841,10 +847,16 @@
                 removeItem(tab);
                 --m_tabCount;
                 m_title->layout()->invalidate();
-                return;
+                break;
             }
         }
     }
+    // have to call active changed on each tab to update shadow effect
+    foreach (QGraphicsItem *item, items()) {
+        if (AuroraeTab *tab = dynamic_cast<AuroraeTab*>(item)) {
+            tab->activeChanged();
+        }
+    }
 }
 
 int AuroraeScene::tabCount() const
--- workspace/kwin/tiling.cpp	(.../tags/KDE/4.5.1/kdebase)	(wersja 1170567)
+++ workspace/kwin/tiling.cpp	(.../branches/KDE/4.5/kdebase)	(wersja 1170567)
@@ -175,7 +175,6 @@
     {
     if( tilingLayouts.value( c->desktop() ) == NULL )
         {
-        c->setGeometry( moveResizeGeom );
         return;
         }
     tilingLayouts[ c->desktop() ]->clientMoved( c, moveResizeGeom, orig );
--- workspace/plasma/desktop/shell/panelview.h	(.../tags/KDE/4.5.1/kdebase)	(wersja 1170567)
+++ workspace/plasma/desktop/shell/panelview.h	(.../branches/KDE/4.5/kdebase)	(wersja 1170567)
@@ -205,6 +205,9 @@
 
     void updateStruts();
 
+    bool migratedFrom(int screenId) const;
+    void migrateTo(int screenId);
+
 protected:
     void moveEvent(QMoveEvent *event);
     void resizeEvent(QResizeEvent *event);
--- workspace/plasma/desktop/shell/plasmaapp.h	(.../tags/KDE/4.5.1/kdebase)	(wersja 1170567)
+++ workspace/plasma/desktop/shell/plasmaapp.h	(.../branches/KDE/4.5/kdebase)	(wersja 1170567)
@@ -152,13 +152,18 @@
     void wallpaperCheckedIn();
     void wallpaperCheckInTimeout();
     void dashboardClosed();
+    void relocatePanels();
 
 private:
     DesktopCorona *m_corona;
+
     QList<PanelView*> m_panels;
     QList<QWeakPointer<Plasma::Containment> > m_panelsWaiting;
+    QList<QWeakPointer<Plasma::Containment> > m_panelRelocationCandidates;
+
+    QList<DesktopView*> m_desktops;
     QList<QWeakPointer<Plasma::Containment> > m_desktopsWaiting;
-    QList<DesktopView*> m_desktops;
+
     QTimer m_panelViewCreationTimer;
     QTimer m_desktopViewCreationTimer;
     QWeakPointer<InteractiveConsole> m_console;
--- workspace/plasma/desktop/shell/panelview.cpp	(.../tags/KDE/4.5.1/kdebase)	(wersja 1170567)
+++ workspace/plasma/desktop/shell/panelview.cpp	(.../branches/KDE/4.5/kdebase)	(wersja 1170567)
@@ -1196,6 +1196,31 @@
     recreateUnhideTrigger();
 }
 
+bool PanelView:: migratedFrom(int screenId) const
+{
+    KConfigGroup cg = config();
+    QList<int> migrations;
+    migrations = cg.readEntry("Migrations", migrations);
+    return migrations.contains(screenId);
+}
+
+void PanelView::migrateTo(int screenId)
+{
+    KConfigGroup cg = config();
+    QList<int> migrations;
+    migrations = cg.readEntry("Migrations", migrations);
+
+    const int index = migrations.indexOf(screenId);
+    if (index == -1) {
+        migrations.append(screenId);
+    } else {
+        migrations = migrations.mid(0, migrations.length() - index - 1);
+    }
+
+    cg.writeEntry("Migrations", migrations);
+    setScreen(screenId);
+}
+
 void PanelView::enterEvent(QEvent *event)
 {
     // allow unhiding to happen again even if we were delay-unhidden
--- workspace/plasma/desktop/shell/plasmaapp.cpp	(.../tags/KDE/4.5.1/kdebase)	(wersja 1170567)
+++ workspace/plasma/desktop/shell/plasmaapp.cpp	(.../branches/KDE/4.5/kdebase)	(wersja 1170567)
@@ -664,7 +664,7 @@
     QList<Kephal::Screen *> screens = Kephal::Screens::self()->screens();
     screens.removeAll(primary);
 
-    // Now we process panels: if there is room on another sreen for the panel,
+    // Now we process panels: if there is room on another screen for the panel,
     // we migrate the panel there, otherwise the view is deleted. The primary
     // screen is preferred in all cases.
     QMutableListIterator<PanelView*> pIt(m_panels);
@@ -684,7 +684,7 @@
             }
 
             if (moveTo) {
-                panel->containment()->setScreen(moveTo->id());
+                panel->migrateTo(moveTo->id());
             } else {
                 pIt.remove();
                 delete panel;
@@ -704,6 +704,12 @@
             m_panelViewCreationTimer.start();
         }
     }
+
+    foreach (PanelView *view, m_panels) {
+        if (view->migratedFrom(screen->id())) {
+            view->migrateTo(screen->id());
+        }
+    }
 }
 
 bool PlasmaApp::canRelocatePanel(PanelView * view, Kephal::Screen *screen)
@@ -740,7 +746,7 @@
         if (pv != view &&
             pv->screen() == screen->id() &&
             pv->location() == view->location() &&
-            !pv->geometry().intersects(newGeom)) {
+            pv->geometry().intersects(newGeom)) {
             return false;
             break;
         }
@@ -919,11 +925,6 @@
     const QList<QWeakPointer<Plasma::Containment> > containments = m_panelsWaiting;
     m_panelsWaiting.clear();
 
-    Kephal::Screen *primary = Kephal::Screens::self()->primaryScreen();
-    QList<Kephal::Screen *> screens = Kephal::Screens::self()->screens();
-    screens.removeAll(primary);
-
-    QList<Plasma::Containment *> relocationCandidates;
     foreach (QWeakPointer<Plasma::Containment> containmentPtr, containments) {
         Plasma::Containment *containment = containmentPtr.data();
         if (!containment) {
@@ -942,16 +943,32 @@
 
         // try to relocate the panel if it is on a now-non-existent screen
         if (containment->screen() >= Kephal::ScreenUtils::numScreens()) {
-            relocationCandidates << containment;
+            m_panelRelocationCandidates << containment;
             continue;
         }
 
         createPanelView(containment);
     }
 
+    if (!m_panelRelocationCandidates.isEmpty()) {
+        QTimer::singleShot(0, this, SLOT(relocatePanels()));
+    }
+}
+
+void PlasmaApp::relocatePanels()
+{
     // we go through relocatables last so that all other panels can be set up first,
     // preventing panel creation ordering to trip up the canRelocatePanel algorithm
-    foreach (Plasma::Containment *containment, relocationCandidates) {
+    Kephal::Screen *primary = Kephal::Screens::self()->primaryScreen();
+    QList<Kephal::Screen *> screens = Kephal::Screens::self()->screens();
+    screens.removeAll(primary);
+
+    foreach (QWeakPointer<Plasma::Containment> c, m_panelRelocationCandidates) {
+        Plasma::Containment *containment = c.data();
+        if (!containment) {
+            continue;
+        }
+
         Kephal::Screen *moveTo = 0;
         PanelView *panelView = createPanelView(containment);
         if (canRelocatePanel(panelView, primary)) {
@@ -966,12 +983,14 @@
         }
 
         if (moveTo) {
-            containment->setScreen(moveTo->id(), -1);
+            panelView->migrateTo(moveTo->id());
         } else {
             m_panels.removeAll(panelView);
             delete panelView;
         }
     }
+
+    m_panelRelocationCandidates.clear();
 }
 
 PanelView *PlasmaApp::createPanelView(Plasma::Containment *containment)
--- workspace/plasma/generic/dataengines/weather/weatherengine.cpp	(.../tags/KDE/4.5.1/kdebase)	(wersja 1170567)
+++ workspace/plasma/generic/dataengines/weather/weatherengine.cpp	(.../branches/KDE/4.5/kdebase)	(wersja 1170567)
@@ -29,48 +29,32 @@
 #include <KServiceTypeTrader>
 
 #include <Plasma/DataEngineManager>
+#include <Plasma/DataContainer>
 
 #include "ions/ion.h"
 
-class WeatherEngine::Private
+// Constructor
+WeatherEngine::WeatherEngine(QObject *parent, const QVariantList& args)
+        :  Plasma::DataEngine(parent, args),
+           m_networkAvailable(false)
 {
-public:
-    Private()
-            : m_networkAvailable(false) {
-    }
+    Q_UNUSED(args)
 
-    /**
-     * Get instance of a loaded ion.
-     * @returns a IonInterface instance of a loaded plugin.
-     */
-    IonInterface* ionForSource(const QString& name) const {
-        int offset = name.indexOf('|');
+    m_reconnectTimer.setSingleShot(true);
+    connect(&m_reconnectTimer, SIGNAL(timeout()), this, SLOT(startReconnect()));
 
-        if (offset < 1) {
-            return NULL;
-        }
+    // Globally notify all plugins to remove their sources (and unload plugin)
+    connect(this, SIGNAL(sourceRemoved(QString)), this, SLOT(removeIonSource(QString)));
+    connect(qApp, SIGNAL(aboutToQuit()), this, SLOT(unloadIons()));
+}
 
-        QString ionName = name.left(offset);
-        return qobject_cast<IonInterface *>(Plasma::DataEngineManager::self()->engine(ionName));
-    }
+// Destructor
+WeatherEngine::~WeatherEngine()
+{
+    // Cleanup all private data.
+    unloadIons();
+}
 
-    /**
-     * Get plugin name from datasource.
-     * @returns The plugin name given a datasource.
-     */
-    QString ionNameForSource(const QString& source) const {
-        int offset = source.indexOf('|');
-        if (offset < 1) {
-            return QString();
-        }
-
-        return QString(source.left(offset));
-    }
-
-    QStringList m_ions;
-    bool m_networkAvailable;
-};
-
 /**
  * Loads an ion plugin given a plugin name found via KService.
  */
@@ -93,9 +77,9 @@
     Plasma::DataEngine *ion = Plasma::DataEngineManager::self()->loadEngine(foundPlugin.pluginName());
     ion->setObjectName(plugName);
     connect(ion, SIGNAL(sourceAdded(QString)), this, SLOT(newIonSource(QString)));
-    connect(ion, SIGNAL(resetCompleted(IonInterface *, bool)), this, SLOT(resetCompleted(IonInterface *, bool)));
+    connect(ion, SIGNAL(forceUpdate(IonInterface*,QString)), this, SLOT(forceUpdate(IonInterface*,QString)));
 
-    d->m_ions << plugName;
+    m_ions << plugName;
 
     return ion;
 }
@@ -108,14 +92,14 @@
 void WeatherEngine::unloadIon(const QString &name)
 {
     Plasma::DataEngineManager::self()->unloadEngine(name);
-    d->m_ions.removeOne(name);
+    m_ions.removeOne(name);
 }
 
 void WeatherEngine::init()
 {
     // Get the list of available plugins but don't load them
     Solid::Networking::Status status = Solid::Networking::status();
-    d->m_networkAvailable = (status == Solid::Networking::Connected ||
+    m_networkAvailable = (status == Solid::Networking::Connected ||
                              status == Solid::Networking::Unknown);
     connect(Solid::Networking::notifier(), SIGNAL(statusChanged(Solid::Networking::Status)),
             this, SLOT(networkStatusChanged(Solid::Networking::Status)));
@@ -156,12 +140,12 @@
  */
 void WeatherEngine::removeIonSource(const QString& source)
 {
-    IonInterface *ion = d->ionForSource(source);
+    IonInterface *ion = ionForSource(source);
     if (ion) {
         ion->removeSource(source);
         // If plugin has no more sources let's unload the plugin
         if (ion->isEmpty()) {
-            unloadIon(d->ionNameForSource(source));
+            unloadIon(ionNameForSource(source));
         }
     }
     kDebug() << "removeIonSource()";
@@ -176,32 +160,13 @@
     setData(source, data);
 }
 
-// Constructor
-WeatherEngine::WeatherEngine(QObject *parent, const QVariantList& args)
-        :  Plasma::DataEngine(parent, args), d(new Private())
-{
-    Q_UNUSED(args)
-
-    // Globally notify all plugins to remove their sources (and unload plugin)
-    connect(this, SIGNAL(sourceRemoved(QString)), this, SLOT(removeIonSource(QString)));
-    connect(qApp, SIGNAL(aboutToQuit()), this, SLOT(unloadIons()));
-}
-
-// Destructor
-WeatherEngine::~WeatherEngine()
-{
-    // Cleanup all private data.
-    unloadIons();
-    delete d;
-}
-
 void WeatherEngine::unloadIons()
 {
-    foreach (const QString &ion, d->m_ions) {
+    foreach (const QString &ion, m_ions) {
         Plasma::DataEngineManager::self()->unloadEngine(ion);
     }
 
-    d->m_ions.clear();
+    m_ions.clear();
 }
 
 /**
@@ -209,24 +174,25 @@
  */
 bool WeatherEngine::sourceRequestEvent(const QString &source)
 {
-    Plasma::DataEngine *ion = d->ionForSource(source);
+    Plasma::DataEngine *ion = ionForSource(source);
 
     if (!ion) {
-        ion = loadIon(d->ionNameForSource(source));
+        ion = loadIon(ionNameForSource(source));
         if (!ion) {
             return false;
         }
     }
 
-    kDebug() << "sourceRequestEvent(): Network is: " << d->m_networkAvailable;
-    if (!d->m_networkAvailable) {
+    // we should connect to the ion anyway, even if the network
+    // is down. when it comes up again, then it will be refreshed
+    ion->connectSource(source, this);
+
+    kDebug() << "sourceRequestEvent(): Network is: " << m_networkAvailable;
+    if (!m_networkAvailable) {
         setData(source, Data());
         return true;
     }
 
-    QByteArray str = source.toLocal8Bit();
-
-    ion->connectSource(source, this);
     if (!containerForSource(source)) {
         // it is an async reply, we need to set up the data anyways
         setData(source, Data());
@@ -239,54 +205,72 @@
  */
 bool WeatherEngine::updateSourceEvent(const QString& source)
 {
-    IonInterface *ion = d->ionForSource(source);
-
-    QByteArray str = source.toLocal8Bit();
-
+    IonInterface *ion = ionForSource(source);
     if (!ion) {
         return false;
     }
 
-    kDebug() << "updateSourceEvent(): Network is: " << d->m_networkAvailable;
-    if (!d->m_networkAvailable) {
+    kDebug() << "updateSourceEvent(): Network is: " << m_networkAvailable;
+    if (!m_networkAvailable) {
         return false;
     }
 
     return ion->updateSourceEvent(source);
 }
 
-void WeatherEngine::triggerReset() const
+void WeatherEngine::networkStatusChanged(Solid::Networking::Status status)
 {
-    kDebug() << "triggerReset()";
-    foreach(const QString &i, d->m_ions) {
+    kDebug();
+    m_networkAvailable = status == Solid::Networking::Connected || status == Solid::Networking::Unknown;
+    if (m_networkAvailable) {
+        // allow the network to settle down and actually come up
+        m_reconnectTimer.start(5000);
+    }
+}
+
+void WeatherEngine::startReconnect()
+{
+    foreach (const QString &i, m_ions) {
         IonInterface * ion = qobject_cast<IonInterface *>(Plasma::DataEngineManager::self()->engine(i));
+        kDebug() << "resetting" << ion;
         if (ion) {
             ion->reset();
         }
     }
 }
 
-void WeatherEngine::networkStatusChanged(Solid::Networking::Status status)
+void WeatherEngine::forceUpdate(IonInterface *i, const QString &source)
 {
-    d->m_networkAvailable = (status == Solid::Networking::Connected || status == Solid::Networking::Unknown);
-    kDebug() << "networkStatusChanged(): Status changed: " << d->m_networkAvailable << "state: " << status;
+    const QString actualSource(i->pluginName() + '|' + source);
+    Plasma::DataContainer *container = containerForSource(source);
+    if (container) {
+        kDebug() << "immediate update of" << source;
+        container->forceImmediateUpdate();
+    } else {
+        kDebug() << "innexplicable failure of" << source;
+    }
+}
 
-    if (d->m_networkAvailable) {
-        QTimer::singleShot(6000, this, SLOT(triggerReset()));
+IonInterface* WeatherEngine::ionForSource(const QString& name) const
+{
+    int offset = name.indexOf('|');
+
+    if (offset < 1) {
+        return NULL;
     }
+
+    QString ionName = name.left(offset);
+    return qobject_cast<IonInterface *>(Plasma::DataEngineManager::self()->engine(ionName));
 }
 
-void WeatherEngine::resetCompleted(IonInterface * i, bool b) const
+QString WeatherEngine::ionNameForSource(const QString& source) const
 {
-    disconnect(i, SIGNAL(resetCompleted(IonInterface*, bool)), this, SLOT(resetCompleted(IonInterface *, bool)));
-    if (b) {
-        foreach(const QString &source, sources()) {
-            IonInterface *ion = d->ionForSource(source);
-            if (ion == i) {
-                ion->updateSourceEvent(source);
-            }
-        }
+    int offset = source.indexOf('|');
+    if (offset < 1) {
+        return QString();
     }
+
+    return QString(source.left(offset));
 }
 
 #include "weatherengine.moc"
--- workspace/plasma/generic/dataengines/weather/ions/ion.cpp	(.../tags/KDE/4.5.1/kdebase)	(wersja 1170567)
+++ workspace/plasma/generic/dataengines/weather/ions/ion.cpp	(.../branches/KDE/4.5/kdebase)	(wersja 1170567)
@@ -47,11 +47,17 @@
  */
 bool IonInterface::sourceRequestEvent(const QString &source)
 {
-    kDebug() << "sourceRequested()";
+    kDebug() << "sourceRequested(): " << source;
+
+    // init anyway the data as it's going to be used
+    // sooner or later (doesnt depend upon initialization
+    // this will avoid problems if updateIonSource() fails for any reason
+    // but later it's able to retrieve the data
+    setData(source, Plasma::DataEngine::Data());
+
+    // if initialized, then we can try to grab the data
     if (d->initialized) {
         return updateIonSource(source);
-    } else {
-        setData(source, Plasma::DataEngine::Data());
     }
 
     return true;
@@ -79,9 +85,7 @@
     d->initialized = initialized;
 
     if (d->initialized) {
-        foreach(const QString &source, sources()) {
-            updateSourceEvent(source);
-        }
+        updateAllSources();
     }
 }
 
--- workspace/plasma/generic/dataengines/weather/ions/wetter.com/ion_wettercom.cpp	(.../tags/KDE/4.5.1/kdebase)	(wersja 1170567)
+++ workspace/plasma/generic/dataengines/weather/ions/wetter.com/ion_wettercom.cpp	(.../branches/KDE/4.5/kdebase)	(wersja 1170567)
@@ -64,7 +64,8 @@
 void WetterComIon::reset()
 {
     cleanup();
-    emit resetCompleted(this, true);
+    m_sourcesToReset = sources();
+    updateAllSources();
 }
 
 void WetterComIon::init()
@@ -469,6 +470,13 @@
 
 void WetterComIon::fetchForecast(const QString& source)
 {
+    foreach (const QString &fetching, m_forecastJobList) {
+        if (fetching == source) {
+            // already fetching!
+            return;
+        }
+    }
+
     QCryptographicHash md5(QCryptographicHash::Md5);
     md5.addData(QString::fromLatin1(PROJECTNAME).toUtf8());
     md5.addData(QString::fromLatin1(APIKEY).toUtf8());
@@ -503,17 +511,31 @@
 
 void WetterComIon::forecast_slotJobFinished(KJob *job)
 {
-    setData(m_forecastJobList[job], Data());
+    const QString source(m_forecastJobList.value(job));
+    setData(source, Data());
     QXmlStreamReader *reader = m_forecastJobXml.value(job);
 
     if (reader) {
-        parseWeatherForecast(m_forecastJobList[job], *reader);
+        parseWeatherForecast(source, *reader);
     }
 
     m_forecastJobList.remove(job);
 
     delete m_forecastJobXml[job];
     m_forecastJobXml.remove(job);
+
+    if (m_sourcesToReset.contains(source)) {
+        m_sourcesToReset.removeAll(source);
+        const QString weatherSource = QString::fromLatin1("wettercom|weather|%1|%2;%3") \
+            .arg(source).arg(m_place[source].placeCode)                 \
+            .arg(m_place[source].displayName);
+
+        // so the weather engine updates it's data
+        forceImmediateUpdateOfAllVisualizations();
+
+        // update the clients of our engine
+        emit forceUpdate(this, weatherSource);
+    }
 }
 
 void WetterComIon::parseWeatherForecast(const QString& source, QXmlStreamReader& xml)
--- workspace/plasma/generic/dataengines/weather/ions/wetter.com/ion_wettercom.h	(.../tags/KDE/4.5.1/kdebase)	(wersja 1170567)
+++ workspace/plasma/generic/dataengines/weather/ions/wetter.com/ion_wettercom.h	(.../branches/KDE/4.5/kdebase)	(wersja 1170567)
@@ -164,6 +164,7 @@
     QMap<KJob *, QString> m_forecastJobList;
 
     KIO::TransferJob *m_job;
+    QStringList m_sourcesToReset;
 };
 
 K_EXPORT_PLASMA_DATAENGINE(wettercom, WetterComIon)
--- workspace/plasma/generic/dataengines/weather/ions/envcan/ion_envcan.cpp	(.../tags/KDE/4.5.1/kdebase)	(wersja 1170567)
+++ workspace/plasma/generic/dataengines/weather/ions/envcan/ion_envcan.cpp	(.../branches/KDE/4.5/kdebase)	(wersja 1170567)
@@ -24,6 +24,7 @@
 #include <KIO/Job>
 #include <KUnitConversion/Converter>
 #include <Solid/Networking>
+#include <Plasma/DataContainer>
 
 
 // ctor, dtor
@@ -52,9 +53,9 @@
 void EnvCanadaIon::reset()
 {
     deleteForecasts();
-    setInitialized(false);
     emitWhenSetup = true;
-    redoXMLSetup();
+    m_sourcesToReset = sources();
+    getXMLSetup();
 }
 
 EnvCanadaIon::~EnvCanadaIon()
@@ -444,9 +445,8 @@
 // Get a specific Ion's data
 bool EnvCanadaIon::updateIonSource(const QString& source)
 {
+    //kDebug() << "updateIonSource()" << source;
 
-    kDebug() << "updateIonSource()";
-
     // We expect the applet to send the source in the following tokenization:
     // ionname|validate|place_name - Triggers validation of place
     // ionname|weather|place_name - Triggers receiving weather of place
@@ -483,41 +483,40 @@
     return false;
 }
 
-void EnvCanadaIon::redoXMLSetup() const
-{
-    getXMLSetup();
-}
-
 // Parses city list and gets the correct city based on ID number
-void EnvCanadaIon::getXMLSetup() const
+void EnvCanadaIon::getXMLSetup()
 {
-    kDebug() << "getXMLSetup()";
+    //kDebug() << "getXMLSetup()";
 
     // If network is down, we need to spin and wait
 
     KIO::TransferJob *job = KIO::get(KUrl("http://dd.weatheroffice.ec.gc.ca/citypage_weather/xml/siteList.xml"), KIO::NoReload, KIO::HideProgressInfo);
 
-    if (job) {
-        connect(job, SIGNAL(data(KIO::Job *, const QByteArray &)), this,
-                SLOT(setup_slotDataArrived(KIO::Job *, const QByteArray &)));
-        connect(job, SIGNAL(result(KJob *)), this, SLOT(setup_slotJobFinished(KJob *)));
-    }
+    m_xmlSetup.clear();
+    connect(job, SIGNAL(data(KIO::Job *, const QByteArray &)), this,
+            SLOT(setup_slotDataArrived(KIO::Job *, const QByteArray &)));
+    connect(job, SIGNAL(result(KJob *)), this, SLOT(setup_slotJobFinished(KJob *)));
 }
 
 // Gets specific city XML data
 void EnvCanadaIon::getXMLData(const QString& source)
 {
-    KUrl url;
+    foreach (const QString &fetching, m_jobList) {
+        if (fetching == source) {
+            // already getting this source and awaiting the data
+            return;
+        }
+    }
 
-    kDebug() << "getXMLData()";
+    //kDebug() << source;
 
     // Demunge source name for key only.
     QString dataKey = source;
     dataKey.remove("envcan|weather|");
 
-    url = "http://dd.weatheroffice.ec.gc.ca/citypage_weather/xml/" + m_places[dataKey].territoryName + "/" + m_places[dataKey].cityCode + "_e.xml";
+    KUrl url = "http://dd.weatheroffice.ec.gc.ca/citypage_weather/xml/" + m_places[dataKey].territoryName + "/" + m_places[dataKey].cityCode + "_e.xml";
     //url="file:///home/spstarr/Desktop/s0000649_e.xml";
-    kDebug() << "Will Try URL: " << url;
+    //kDebug() << "Will Try URL: " << url;
 
     if (m_places[dataKey].territoryName.isEmpty() && m_places[dataKey].cityCode.isEmpty()) {
         setData(source, "validate", QString("envcan|malformed"));
@@ -529,11 +528,9 @@
     m_jobXml.insert(newJob, new QXmlStreamReader);
     m_jobList.insert(newJob, source);
 
-    if (newJob) {
-        connect(newJob, SIGNAL(data(KIO::Job *, const QByteArray &)), this,
-                SLOT(slotDataArrived(KIO::Job *, const QByteArray &)));
-        connect(newJob, SIGNAL(result(KJob *)), this, SLOT(slotJobFinished(KJob *)));
-    }
+    connect(newJob, SIGNAL(data(KIO::Job *, const QByteArray &)), this,
+            SLOT(slotDataArrived(KIO::Job *, const QByteArray &)));
+    connect(newJob, SIGNAL(result(KJob *)), this, SLOT(slotJobFinished(KJob *)));
 }
 
 void EnvCanadaIon::setup_slotDataArrived(KIO::Job *job, const QByteArray &data)
@@ -541,10 +538,12 @@
     Q_UNUSED(job)
 
     if (data.isEmpty()) {
+        //kDebug() << "done!";
         return;
     }
 
     // Send to xml.
+    //kDebug() << data;
     m_xmlSetup.addData(data);
 }
 
@@ -562,7 +561,9 @@
 void EnvCanadaIon::slotJobFinished(KJob *job)
 {
     // Dual use method, if we're fetching location data to parse we need to do this first
-    setData(m_jobList[job], Data());
+    const QString source = m_jobList.value(job);
+    //kDebug() << source << m_sourcesToReset.contains(source);
+    setData(source, Data());
     QXmlStreamReader *reader = m_jobXml.value(job);
     if (reader) {
         readXMLData(m_jobList[job], *reader);
@@ -571,21 +572,25 @@
     m_jobList.remove(job);
     delete m_jobXml[job];
     m_jobXml.remove(job);
+
+    if (m_sourcesToReset.contains(source)) {
+        m_sourcesToReset.removeAll(source);
+
+        // so the weather engine updates it's data
+        forceImmediateUpdateOfAllVisualizations();
+
+        // update the clients of our engine
+        emit forceUpdate(this, source);
+    }
 }
 
 void EnvCanadaIon::setup_slotJobFinished(KJob *job)
 {
     Q_UNUSED(job)
     const bool success = readXMLSetup();
+    m_xmlSetup.clear();
+    //kDebug() << success << m_sourcesToReset;
     setInitialized(success);
-    if (emitWhenSetup) {
-        emitWhenSetup = false;
-        emit(resetCompleted(this, success));
-    } else if (success) {
-        foreach(const QString &source, sources()) {
-            updateIonSource(source);
-        }
-    }
 }
 
 // Parse the city list and store into a QMap
@@ -596,7 +601,7 @@
     QString code;
     QString cityName;
 
-    kDebug() << "readXMLSetup()";
+    //kDebug() << "readXMLSetup()";
 
     while (!m_xmlSetup.atEnd()) {
         m_xmlSetup.readNext();
@@ -632,6 +637,7 @@
         }
 
     }
+
     return (success && !m_xmlSetup.error());
 }
 
@@ -677,7 +683,7 @@
     data.recordHigh = 0.0;
     data.recordLow = 0.0;
 
-    kDebug() << "readXMLData()";
+    //kDebug() << "readXMLData()";
 
     QString dataKey = source;
     dataKey.remove("envcan|weather|");
@@ -1293,7 +1299,7 @@
 
 void EnvCanadaIon::updateWeather(const QString& source)
 {
-    kDebug() << "updateWeather()";
+    //kDebug() << "updateWeather()";
 
     QMap<QString, QString> dataFields;
     Plasma::DataEngine::Data data;
@@ -1312,7 +1318,7 @@
     // Real weather - Current conditions
     data.insert("Observation Period", observationTime(source));
     data.insert("Current Conditions", i18nc("weather condition", condition(source).toUtf8()));
-    kDebug() << "i18n condition string: " << qPrintable(condition(source));
+    //kDebug() << "i18n condition string: " << qPrintable(condition(source));
 
     // Tell applet which icon to use for conditions and provide mapping for condition type to the icons to display
     QMap<QString, ConditionIcons> conditionList;
@@ -1704,7 +1710,7 @@
                             .arg(m_weatherData[source].forecasts[i]->forecastTempHigh) \
                             .arg(m_weatherData[source].forecasts[i]->forecastTempLow) \
                             .arg(m_weatherData[source].forecasts[i]->popPrecent));
-        kDebug() << "i18n summary string: " << qPrintable(i18n(m_weatherData[source].forecasts[i]->shortForecast.toUtf8()));
+        //kDebug() << "i18n summary string: " << qPrintable(i18n(m_weatherData[source].forecasts[i]->shortForecast.toUtf8()));
     }
     return forecastData;
 }
--- workspace/plasma/generic/dataengines/weather/ions/envcan/ion_envcan.h	(.../tags/KDE/4.5.1/kdebase)	(wersja 1170567)
+++ workspace/plasma/generic/dataengines/weather/ions/envcan/ion_envcan.h	(.../branches/KDE/4.5/kdebase)	(wersja 1170567)
@@ -159,8 +159,6 @@
     void slotDataArrived(KIO::Job *, const QByteArray &);
     void slotJobFinished(KJob *);
 
-    void redoXMLSetup(void) const;
-
 private:
     /* Environment Canada Methods - Internal for Ion */
     void deleteForecasts();
@@ -202,7 +200,7 @@
     QMap<QString, QString> weatherRecords(const QString& source) const;
 
     // Load and Parse the place XML listing
-    void getXMLSetup(void) const;
+    void getXMLSetup(void);
     bool readXMLSetup(void);
 
     // Load and parse the specific place(s)
@@ -248,8 +246,9 @@
     QHash<QString, WeatherData> m_weatherData;
 
     // Store KIO jobs
-    QMap<KJob *, QXmlStreamReader*> m_jobXml;
-    QMap<KJob *, QString> m_jobList;
+    QHash<KJob *, QXmlStreamReader*> m_jobXml;
+    QHash<KJob *, QString> m_jobList;
+    QStringList m_sourcesToReset;
     QXmlStreamReader m_xmlSetup;
     Plasma::DataEngine *m_timeEngine;
 
--- workspace/plasma/generic/dataengines/weather/ions/ion.h	(.../tags/KDE/4.5.1/kdebase)	(wersja 1170567)
+++ workspace/plasma/generic/dataengines/weather/ions/ion.h	(.../branches/KDE/4.5/kdebase)	(wersja 1170567)
@@ -97,11 +97,7 @@
     virtual void reset() = 0;
 
 Q_SIGNALS:
-   
-    /**
-     * Triggered when we get initial setup data for ions that provide a list of places
-     */ 
-    void resetCompleted(IonInterface *, bool);
+    void forceUpdate(IonInterface *ion, const QString &source);
 
 protected:
 
--- workspace/plasma/generic/dataengines/weather/ions/bbcukmet/ion_bbcukmet.cpp	(.../tags/KDE/4.5.1/kdebase)	(wersja 1170567)
+++ workspace/plasma/generic/dataengines/weather/ions/bbcukmet/ion_bbcukmet.cpp	(.../branches/KDE/4.5/kdebase)	(wersja 1170567)
@@ -40,10 +40,10 @@
 void UKMETIon::reset()
 {
     deleteForecasts();
-    emit(resetCompleted(this, true));
+    m_sourcesToReset = sources();
+    updateAllSources();
 }
 
-
 void UKMETIon::deleteForecasts()
 {
     // Destroy each forecast stored in a QVector
@@ -226,6 +226,13 @@
 // Gets specific city XML data
 void UKMETIon::getXMLData(const QString& source)
 {
+    foreach (const QString &fetching, m_obsJobList) {
+        if (fetching == source) {
+            // already getting this source and awaiting the data
+            return;
+        }
+    }
+
     KUrl url;
     url = m_place[source].XMLurl;
 
@@ -407,7 +414,8 @@
 
 void UKMETIon::observation_slotJobFinished(KJob *job)
 {
-    setData(m_obsJobList[job], Data());
+    const QString source = m_obsJobList.value(job);
+    setData(source, Data());
 
     QXmlStreamReader *reader = m_obsJobXml.value(job);
     if (reader) {
@@ -417,6 +425,11 @@
     m_obsJobList.remove(job);
     delete m_obsJobXml[job];
     m_obsJobXml.remove(job);
+
+    if (m_sourcesToReset.contains(source)) {
+        m_sourcesToReset.removeAll(source);
+        emit forceUpdate(this, source);
+    }
 }
 
 void UKMETIon::forecast_slotDataArrived(KIO::Job *job, const QByteArray &data)
--- workspace/plasma/generic/dataengines/weather/ions/bbcukmet/ion_bbcukmet.h	(.../tags/KDE/4.5.1/kdebase)	(wersja 1170567)
+++ workspace/plasma/generic/dataengines/weather/ions/bbcukmet/ion_bbcukmet.h	(.../branches/KDE/4.5/kdebase)	(wersja 1170567)
@@ -141,6 +141,8 @@
     void parseWeatherForecast(const QString& source, QXmlStreamReader& xml);
     void parseUnknownElement(QXmlStreamReader& xml) const;
 
+    void deleteForecasts();
+
     struct XMLMapInfo {
         QString place;
         QString XMLurl;
@@ -169,8 +171,7 @@
     Plasma::DataEngine *m_timeEngine;
 
     QDateTime m_dateFormat;
-
-    void deleteForecasts();
+    QStringList m_sourcesToReset;
 };
 
 K_EXPORT_PLASMA_DATAENGINE(bbcukmet, UKMETIon)
--- workspace/plasma/generic/dataengines/weather/ions/noaa/ion_noaa.cpp	(.../tags/KDE/4.5.1/kdebase)	(wersja 1170567)
+++ workspace/plasma/generic/dataengines/weather/ions/noaa/ion_noaa.cpp	(.../branches/KDE/4.5/kdebase)	(wersja 1170567)
@@ -68,8 +68,7 @@
 
 void NOAAIon::reset()
 {
-    emitWhenSetup = true;
-    setInitialized(false);
+    m_sourcesToReset = sources();
     getXMLSetup();
 }
 
@@ -145,7 +144,6 @@
             setData(source, "validate", QString("noaa|invalid|single|").append(sourceAction[2]));
             return true;
         }
-
     } else if (sourceAction[1] == "weather" && sourceAction.size() > 2) {
         getXMLData(source);
         return true;
@@ -174,11 +172,16 @@
 // Gets specific city XML data
 void NOAAIon::getXMLData(const QString& source)
 {
-    KUrl url;
+    foreach (const QString &fetching, m_jobList) {
+        if (fetching == source) {
+            // already getting this source and awaiting the data
+            return;
+        }
+    }
 
     QString dataKey = source;
     dataKey.remove("noaa|weather|");
-    url = m_places[dataKey].XMLurl;
+    KUrl url = m_places[dataKey].XMLurl;
 
     // If this is empty we have no valid data, send out an error and abort.
     if (url.url().isEmpty()) {
@@ -192,7 +195,7 @@
 
     if (m_job) {
         connect(m_job, SIGNAL(data(KIO::Job *, const QByteArray &)), this,
-             SLOT(slotDataArrived(KIO::Job *, const QByteArray &)));
+                SLOT(slotDataArrived(KIO::Job *, const QByteArray &)));
         connect(m_job, SIGNAL(result(KJob *)), this, SLOT(slotJobFinished(KJob *)));
     }
 }
@@ -222,7 +225,8 @@
 void NOAAIon::slotJobFinished(KJob *job)
 {
     // Dual use method, if we're fetching location data to parse we need to do this first
-    removeAllData(m_jobList[job]);
+    const QString source(m_jobList.value(job));
+    removeAllData(source);
     QXmlStreamReader *reader = m_jobXml.value(job);
     if (reader) {
         readXMLData(m_jobList[job], *reader);
@@ -241,9 +245,9 @@
     Q_UNUSED(job)
     const bool success = readXMLSetup();
     setInitialized(success);
-    if (emitWhenSetup) {
-        emitWhenSetup = false;
-        emit(resetCompleted(this, success));
+
+    foreach (const QString &source, m_sourcesToReset) {
+        updateSourceEvent(source);
     }
 }
 
@@ -840,8 +844,9 @@
 void NOAAIon::forecast_slotJobFinished(KJob *job)
 {
     QXmlStreamReader *reader = m_jobXml.value(job);
+    const QString source = m_jobList.value(job);
+
     if (reader) {
-        QString source = m_jobList[job];
         readForecast(source, *reader);
         updateWeather(source);
     }
@@ -849,6 +854,16 @@
     m_jobList.remove(job);
     delete m_jobXml[job];
     m_jobXml.remove(job);
+
+    if (m_sourcesToReset.contains(source)) {
+        m_sourcesToReset.removeAll(source);
+
+        // so the weather engine updates it's data
+        forceImmediateUpdateOfAllVisualizations();
+
+        // update the clients of our engine
+        emit forceUpdate(this, source);
+    }
 }
 
 void NOAAIon::readForecast(const QString& source, QXmlStreamReader& xml)
--- workspace/plasma/generic/dataengines/weather/ions/noaa/ion_noaa.h	(.../tags/KDE/4.5.1/kdebase)	(wersja 1170567)
+++ workspace/plasma/generic/dataengines/weather/ions/noaa/ion_noaa.h	(.../branches/KDE/4.5/kdebase)	(wersja 1170567)
@@ -176,7 +176,7 @@
     Plasma::DataEngine *m_timeEngine;
     QDateTime m_dateFormat;
     bool emitWhenSetup;
-
+    QStringList m_sourcesToReset;
 };
 
 K_EXPORT_PLASMA_DATAENGINE(noaa, NOAAIon)
--- workspace/plasma/generic/dataengines/weather/weatherengine.h	(.../tags/KDE/4.5.1/kdebase)	(wersja 1170567)
+++ workspace/plasma/generic/dataengines/weather/weatherengine.h	(.../branches/KDE/4.5/kdebase)	(wersja 1170567)
@@ -20,6 +20,8 @@
 #ifndef WEATHERENGINE_H
 #define WEATHERENGINE_H
 
+#include <QTimer>
+
 #include <KService>
 #include <KGenericFactory>
 
@@ -81,15 +83,8 @@
      */
     void dataUpdated(const QString& source, Plasma::DataEngine::Data data);
 
-    /**
-    * Reimplemented from Plasma::DataEngine.
-    * @param source The datasource to be updated.
-    * @param data The new data updated.
-    */
-    void resetCompleted(IonInterface *, bool) const;
+    void forceUpdate(IonInterface *ion, const QString &source);
 
-    void triggerReset(void) const;
-
     /**
      * Notify WeatherEngine a new ion has data sources.
      * @arg source datasource name.
@@ -110,6 +105,7 @@
      * Whenever networking changes, take action
      */
     void networkStatusChanged(Solid::Networking::Status);
+    void startReconnect();
 
     /**
      * Cleans up the ions that are currently loaded
@@ -122,8 +118,21 @@
     void updateIonList(const QStringList &changedResources = QStringList());
 
 private:
-    class Private;
-    Private *const d;
+    /**
+     * Get instance of a loaded ion.
+     * @returns a IonInterface instance of a loaded plugin.
+     */
+    IonInterface* ionForSource(const QString& name) const;
+
+    /**
+     * Get plugin name from datasource.
+     * @returns The plugin name given a datasource.
+     */
+    QString ionNameForSource(const QString& source) const;
+
+    QStringList m_ions;
+    bool m_networkAvailable;
+    QTimer m_reconnectTimer;
 };
 
 K_EXPORT_PLASMA_DATAENGINE(weather, WeatherEngine)
--- workspace/plasma/generic/applets/battery/battery.h	(.../tags/KDE/4.5.1/kdebase)	(wersja 1170567)
+++ workspace/plasma/generic/applets/battery/battery.h	(.../branches/KDE/4.5/kdebase)	(wersja 1170567)
@@ -44,7 +44,7 @@
 class Battery : public Plasma::PopupApplet
 {
     Q_OBJECT
-    Q_PROPERTY(qreal labelAlpha READ labelAlpha WRITE setLabelAlpha NOTIFY labelAlphaChanged)
+    Q_PROPERTY(qreal labelAlpha READ labelAlpha WRITE setLabelAlpha )
     Q_PROPERTY(qreal acAlpha READ acAlpha WRITE setAcAlpha)
 
     public:
--- workspace/plasma/generic/applets/battery/battery.cpp	(.../tags/KDE/4.5.1/kdebase)	(wersja 1170567)
+++ workspace/plasma/generic/applets/battery/battery.cpp	(.../branches/KDE/4.5/kdebase)	(wersja 1170567)
@@ -46,6 +46,7 @@
 #include <KConfigDialog>
 #include <KGlobalSettings>
 #include <KPushButton>
+#include <KComboBox>
 
 #include <kworkspace/kworkspace.h>
 
@@ -510,7 +511,14 @@
         m_controlsLayout->addItem(m_profileLabel, row, 0);
 
         m_profileCombo = new Plasma::ComboBox(m_controls);
-        // This is necessary until Qt task #217874 is fixed
+        // Workaround for bug 219873
+#if (QT_VERSION >= QT_VERSION_CHECK(4, 7, 0))
+        m_profileCombo->nativeWidget()->setMaxVisibleItems(4);
+#else
+        // Value passed needs to be one less than intended on Qt < 4.7.0
+        m_profileCombo->nativeWidget()->setMaxVisibleItems(3);
+#endif
+        // This is necessary until QTBUG-2368 is fixed
         m_profileCombo->setZValue(110);
         connect(m_profileCombo, SIGNAL(activated(QString)),
                 this, SLOT(setProfile(QString)));
--- workspace/plasma/generic/runners/kill/killrunner.cpp	(.../tags/KDE/4.5.1/kdebase)	(wersja 1170567)
+++ workspace/plasma/generic/runners/kill/killrunner.cpp	(.../branches/KDE/4.5/kdebase)	(wersja 1170567)
@@ -104,6 +104,7 @@
         m_prepLock.lockForWrite();
         if (!m_processes) {
             m_processes = new KSysGuard::Processes();
+            m_processes->updateAllProcesses();
         }
     }
     m_prepLock.unlock();

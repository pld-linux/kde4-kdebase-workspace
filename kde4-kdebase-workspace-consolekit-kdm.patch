diff -Nur kdebase-workspace-4.0.0/cmake/modules/FindDBus.cmake kdebase-workspace-4.0.0-consolekit-kdm/cmake/modules/FindDBus.cmake
--- kdebase-workspace-4.0.0/cmake/modules/FindDBus.cmake	1970-01-01 01:00:00.000000000 +0100
+++ kdebase-workspace-4.0.0-consolekit-kdm/cmake/modules/FindDBus.cmake	2008-01-08 01:11:25.000000000 +0100
@@ -0,0 +1,39 @@
+
+if(DBUS_INCLUDE_DIR AND DBUS_LIBRARY AND DBUS_ARCH_INCLUDE_DIR)
+	# Already in cache, be silent
+	set(DBUS_FIND_QUIETLY TRUE)	
+endif(DBUS_INCLUDE_DIR AND DBUS_LIBRARY AND DBUS_ARCH_INCLUDE_DIR)
+
+set(DBUS_LIBRARY)
+set(DBUS_INCLUDE_DIR)
+set(DBUS_ARCH_INCLUDE_DIR)
+
+FIND_PATH(DBUS_INCLUDE_DIR dbus/dbus.h
+	/usr/include
+	/usr/include/dbus-1.0
+	/usr/local/include
+)
+
+FIND_PATH(DBUS_ARCH_INCLUDE_DIR dbus/dbus-arch-deps.h
+	/usr/lib${LIB_SUFFIX}/include
+	/usr/lib${LIB_SUFFIX}/dbus-1.0/include
+	/usr/lib64/include
+	/usr/lib64/dbus-1.0/include
+	/usr/lib/include
+	/usr/lib/dbus-1.0/include
+)
+
+FIND_LIBRARY(DBUS_LIBRARY NAMES dbus-1 dbus
+	PATHS
+	/usr/lib
+	/usr/local/lib
+)
+
+if(DBUS_INCLUDE_DIR AND DBUS_LIBRARY AND DBUS_ARCH_INCLUDE_DIR)
+   MESSAGE( STATUS "dbus found: includes in ${DBUS_INCLUDE_DIR}, library in ${DBUS_LIBRARY}")
+   set(DBUS_FOUND TRUE)
+else(DBUS_INCLUDE_DIR AND DBUS_LIBRARY AND DBUS_ARCH_INCLUDE_DIR)
+   MESSAGE( STATUS "dbus not found")
+endif(DBUS_INCLUDE_DIR AND DBUS_LIBRARY AND DBUS_ARCH_INCLUDE_DIR)
+
+MARK_AS_ADVANCED(DBUS_INCLUDE_DIR DBUS_LIBRARY DBUS_ARCH_INCLUDE_DIR)
diff -Nur kdebase-workspace-4.0.0/kdm/backend/client.c kdebase-workspace-4.0.0-consolekit-kdm/kdm/backend/client.c
--- kdebase-workspace-4.0.0/kdm/backend/client.c	2008-01-05 00:55:44.000000000 +0100
+++ kdebase-workspace-4.0.0-consolekit-kdm/kdm/backend/client.c	2008-01-08 01:11:25.000000000 +0100
@@ -82,6 +82,10 @@
 #endif
 #include <signal.h>
 
+#ifdef WITH_CONSOLE_KIT
+#include "consolekit.h"
+#endif
+
 /*
  * Session data, mostly what struct verify_info was for
  */
@@ -1178,8 +1182,13 @@
 }
 */
 
+#ifdef WITH_CONSOLE_KIT
+int
+startClient( volatile int *pid, const char *ck_session_cookie )
+#else
 int
 startClient( volatile int *pid )
+#endif
 {
 	const char *home, *sessargs, *desksess;
 	char **env, *xma;
@@ -1268,6 +1277,11 @@
 	if (krbtkfile[0] != '\0')
 		env = setEnv( env, "KRBTKFILE", krbtkfile );
 #endif
+#ifdef WITH_CONSOLE_KIT
+	if (ck_session_cookie != NULL) {
+		env = setEnv ( env, "XDG_SESSION_COOKIE", ck_session_cookie );
+	}
+#endif
 	userEnviron = inheritEnv( env, envvars );
 	env = systemEnv( 0, curuser );
 	systemEnviron = setEnv( env, "HOME", p->pw_dir );
diff -Nur kdebase-workspace-4.0.0/kdm/backend/CMakeLists.txt kdebase-workspace-4.0.0-consolekit-kdm/kdm/backend/CMakeLists.txt
--- kdebase-workspace-4.0.0/kdm/backend/CMakeLists.txt	2008-01-05 00:55:44.000000000 +0100
+++ kdebase-workspace-4.0.0-consolekit-kdm/kdm/backend/CMakeLists.txt	2008-01-08 01:11:25.000000000 +0100
@@ -1,9 +1,11 @@
+find_package(DBus REQUIRED)
 set(kdm_SRCS
 	dm.h
 	auth.c
 	bootman.c
 	client.c
 	ctrl.c
+	consolekit.c
 	daemon.c
 	dm.c
 	dpylist.c
@@ -50,6 +52,7 @@
 macro_add_file_dependencies(error.c ${CMAKE_CURRENT_SOURCE_DIR}/printf.c)
 kde4_add_executable(kdm NOGUI ${kdm_SRCS})
 macro_add_compile_flags(kdm -U_REENTRANT)
+include_directories(${DBUS_INCLUDE_DIR} ${DBUS_ARCH_INCLUDE_DIR})
 target_link_libraries( kdm
 	${X11_X11_LIB} ${X11_Xau_LIB} ${X11_Xdmcp_LIB} ${X11_X_EXTRA_LIBS}
 	${UNIXAUTH_LIBRARIES}
@@ -59,6 +62,7 @@
 	${KRB5_LIBRARIES}
 	${SOCKET_LIBRARIES}
 	${RESOLV_LIBRARIES}
+	${DBUS_LIBRARY}
 )
 if(UTIL_LIBRARIES)
 	target_link_libraries( kdm ${UTIL_LIBRARIES} )
diff -Nur kdebase-workspace-4.0.0/kdm/backend/consolekit.c kdebase-workspace-4.0.0-consolekit-kdm/kdm/backend/consolekit.c
--- kdebase-workspace-4.0.0/kdm/backend/consolekit.c	1970-01-01 01:00:00.000000000 +0100
+++ kdebase-workspace-4.0.0-consolekit-kdm/kdm/backend/consolekit.c	2008-01-08 01:11:25.000000000 +0100
@@ -0,0 +1,544 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: t; c-basic-offset: 8 -*-
+ *
+ * Copyright (C) 2006-2007 William Jon McCann <mccann@jhu.edu>
+ * Copyright (C) 2007 Kevin Kofler <Kevin@tigcc.ticalc.org>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ */
+
+#include "dm.h"
+#include "dm_auth.h"
+#include "dm_error.h"
+
+#include <stdlib.h>
+#include <string.h>
+#include <pwd.h>
+
+#define DBUS_API_SUBJECT_TO_CHANGE
+#include <dbus/dbus.h>
+
+#include "consolekit.h"
+
+
+#define CK_NAME              "org.freedesktop.ConsoleKit"
+#define CK_PATH              "/org/freedesktop/ConsoleKit"
+#define CK_INTERFACE         "org.freedesktop.ConsoleKit"
+#define CK_MANAGER_PATH      "/org/freedesktop/ConsoleKit/Manager"
+#define CK_MANAGER_INTERFACE "org.freedesktop.ConsoleKit.Manager"
+#define CK_SESSION_INTERFACE "org.freedesktop.ConsoleKit.Session"
+
+static DBusConnection *private_connection = NULL;
+
+static void
+add_param_int (DBusMessageIter *iter_struct,
+	       const char      *key,
+	       int              value)
+{
+	DBusMessageIter iter_struct_entry;
+	DBusMessageIter iter_var;
+
+	dbus_message_iter_open_container (iter_struct,
+					  DBUS_TYPE_STRUCT,
+					  NULL,
+					  &iter_struct_entry);
+
+	dbus_message_iter_append_basic (&iter_struct_entry,
+					DBUS_TYPE_STRING,
+					&key);
+
+	dbus_message_iter_open_container (&iter_struct_entry,
+					  DBUS_TYPE_VARIANT,
+					  DBUS_TYPE_INT32_AS_STRING,
+					  &iter_var);
+
+	dbus_message_iter_append_basic (&iter_var,
+					DBUS_TYPE_INT32,
+					&value);
+
+	dbus_message_iter_close_container (&iter_struct_entry,
+					   &iter_var);
+
+	dbus_message_iter_close_container (iter_struct, &iter_struct_entry);
+}
+
+static void
+add_param_boolean (DBusMessageIter *iter_struct,
+		   const char      *key,
+		   int             value)
+{
+	DBusMessageIter iter_struct_entry;
+	DBusMessageIter iter_var;
+
+	dbus_message_iter_open_container (iter_struct,
+					  DBUS_TYPE_STRUCT,
+					  NULL,
+					  &iter_struct_entry);
+
+	dbus_message_iter_append_basic (&iter_struct_entry,
+					DBUS_TYPE_STRING,
+					&key);
+
+	dbus_message_iter_open_container (&iter_struct_entry,
+					  DBUS_TYPE_VARIANT,
+					  DBUS_TYPE_BOOLEAN_AS_STRING,
+					  &iter_var);
+
+	dbus_message_iter_append_basic (&iter_var,
+					DBUS_TYPE_BOOLEAN,
+					&value);
+
+	dbus_message_iter_close_container (&iter_struct_entry,
+					   &iter_var);
+
+	dbus_message_iter_close_container (iter_struct, &iter_struct_entry);
+}
+
+static void
+add_param_string (DBusMessageIter *iter_struct,
+		  const char      *key,
+		  const char      *value)
+{
+	DBusMessageIter iter_struct_entry;
+	DBusMessageIter iter_var;
+
+	dbus_message_iter_open_container (iter_struct,
+					  DBUS_TYPE_STRUCT,
+					  NULL,
+					  &iter_struct_entry);
+
+	dbus_message_iter_append_basic (&iter_struct_entry,
+					DBUS_TYPE_STRING,
+					&key);
+
+	dbus_message_iter_open_container (&iter_struct_entry,
+					  DBUS_TYPE_VARIANT,
+					  DBUS_TYPE_STRING_AS_STRING,
+					  &iter_var);
+
+	dbus_message_iter_append_basic (&iter_var,
+					DBUS_TYPE_STRING,
+					&value);
+
+	dbus_message_iter_close_container (&iter_struct_entry,
+					   &iter_var);
+
+	dbus_message_iter_close_container (iter_struct, &iter_struct_entry);
+}
+
+static int
+session_get_x11_display (DBusConnection *connection,
+			 const char     *ssid,
+			 char          **str)
+{
+	DBusError       error;
+	DBusMessage    *message;
+	DBusMessage    *reply;
+	DBusMessageIter iter;
+	const char     *value;
+
+	if (str != NULL) {
+		*str = NULL;
+	}
+
+	message = dbus_message_new_method_call (CK_NAME,
+						ssid,
+						CK_SESSION_INTERFACE,
+						"GetX11Display");
+	if (message == NULL) {
+		debug ("ConsoleKit: Couldn't allocate the D-Bus message");
+		return FALSE;
+	}
+
+	dbus_error_init (&error);
+	reply = dbus_connection_send_with_reply_and_block (connection,
+							   message,
+							   -1, &error);
+	if (dbus_error_is_set (&error)) {
+		debug ("ConsoleKit: %s raised:\n %s\n\n", error.name, error.message);
+		reply = NULL;
+	}
+
+	dbus_connection_flush (connection);
+	dbus_message_unref (message);
+
+	if (reply == NULL) {
+		return FALSE;
+	}
+
+	dbus_message_iter_init (reply, &iter);
+	dbus_message_iter_get_basic (&iter, &value);
+	if (str != NULL) {
+		*str = strdup (value);
+	}
+	dbus_message_unref (reply);
+
+	return TRUE;
+}
+
+static int
+session_unlock (DBusConnection *connection,
+		const char     *ssid)
+{
+	DBusError       error;
+	DBusMessage    *message;
+	DBusMessage    *reply;
+
+	debug ("ConsoleKit: Unlocking session %s", ssid);
+	message = dbus_message_new_method_call (CK_NAME,
+						ssid,
+						CK_SESSION_INTERFACE,
+						"Unlock");
+	if (message == NULL) {
+		debug ("ConsoleKit: Couldn't allocate the D-Bus message");
+		return FALSE;
+	}
+
+	dbus_error_init (&error);
+	reply = dbus_connection_send_with_reply_and_block (connection,
+							   message,
+							   -1, &error);
+	dbus_message_unref (message);
+	dbus_message_unref (reply);
+	dbus_connection_flush (connection);
+
+	if (dbus_error_is_set (&error)) {
+		debug ("ConsoleKit: %s raised:\n %s\n\n", error.name, error.message);
+		return FALSE;
+	}
+
+	return TRUE;
+}
+
+/* from libhal */
+static char **
+get_path_array_from_iter (DBusMessageIter *iter,
+			  int             *num_elements)
+{
+	int count;
+	char **buffer;
+
+	count = 0;
+	buffer = (char **)malloc (sizeof (char *) * 8);
+
+	if (buffer == NULL)
+		goto oom;
+
+	buffer[0] = NULL;
+	while (dbus_message_iter_get_arg_type (iter) == DBUS_TYPE_OBJECT_PATH) {
+		const char *value;
+		char *str;
+
+		if ((count % 8) == 0 && count != 0) {
+			buffer = realloc (buffer, sizeof (char *) * (count + 8));
+			if (buffer == NULL)
+				goto oom;
+		}
+
+		dbus_message_iter_get_basic (iter, &value);
+		str = strdup (value);
+		if (str == NULL)
+			goto oom;
+
+		buffer[count] = str;
+
+		dbus_message_iter_next (iter);
+		count++;
+	}
+
+	if ((count % 8) == 0) {
+		buffer = realloc (buffer, sizeof (char *) * (count + 1));
+		if (buffer == NULL)
+			goto oom;
+	}
+
+	buffer[count] = NULL;
+	if (num_elements != NULL)
+		*num_elements = count;
+	return buffer;
+
+oom:
+	logWarn ("%s %d : error allocating memory\n", __FILE__, __LINE__);
+	return NULL;
+
+}
+
+static char **
+get_sessions_for_user (DBusConnection *connection,
+		       const char     *user,
+		       const char     *x11_display)
+{
+	DBusError       error;
+	DBusMessage    *message;
+	DBusMessage    *reply;
+	DBusMessageIter iter;
+	DBusMessageIter iter_reply;
+	DBusMessageIter iter_array;
+	struct passwd	*pwent;
+	char           **sessions;
+
+	sessions = NULL;
+	message = NULL;
+	reply = NULL;
+
+	pwent = getpwnam (user);
+
+	dbus_error_init (&error);
+	message = dbus_message_new_method_call (CK_NAME,
+						CK_MANAGER_PATH,
+						CK_MANAGER_INTERFACE,
+						"GetSessionsForUser");
+	if (message == NULL) {
+		debug ("ConsoleKit: Couldn't allocate the D-Bus message");
+		goto out;
+	}
+
+	dbus_message_iter_init_append (message, &iter);
+	dbus_message_iter_append_basic (&iter,
+					DBUS_TYPE_UINT32,
+					&pwent->pw_uid);
+
+	dbus_error_init (&error);
+	reply = dbus_connection_send_with_reply_and_block (connection,
+							   message,
+							   -1, &error);
+	dbus_connection_flush (connection);
+
+	if (dbus_error_is_set (&error)) {
+		debug ("ConsoleKit: %s raised:\n %s\n\n", error.name, error.message);
+		goto out;
+	}
+
+	if (reply == NULL) {
+		debug ("ConsoleKit: No reply for GetSessionsForUser");
+		goto out;
+	}
+
+	dbus_message_iter_init (reply, &iter_reply);
+	if (dbus_message_iter_get_arg_type (&iter_reply) != DBUS_TYPE_ARRAY) {
+		debug ("ConsoleKit: Wrong reply for GetSessionsForUser - expecting an array.");
+		goto out;
+	}
+
+	dbus_message_iter_recurse (&iter_reply, &iter_array);
+	sessions = get_path_array_from_iter (&iter_array, NULL);
+
+ out:
+	if (message != NULL) {
+		dbus_message_unref (message);
+	}
+	if (reply != NULL) {
+		dbus_message_unref (reply);
+	}
+
+	return sessions;
+}
+
+void
+unlock_ck_session (const char *user,
+		   const char *x11_display)
+{
+	DBusError       error;
+	DBusConnection *connection;
+	char           **sessions;
+	int              i;
+
+	debug ("ConsoleKit: Unlocking session for %s on %s", user, x11_display);
+
+	dbus_error_init (&error);
+	connection = dbus_bus_get (DBUS_BUS_SYSTEM, &error);
+	if (connection == NULL) {
+		debug ("ConsoleKit: Failed to connect to the D-Bus daemon: %s", error.message);
+		dbus_error_free (&error);
+		return;
+	}
+
+	sessions = get_sessions_for_user (connection, user, x11_display);
+	if (sessions == NULL || sessions[0] == NULL) {
+		debug ("ConsoleKit: no sessions found");
+		return;
+	}
+
+	for (i = 0; sessions[i] != NULL; i++) {
+		char *ssid;
+		char *xdisplay;
+
+		ssid = sessions[i];
+		session_get_x11_display (connection, ssid, &xdisplay);
+		debug ("ConsoleKit: session %s has DISPLAY %s", ssid, xdisplay);
+
+		if (xdisplay != NULL
+		    && x11_display != NULL
+		    && strcmp (xdisplay, x11_display) == 0) {
+			int res;
+
+			res = session_unlock (connection, ssid);
+			if (! res) {
+				logError ("ConsoleKit: Unable to unlock %s", ssid);
+			}
+		}
+
+		free (xdisplay);
+	}
+
+	freeStrArr (sessions);
+}
+
+char *
+open_ck_session (struct passwd *pwent,
+		 struct display *d)
+{
+	DBusConnection *connection;
+	DBusError       error;
+	DBusMessage    *message;
+	DBusMessage    *reply;
+	DBusMessageIter iter;
+	DBusMessageIter iter_struct;
+	char	       *cookie;
+
+	cookie = NULL;
+
+	if (pwent == NULL) {
+		debug ("ConsoleKit: NULL user passed as parameter");
+		return NULL;
+	}
+
+	debug ("ConsoleKit: Opening session for %s", pwent->pw_name);
+
+	dbus_error_init (&error);
+	connection = dbus_bus_get_private (DBUS_BUS_SYSTEM, &error);
+	private_connection = connection;
+
+	if (connection == NULL) {
+		debug ("ConsoleKit: Failed to connect to the D-Bus daemon: %s", error.message);
+		dbus_error_free (&error);
+		return NULL;
+	}
+
+	dbus_connection_set_exit_on_disconnect (connection, FALSE);
+	/* No mainloop integration needed for D-Bus because only blocking calls are used. */
+
+	dbus_error_init (&error);
+	message = dbus_message_new_method_call (CK_NAME,
+						CK_MANAGER_PATH,
+						CK_MANAGER_INTERFACE,
+						"OpenSessionWithParameters");
+	if (message == NULL) {
+		debug ("ConsoleKit: Couldn't allocate the D-Bus message");
+		return NULL;
+	}
+
+	dbus_message_iter_init_append (message, &iter);
+	dbus_message_iter_open_container (&iter,
+					  DBUS_TYPE_ARRAY,
+					  DBUS_STRUCT_BEGIN_CHAR_AS_STRING
+					  DBUS_TYPE_STRING_AS_STRING
+					  DBUS_TYPE_VARIANT_AS_STRING
+					  DBUS_STRUCT_END_CHAR_AS_STRING,
+					  &iter_struct);
+
+	add_param_int (&iter_struct, "user", pwent->pw_uid);
+	add_param_string (&iter_struct, "x11-display", d->name);
+	add_param_boolean (&iter_struct, "is-local", ((d->displayType & d_location) == dLocal));
+#ifdef XDMCP
+	if ((d->displayType & d_location) != dLocal) {
+		add_param_string (&iter_struct, "remote-host-name", d->remoteHost);
+	}
+#endif
+
+#ifdef HAVE_VTS
+	if (d->serverVT > 0) {
+		char device[20];
+
+		/* FIXME: how does xorg construct this */
+		sprintf(device, "/dev/tty%d", d->serverVT);
+		add_param_string (&iter_struct, "x11-display-device", device);
+	}
+#endif
+
+	dbus_message_iter_close_container (&iter, &iter_struct);
+
+	reply = dbus_connection_send_with_reply_and_block (connection,
+							   message,
+							   -1, &error);
+	if (dbus_error_is_set (&error)) {
+		debug ("ConsoleKit: %s raised:\n %s\n\n", error.name, error.message);
+		reply = NULL;
+	}
+
+	dbus_connection_flush (connection);
+
+	dbus_message_unref (message);
+	dbus_error_free (&error);
+
+	if (reply != NULL) {
+		const char *value;
+
+		dbus_message_iter_init (reply, &iter);
+		dbus_message_iter_get_basic (&iter, &value);
+		cookie = strdup (value);
+		dbus_message_unref (reply);
+	}
+
+	return cookie;
+}
+
+void
+close_ck_session (const char *cookie)
+{
+	DBusError       error;
+	DBusMessage    *message;
+	DBusMessage    *reply;
+	DBusMessageIter iter;
+
+	if (cookie == NULL) {
+		return;
+	}
+
+	if (private_connection == NULL) {
+		return;
+	}
+
+	dbus_error_init (&error);
+	message = dbus_message_new_method_call (CK_NAME,
+						CK_MANAGER_PATH,
+						CK_MANAGER_INTERFACE,
+						"CloseSession");
+	if (message == NULL) {
+		debug ("ConsoleKit: Couldn't allocate the D-Bus message");
+		return;
+	}
+
+	dbus_message_iter_init_append (message, &iter);
+	dbus_message_iter_append_basic (&iter,
+					DBUS_TYPE_STRING,
+					&cookie);
+
+	reply = dbus_connection_send_with_reply_and_block (private_connection,
+							   message,
+							   -1, &error);
+	if (dbus_error_is_set (&error)) {
+		debug ("ConsoleKit: %s raised:\n %s\n\n", error.name, error.message);
+		reply = NULL;
+	}
+
+	dbus_connection_flush (private_connection);
+
+	dbus_message_unref (message);
+	dbus_error_free (&error);
+
+        dbus_connection_close (private_connection);
+	private_connection = NULL;
+}
diff -Nur kdebase-workspace-4.0.0/kdm/backend/consolekit.h kdebase-workspace-4.0.0-consolekit-kdm/kdm/backend/consolekit.h
--- kdebase-workspace-4.0.0/kdm/backend/consolekit.h	1970-01-01 01:00:00.000000000 +0100
+++ kdebase-workspace-4.0.0-consolekit-kdm/kdm/backend/consolekit.h	2008-01-08 01:11:25.000000000 +0100
@@ -0,0 +1,36 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: t; c-basic-offset: 8 -*-
+ *
+ * Copyright (C) 2006 William Jon McCann <mccann@jhu.edu>
+ * Copyright (C) 2007 Kevin Kofler <Kevin@tigcc.ticalc.org>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ */
+
+
+#ifndef __CONSOLE_KIT_H
+#define __CONSOLE_KIT_H
+
+#include <pwd.h>
+
+struct display;
+
+char *      open_ck_session       (struct passwd *pwent,
+                                   struct display *display);
+void        close_ck_session      (const char    *cookie);
+void        unlock_ck_session     (const char    *user,
+                                   const char    *x11_display);
+
+#endif /* __CONSOLE_KIT_H */
diff -Nur kdebase-workspace-4.0.0/kdm/backend/dm.h kdebase-workspace-4.0.0-consolekit-kdm/kdm/backend/dm.h
--- kdebase-workspace-4.0.0/kdm/backend/dm.h	2008-01-05 00:55:44.000000000 +0100
+++ kdebase-workspace-4.0.0-consolekit-kdm/kdm/backend/dm.h	2008-01-08 01:11:25.000000000 +0100
@@ -37,6 +37,8 @@
 #ifndef _DM_H_
 #define _DM_H_ 1
 
+#define WITH_CONSOLE_KIT
+
 #include "greet.h"
 
 #define WANT_CORE_DECLS
@@ -504,7 +506,11 @@
 #define GCONV_BINARY  5
 typedef char *(*GConvFunc)( int what, const char *prompt );
 int verify( GConvFunc gconv, int rootok );
+#ifdef WITH_CONSOLE_KIT
+int startClient( volatile int *pid,  const char *ck_session_cookie );
+#else
 int startClient( volatile int *pid );
+#endif
 void clientExited( void );
 void sessionExit( int status ) ATTR_NORETURN;
 int readDmrc( void );
diff -Nur kdebase-workspace-4.0.0/kdm/backend/Imakefile kdebase-workspace-4.0.0-consolekit-kdm/kdm/backend/Imakefile
--- kdebase-workspace-4.0.0/kdm/backend/Imakefile	2008-01-05 00:55:44.000000000 +0100
+++ kdebase-workspace-4.0.0-consolekit-kdm/kdm/backend/Imakefile	2008-01-08 01:11:25.000000000 +0100
@@ -155,13 +155,13 @@
 		 netaddr.c reset.c resource.c protodpy.c policy.c \
 		 session.c socket.c streams.c util.c xdmcp.c \
 		 process.c mitauth.c \
-		 genauth.c access.c choose.c \
+		 genauth.c access.c choose.c consolekit.c \
 		 $(XDMAUTHSRCS) $(RPCSRCS) $(KRB5SRCS)
       COMMOBJS = auth.o daemon.o server.o dpylist.o dm.o error.o \
 		 netaddr.o reset.o resource.o protodpy.o policy.o \
 		 session.o socket.o streams.o util.o xdmcp.o \
 		 process.o mitauth.o \
-		 genauth.o access.o choose.o \
+		 genauth.o access.o choose.o consolekit.o \
 		 $(XDMAUTHOBJS) $(RPCOBJS) $(KRB5OBJS)
 
          SRCS1 = $(COMMSRCS) client.c
diff -Nur kdebase-workspace-4.0.0/kdm/backend/session.c kdebase-workspace-4.0.0-consolekit-kdm/kdm/backend/session.c
--- kdebase-workspace-4.0.0/kdm/backend/session.c	2008-01-05 00:55:44.000000000 +0100
+++ kdebase-workspace-4.0.0-consolekit-kdm/kdm/backend/session.c	2008-01-08 01:11:25.000000000 +0100
@@ -45,6 +45,10 @@
 #include <ctype.h>
 #include <signal.h>
 
+#ifdef WITH_CONSOLE_KIT
+#include "consolekit.h"
+#endif
+
 struct display *td;
 const char *td_setup = "auto";
 
@@ -552,6 +556,10 @@
 	volatile int clientPid = -1;
 	volatile time_t tdiff = 0;
 	sigset_t ss;
+#ifdef WITH_CONSOLE_KIT
+	char *ck_session_cookie;
+#endif
+
 
 	td = d;
 	debug( "manageSession %s\n", d->name );
@@ -628,7 +636,12 @@
 	if (td_setup)
 		setupDisplay( td_setup );
 
+#ifdef WITH_CONSOLE_KIT
+	ck_session_cookie = open_ck_session (getpwnam(curuser), d);
+	if (!startClient( &clientPid, ck_session_cookie )) {
+#else
 	if (!startClient( &clientPid )) {
+#endif
 		logError( "Client start failed\n" );
 		sessionExit( EX_NORMAL ); /* XXX maybe EX_REMANAGE_DPY? -- enable in dm.c! */
 	}
@@ -650,6 +663,14 @@
 				catchTerm( SIGTERM );
 		}
 	}
+
+#ifdef WITH_CONSOLE_KIT
+	if (ck_session_cookie != NULL) {
+		close_ck_session (ck_session_cookie);
+		free (ck_session_cookie);
+	}
+#endif
+
 	/*
 	 * Sometimes the Xsession somehow manages to exit before
 	 * a server crash is noticed - so we sleep a bit and wait
diff -Nur kdebase-workspace-4.0.0/kdm/backend/xdmcp.c kdebase-workspace-4.0.0-consolekit-kdm/kdm/backend/xdmcp.c
--- kdebase-workspace-4.0.0/kdm/backend/xdmcp.c	2008-01-05 00:55:44.000000000 +0100
+++ kdebase-workspace-4.0.0-consolekit-kdm/kdm/backend/xdmcp.c	2008-01-08 01:14:03.000000000 +0100
@@ -1016,6 +1016,8 @@
 			d->clientAddr = clientAddress;
 			d->clientPort = clientPort;
 			d->connectionType = connectionType;
+			d->remoteHost = networkAddressToHostname (pdpy->connectionType,
+			                             &pdpy->connectionAddress);
 			if (pdpy->fileAuthorization) {
 				d->authorizations = (Xauth **)Malloc( sizeof(Xauth *) );
 				if (!d->authorizations) {

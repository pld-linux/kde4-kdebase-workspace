diff -Nru kdebase-workspace-4.3.73svn1040395/doc/kdm/index.docbook kdebase-workspace-4.3.73svn1040395-new/doc/kdm/index.docbook
--- kdebase-workspace-4.3.73svn1040395/doc/kdm/index.docbook	2009-10-26 10:14:41.000000000 +0100
+++ kdebase-workspace-4.3.73svn1040395-new/doc/kdm/index.docbook	2009-10-28 22:58:07.000000000 +0100
@@ -317,7 +317,7 @@
 system, and that you simply want to change its behavior in some way.</para>
 
 <para>When &kdm; starts up, it reads its configuration from the folder
-<filename class="directory">$<envar>KDEDIR</envar>/share/config/kdm/</filename>
+<filename class="directory">/etc/X11/kdm/</filename>
 (this may
 be <filename class="directory">/etc/kde4/kdm/</filename> or something else
 on your system).</para>
diff -Nru kdebase-workspace-4.3.73svn1040395/kcontrol/fonts/fonts.cpp kdebase-workspace-4.3.73svn1040395-new/kcontrol/fonts/fonts.cpp
--- kdebase-workspace-4.3.73svn1040395/kcontrol/fonts/fonts.cpp	2009-10-02 16:53:57.000000000 +0200
+++ kdebase-workspace-4.3.73svn1040395-new/kcontrol/fonts/fonts.cpp	2009-10-28 22:58:08.000000000 +0100
@@ -638,7 +638,7 @@
        "<p>The use of this option is generally discouraged. For selecting proper DPI"
        " value a better option is explicitly configuring it for the whole X server if"
        " possible (e.g. DisplaySize in xorg.conf or adding <i>-dpi value</i> to"
-       " ServerLocalArgs= in $KDEDIR/share/config/kdm/kdmrc). When fonts do not render"
+       " ServerLocalArgs= in /etc/X11/kdm/kdmrc). When fonts do not render"
        " properly with real DPI value better fonts should be used or configuration"
        " of font hinting should be checked.</p>" );
    comboForceDpi->setWhatsThis(whatsthis);
diff -Nru kdebase-workspace-4.3.73svn1040395/kcontrol/fonts/fonts.cpp.orig kdebase-workspace-4.3.73svn1040395-new/kcontrol/fonts/fonts.cpp.orig
--- kdebase-workspace-4.3.73svn1040395/kcontrol/fonts/fonts.cpp.orig	1970-01-01 01:00:00.000000000 +0100
+++ kdebase-workspace-4.3.73svn1040395-new/kcontrol/fonts/fonts.cpp.orig	2009-10-02 16:53:57.000000000 +0200
@@ -0,0 +1,830 @@
+// KDE Display fonts setup tab
+//
+// Copyright (c)  Mark Donohoe 1997
+//                lars Knoll 1999
+//                Rik Hemsley 2000
+//
+// Ported to kcontrol2 by Geert Jansen.
+
+#include <config-workspace.h>
+
+#include <QCheckBox>
+#include <QComboBox>
+#include <QDir>
+#include <QLabel>
+#include <QPushButton>
+#include <QtCore/QSettings>
+
+
+//Added by qt3to4:
+#include <QPixmap>
+#include <QByteArray>
+#include <QGridLayout>
+#include <QHBoxLayout>
+#include <QVBoxLayout>
+#include <QFormLayout>
+
+
+#include <kacceleratormanager.h>
+#include <kapplication.h>
+#include <kglobalsettings.h>
+#include <kgenericfactory.h>
+#include <kmessagebox.h>
+#include <knuminput.h>
+#include <kprocess.h>
+#include <kconfig.h>
+#include <kstandarddirs.h>
+#include <stdlib.h>
+
+#include "../krdb/krdb.h"
+#include "fonts.h"
+#include "fonts.moc"
+
+#include <kdebug.h>
+
+#ifdef HAVE_FREETYPE
+#include <ft2build.h>
+#ifdef FT_LCD_FILTER_H
+#include FT_FREETYPE_H
+#include FT_LCD_FILTER_H
+#endif
+#endif
+
+#include <X11/Xlib.h>
+
+#include <KPluginFactory>
+
+// X11 headers
+#undef Bool
+#undef Unsorted
+#undef None
+
+static const char * const aa_rgb_xpm[]={
+"12 12 3 1",
+"a c #0000ff",
+"# c #00ff00",
+". c #ff0000",
+"....####aaaa",
+"....####aaaa",
+"....####aaaa",
+"....####aaaa",
+"....####aaaa",
+"....####aaaa",
+"....####aaaa",
+"....####aaaa",
+"....####aaaa",
+"....####aaaa",
+"....####aaaa",
+"....####aaaa"};
+static const char * const aa_bgr_xpm[]={
+"12 12 3 1",
+". c #0000ff",
+"# c #00ff00",
+"a c #ff0000",
+"....####aaaa",
+"....####aaaa",
+"....####aaaa",
+"....####aaaa",
+"....####aaaa",
+"....####aaaa",
+"....####aaaa",
+"....####aaaa",
+"....####aaaa",
+"....####aaaa",
+"....####aaaa",
+"....####aaaa"};
+static const char * const aa_vrgb_xpm[]={
+"12 12 3 1",
+"a c #0000ff",
+"# c #00ff00",
+". c #ff0000",
+"............",
+"............",
+"............",
+"............",
+"############",
+"############",
+"############",
+"############",
+"aaaaaaaaaaaa",
+"aaaaaaaaaaaa",
+"aaaaaaaaaaaa",
+"aaaaaaaaaaaa"};
+static const char * const aa_vbgr_xpm[]={
+"12 12 3 1",
+". c #0000ff",
+"# c #00ff00",
+"a c #ff0000",
+"............",
+"............",
+"............",
+"............",
+"############",
+"############",
+"############",
+"############",
+"aaaaaaaaaaaa",
+"aaaaaaaaaaaa",
+"aaaaaaaaaaaa",
+"aaaaaaaaaaaa"};
+
+static const char* const * const aaPixmaps[]={ aa_rgb_xpm, aa_bgr_xpm, aa_vrgb_xpm, aa_vbgr_xpm };
+
+/**** DLL Interface ****/
+K_PLUGIN_FACTORY(FontFactory, registerPlugin<KFonts>(); )
+K_EXPORT_PLUGIN(FontFactory("kcmfonts"))
+
+/**** FontUseItem ****/
+
+FontUseItem::FontUseItem(
+  QWidget * parent,
+  const QString &name,
+  const QString &grp,
+  const QString &key,
+  const QString &rc,
+  const QFont &default_fnt,
+  bool f
+)
+  : KFontRequester(parent, f),
+    _rcfile(rc),
+    _rcgroup(grp),
+    _rckey(key),
+    _default(default_fnt)
+{
+  KAcceleratorManager::setNoAccel( this );
+  setTitle( name );
+  readFont();
+}
+
+void FontUseItem::setDefault()
+{
+  setFont( _default, isFixedOnly() );
+}
+
+void FontUseItem::readFont()
+{
+  KConfig *config;
+
+  bool deleteme = false;
+  if (_rcfile.isEmpty())
+    config = KGlobal::config().data();
+  else
+  {
+    config = new KConfig(_rcfile);
+    deleteme = true;
+  }
+
+  KConfigGroup group(config, _rcgroup);
+  QFont tmpFnt(_default);
+  setFont( group.readEntry(_rckey, tmpFnt), isFixedOnly() );
+  if (deleteme) delete config;
+}
+
+void FontUseItem::writeFont()
+{
+  KConfig *config;
+
+  if (_rcfile.isEmpty()) {
+    config = KGlobal::config().data();
+    KConfigGroup(config, _rcgroup).writeEntry(_rckey, font(), KConfig::Normal|KConfig::Global);
+  } else {
+    config = new KConfig(KStandardDirs::locateLocal("config", _rcfile));
+    KConfigGroup(config, _rcgroup).writeEntry(_rckey, font());
+    config->sync();
+    delete config;
+  }
+}
+
+void FontUseItem::applyFontDiff( const QFont &fnt, int fontDiffFlags )
+{
+  QFont _font( font() );
+
+  if (fontDiffFlags & KFontChooser::FontDiffSize) {
+    _font.setPointSizeF( fnt.pointSizeF() );
+  }
+  if (fontDiffFlags & KFontChooser::FontDiffFamily) {
+    if (!isFixedOnly() || QFontInfo(fnt).fixedPitch()) _font.setFamily( fnt.family() );
+  }
+  if (fontDiffFlags & KFontChooser::FontDiffStyle) {
+    _font.setWeight( fnt.weight() );
+    _font.setStyle( fnt.style() );
+    _font.setUnderline( fnt.underline() );
+  }
+
+  setFont( _font, isFixedOnly() );
+}
+
+/**** FontAASettings ****/
+#ifdef HAVE_FONTCONFIG
+FontAASettings::FontAASettings(QWidget *parent)
+              : KDialog( parent ),
+                changesMade(false)
+{
+  setObjectName( "FontAASettings" );
+  setModal( true );
+  setCaption( i18n("Configure Anti-Alias Settings") );
+  setButtons( Ok|Cancel );
+  showButtonSeparator( true );
+
+  QWidget     *mw=new QWidget(this);
+  QFormLayout *layout=new QFormLayout(mw);
+  layout->setMargin(0);
+
+  excludeRange=new QCheckBox(i18n("E&xclude range:"), mw);
+  QHBoxLayout *rangeLayout = new QHBoxLayout();
+  excludeFrom=new KDoubleNumInput(0, 72, 8.0, mw, 1, 1);
+  excludeFrom->setSuffix(i18n(" pt"));
+  rangeLayout->addWidget(excludeFrom);
+  excludeToLabel=new QLabel(i18n(" to "), mw);
+  rangeLayout->addWidget(excludeToLabel);
+  excludeTo=new KDoubleNumInput(0, 72, 15.0, mw, 1, 1);
+  excludeTo->setSuffix(i18n(" pt"));
+  rangeLayout->addWidget(excludeTo);
+  layout->addRow(excludeRange, rangeLayout);
+
+  QString subPixelWhatsThis = i18n("<p>If you have a TFT or LCD screen you"
+       " can further improve the quality of displayed fonts by selecting"
+       " this option.<br />Sub-pixel rendering is also known as ClearType(tm).<br />"
+       " In order for sub-pixel rendering to"
+       " work correctly you need to know how the sub-pixels of your display"
+       " are aligned.</p>"
+       " <p>On TFT or LCD displays a single pixel is actually composed of"
+       " three sub-pixels, red, green and blue. Most displays"
+       " have a linear ordering of RGB sub-pixel, some have BGR.<br />"
+       " This feature does not work with CRT monitors.</p>" );
+
+  useSubPixel=new QCheckBox(i18n("&Use sub-pixel rendering:"), mw);
+  useSubPixel->setWhatsThis( subPixelWhatsThis );
+
+  subPixelType=new QComboBox(mw);
+  layout->addRow(useSubPixel, subPixelType);
+
+  subPixelType->setEditable(false);
+  subPixelType->setWhatsThis( subPixelWhatsThis );
+
+  for(int t=KXftConfig::SubPixel::None+1; t<=KXftConfig::SubPixel::Vbgr; ++t)
+    subPixelType->addItem(QPixmap(aaPixmaps[t-1]), i18n(KXftConfig::description((KXftConfig::SubPixel::Type)t).toUtf8()));
+
+  QLabel *hintingLabel=new QLabel(i18n("Hinting style: "), mw);
+  hintingStyle=new QComboBox(mw);
+  hintingStyle->setEditable(false);
+  layout->addRow(hintingLabel, hintingStyle);
+  for(int s=KXftConfig::Hint::NotSet+1; s<=KXftConfig::Hint::Full; ++s)
+    hintingStyle->addItem(i18n(KXftConfig::description((KXftConfig::Hint::Style)s).toUtf8()));
+
+  QString hintingText(i18n("Hinting is a process used to enhance the quality of fonts at small sizes."));
+  hintingStyle->setWhatsThis( hintingText);
+  hintingLabel->setWhatsThis( hintingText);
+  load();
+  enableWidgets();
+  setMainWidget(mw);
+
+  connect(excludeRange, SIGNAL(toggled(bool)), SLOT(changed()));
+  connect(useSubPixel, SIGNAL(toggled(bool)), SLOT(changed()));
+  connect(excludeFrom, SIGNAL(valueChanged(double)), SLOT(changed()));
+  connect(excludeTo, SIGNAL(valueChanged(double)), SLOT(changed()));
+  connect(subPixelType, SIGNAL(activated(const QString &)), SLOT(changed()));
+  connect(hintingStyle, SIGNAL(activated(const QString &)), SLOT(changed()));
+}
+
+bool FontAASettings::load()
+{
+  double     from, to;
+  KXftConfig xft;
+
+  if(xft.getExcludeRange(from, to))
+     excludeRange->setChecked(true);
+  else
+  {
+    excludeRange->setChecked(false);
+    from=8.0;
+    to=15.0;
+  }
+
+  excludeFrom->setValue(from);
+  excludeTo->setValue(to);
+
+  KXftConfig::SubPixel::Type spType;
+
+  if(!xft.getSubPixelType(spType) || KXftConfig::SubPixel::None==spType)
+    useSubPixel->setChecked(false);
+  else
+  {
+    int idx=getIndex(spType);
+
+    if(idx>-1)
+    {
+      useSubPixel->setChecked(true);
+      subPixelType->setCurrentIndex(idx);
+    }
+    else
+      useSubPixel->setChecked(false);
+  }
+
+  KXftConfig::Hint::Style hStyle;
+
+  if(!xft.getHintStyle(hStyle) || KXftConfig::Hint::NotSet==hStyle)
+  {
+    KConfig kglobals("kdeglobals", KConfig::NoGlobals);
+
+    hStyle=KXftConfig::Hint::Medium;
+    xft.setHintStyle(hStyle);
+    xft.apply();  // Save this setting
+    KConfigGroup(&kglobals, "General").writeEntry("XftHintStyle", KXftConfig::toStr(hStyle));
+    kglobals.sync();
+    runRdb(KRdbExportXftSettings);
+  }
+
+  hintingStyle->setCurrentIndex(getIndex(hStyle));
+
+  enableWidgets();
+
+  return xft.getAntiAliasing();
+}
+
+bool FontAASettings::save( bool useAA )
+{
+  KXftConfig   xft;
+  KConfig      kglobals("kdeglobals", KConfig::NoGlobals);
+  KConfigGroup grp(&kglobals, "General");
+
+  xft.setAntiAliasing( useAA );
+
+  if(excludeRange->isChecked())
+    xft.setExcludeRange(excludeFrom->value(), excludeTo->value());
+  else
+    xft.setExcludeRange(0, 0);
+
+  KXftConfig::SubPixel::Type spType(useSubPixel->isChecked()
+                                        ? getSubPixelType()
+                                        : KXftConfig::SubPixel::None);
+
+  xft.setSubPixelType(spType);
+  grp.writeEntry("XftSubPixel", KXftConfig::toStr(spType));
+  grp.writeEntry("XftAntialias", useAA);
+
+  bool mod=false;
+  KXftConfig::Hint::Style hStyle(getHintStyle());
+
+  xft.setHintStyle(hStyle);
+
+  QString hs(KXftConfig::toStr(hStyle));
+
+  if(!hs.isEmpty() && hs!=grp.readEntry("XftHintStyle"))
+  {
+    grp.writeEntry("XftHintStyle", hs);
+    mod=true;
+  }
+  kglobals.sync();
+
+  if(!mod)
+    mod=xft.changed();
+
+  xft.apply();
+
+  return mod;
+}
+
+void FontAASettings::defaults()
+{
+  excludeRange->setChecked(true);
+  excludeFrom->setValue(8.0);
+  excludeTo->setValue(15.0);
+  useSubPixel->setChecked(false);
+  hintingStyle->setCurrentIndex(getIndex(KXftConfig::Hint::Medium));
+  enableWidgets();
+}
+
+int FontAASettings::getIndex(KXftConfig::SubPixel::Type spType)
+{
+  int pos=-1;
+  int index;
+
+  for(index=0; index<subPixelType->count(); ++index)
+    if(subPixelType->itemText(index)==i18n(KXftConfig::description(spType).toUtf8()))
+    {
+      pos=index;
+      break;
+    }
+
+  return pos;
+}
+
+KXftConfig::SubPixel::Type FontAASettings::getSubPixelType()
+{
+  int t;
+
+  for(t=KXftConfig::SubPixel::None; t<=KXftConfig::SubPixel::Vbgr; ++t)
+    if(subPixelType->currentText()==i18n(KXftConfig::description((KXftConfig::SubPixel::Type)t).toUtf8()))
+      return (KXftConfig::SubPixel::Type)t;
+
+  return KXftConfig::SubPixel::None;
+}
+
+int FontAASettings::getIndex(KXftConfig::Hint::Style hStyle)
+{
+  int pos=-1;
+  int index;
+
+  for(index=0; index<hintingStyle->count(); ++index)
+    if(hintingStyle->itemText(index)==i18n(KXftConfig::description(hStyle).toUtf8()))
+    {
+      pos=index;
+      break;
+    }
+
+  return pos;
+}
+
+
+KXftConfig::Hint::Style FontAASettings::getHintStyle()
+{
+  int s;
+
+  for(s=KXftConfig::Hint::NotSet; s<=KXftConfig::Hint::Full; ++s)
+    if(hintingStyle->currentText()==i18n(KXftConfig::description((KXftConfig::Hint::Style)s).toUtf8()))
+      return (KXftConfig::Hint::Style)s;
+
+  return KXftConfig::Hint::Medium;
+}
+
+void FontAASettings::enableWidgets()
+{
+  excludeFrom->setEnabled(excludeRange->isChecked());
+  excludeTo->setEnabled(excludeRange->isChecked());
+  excludeToLabel->setEnabled(excludeRange->isChecked());
+  subPixelType->setEnabled(useSubPixel->isChecked());
+#ifdef FT_LCD_FILTER_H
+  static int ft_has_subpixel = -1;
+  if( ft_has_subpixel == -1 ) {
+    FT_Library            ftLibrary;
+    if(FT_Init_FreeType(&ftLibrary) == 0) {
+      ft_has_subpixel = ( FT_Library_SetLcdFilter(ftLibrary, FT_LCD_FILTER_DEFAULT )
+        == FT_Err_Unimplemented_Feature ) ? 0 : 1;
+      FT_Done_FreeType(ftLibrary);
+    }
+  }
+  useSubPixel->setEnabled(ft_has_subpixel);
+  subPixelType->setEnabled(ft_has_subpixel);
+#endif
+}
+#endif
+
+void FontAASettings::changed()
+{
+#ifdef HAVE_FONTCONFIG
+    changesMade=true;
+    enableWidgets();
+#endif
+}
+
+#ifdef HAVE_FONTCONFIG
+int FontAASettings::exec()
+{
+    int i=KDialog::exec();
+
+    if(!i)
+        load(); // Reset settings...
+
+    return i && changesMade;
+}
+#endif
+
+/**** KFonts ****/
+
+KFonts::KFonts(QWidget *parent, const QVariantList &args)
+    :   KCModule(FontFactory::componentData(), parent, args)
+{
+  QStringList nameGroupKeyRc;
+
+  nameGroupKeyRc
+    << i18n("General")        << "General"    << "font"         << ""
+    << i18n("Fixed width")    << "General"    << "fixed"        << ""
+    << i18n("Small")          << "General"    << "smallestReadableFont" << ""
+    << i18n("Toolbar")        << "General"    << "toolBarFont"  << ""
+    << i18n("Menu")           << "General"    << "menuFont"     << ""
+    << i18n("Window title")   << "WM"         << "activeFont"   << ""
+    << i18n("Taskbar")        << "General"    << "taskbarFont"  << ""
+    << i18n("Desktop")        << "General"    << "desktopFont" << "";
+
+  QList<QFont> defaultFontList;
+
+  // NOTE: keep in sync with kdelibs/kdeui/kernel/kglobalsettings.cpp
+
+  QFont f0("Sans Serif", 10);
+  QFont f1("Monospace", 10);
+  QFont f2("Sans Serif", 8);
+  QFont f3("Sans Serif", 9, QFont::Bold);
+  QFont f4("Sans Serif", 10);
+  QFont f5("Sans Serif", 8); // smallestReadableFont
+
+  defaultFontList << f0 << f1 << f5 << f2 << f0 << f3 << f4 << f0;
+
+  QList<bool> fixedList;
+
+  fixedList
+    <<  false
+    <<  true
+    <<  false
+    <<  false
+    <<  false
+    <<  false
+    <<  false
+    <<  false;
+
+  QStringList quickHelpList;
+
+  quickHelpList
+    << i18n("Used for normal text (e.g. button labels, list items).")
+    << i18n("A non-proportional font (i.e. typewriter font).")
+    << i18n("Smallest font that is still readable well.")
+    << i18n("Used to display text beside toolbar icons.")
+    << i18n("Used by menu bars and popup menus.")
+    << i18n("Used by the window titlebar.")
+    << i18n("Used by the taskbar.")
+    << i18n("Used for desktop icons.");
+
+  QVBoxLayout * layout = new QVBoxLayout(this );
+  layout->setMargin(0);
+
+  QGridLayout * fontUseLayout = new QGridLayout( );
+  layout->addLayout( fontUseLayout );
+  fontUseLayout->setColumnStretch(0, 0);
+  fontUseLayout->setColumnStretch(1, 1);
+  fontUseLayout->setColumnStretch(2, 0);
+
+  QList<QFont>::ConstIterator defaultFontIt(defaultFontList.begin());
+  QList<bool>::ConstIterator fixedListIt(fixedList.begin());
+  QStringList::ConstIterator quickHelpIt(quickHelpList.begin());
+  QStringList::ConstIterator it(nameGroupKeyRc.begin());
+
+  unsigned int count = 0;
+
+  while (it != nameGroupKeyRc.constEnd()) {
+
+    QString name = *it; it++;
+    QString group = *it; it++;
+    QString key = *it; it++;
+    QString file = *it; it++;
+
+    FontUseItem * i =
+      new FontUseItem(
+        this,
+        name,
+        group,
+        key,
+        file,
+        *defaultFontIt++,
+        *fixedListIt++
+      );
+
+    fontUseList.append(i);
+    connect(i, SIGNAL(fontSelected(const QFont &)), SLOT(fontSelected()));
+
+    QLabel * fontUse = new QLabel(i18nc("Font role", "%1: ", name), this);
+    fontUse->setAlignment(Qt::AlignRight | Qt::AlignVCenter);
+    fontUse->setWhatsThis( *quickHelpIt++);
+
+    fontUseLayout->addWidget(fontUse, count, 0);
+    fontUseLayout->addWidget(i, count, 1);
+
+    ++count;
+  }
+
+   QHBoxLayout *hblay = new QHBoxLayout();
+   layout->addLayout(hblay);
+   hblay->addStretch();
+   QPushButton * fontAdjustButton = new QPushButton(i18n("Ad&just All Fonts..."), this);
+   fontAdjustButton->setWhatsThis( i18n("Click to change all fonts"));
+   hblay->addWidget( fontAdjustButton );
+   connect(fontAdjustButton, SIGNAL(clicked()), SLOT(slotApplyFontDiff()));
+
+   layout->addSpacing(KDialog::spacingHint());
+
+   QGridLayout* lay = new QGridLayout();
+   layout->addLayout(lay);
+   lay->setColumnStretch( 3, 10 );
+   QLabel* label=0L;
+#ifdef HAVE_FONTCONFIG
+   label = new QLabel( i18n( "Use a&nti-aliasing:" ), this );
+   label->setAlignment(Qt::AlignRight | Qt::AlignVCenter);
+   lay->addWidget( label, 0, 0 );
+   cbAA = new QComboBox( this );
+   cbAA->insertItem( AAEnabled, i18nc( "Use anti-aliasing", "Enabled" )); // change AASetting type if order changes
+   cbAA->insertItem( AASystem, i18nc( "Use anti-aliasing", "System Settings" ));
+   cbAA->insertItem( AADisabled, i18nc( "Use anti-aliasing", "Disabled" ));
+   cbAA->setWhatsThis( i18n("If this option is selected, KDE will smooth the edges of curves in "
+                              "fonts."));
+   aaSettingsButton = new QPushButton( i18n( "Configure..." ), this);
+   connect(aaSettingsButton, SIGNAL(clicked()), SLOT(slotCfgAa()));
+   label->setBuddy( cbAA );
+   lay->addWidget( cbAA, 0, 1 );
+   lay->addWidget( aaSettingsButton, 0, 2 );
+   connect(cbAA, SIGNAL(activated(int)), SLOT(slotUseAntiAliasing()));
+#endif
+   label = new QLabel( i18n( "Force fonts DPI:" ), this );
+   label->setAlignment(Qt::AlignRight | Qt::AlignVCenter);
+   lay->addWidget( label, 1, 0 );
+   comboForceDpi = new QComboBox( this );
+   label->setBuddy( comboForceDpi );
+   comboForceDpi->insertItem( DPINone, i18nc("Force fonts DPI", "Disabled" )); // change DPISetti ng type if order changes
+   comboForceDpi->insertItem( DPI96, i18n( "96 DPI" ));
+   comboForceDpi->insertItem( DPI120, i18n( "120 DPI" ));
+   QString whatsthis = i18n(
+       "<p>This option forces a specific DPI value for fonts. It may be useful"
+       " when the real DPI of the hardware is not detected properly and it"
+       " is also often misused when poor quality fonts are used that do not"
+       " look well with DPI values other than 96 or 120 DPI.</p>"
+       "<p>The use of this option is generally discouraged. For selecting proper DPI"
+       " value a better option is explicitly configuring it for the whole X server if"
+       " possible (e.g. DisplaySize in xorg.conf or adding <i>-dpi value</i> to"
+       " ServerLocalArgs= in $KDEDIR/share/config/kdm/kdmrc). When fonts do not render"
+       " properly with real DPI value better fonts should be used or configuration"
+       " of font hinting should be checked.</p>" );
+   comboForceDpi->setWhatsThis(whatsthis);
+   connect( comboForceDpi, SIGNAL( activated( int )), SLOT( changed()));
+   lay->addWidget( comboForceDpi, 1, 1 );
+
+   layout->addStretch(1);
+
+#ifdef HAVE_FONTCONFIG
+   aaSettings=new FontAASettings(this);
+#endif
+
+}
+
+KFonts::~KFonts()
+{
+  QList<FontUseItem *>::Iterator it(fontUseList.begin()),
+                                 end(fontUseList.end());
+
+  for(; it!=end; ++it)
+    delete (*it);
+  fontUseList.clear();
+}
+
+void KFonts::fontSelected()
+{
+  emit changed(true);
+}
+
+void KFonts::defaults()
+{
+  for ( int i = 0; i < (int) fontUseList.count(); i++ )
+    fontUseList.at( i )->setDefault();
+
+#ifdef HAVE_FONTCONFIG
+  useAA = AASystem;
+  cbAA->setCurrentIndex( useAA );
+  aaSettings->defaults();
+#endif
+  comboForceDpi->setCurrentIndex( DPINone );
+  emit changed(true);
+}
+
+void KFonts::load()
+{
+  QList<FontUseItem *>::Iterator it(fontUseList.begin()),
+                                 end(fontUseList.end());
+
+  for(; it!=end; ++it)
+    (*it)->readFont();
+
+#ifdef HAVE_FONTCONFIG
+  useAA_original = useAA = aaSettings->load() ? AAEnabled : AADisabled;
+  cbAA->setCurrentIndex( useAA );
+#endif
+
+  KConfig _cfgfonts( "kcmfonts" );
+  KConfigGroup cfgfonts(&_cfgfonts, "General");
+  int dpicfg = cfgfonts.readEntry( "forceFontDPI", 0 );
+  DPISetting dpi = dpicfg == 120 ? DPI120 : dpicfg == 96 ? DPI96 : DPINone;
+  comboForceDpi->setCurrentIndex( dpi );
+  dpi_original = dpi;
+#ifdef HAVE_FONTCONFIG
+  if( cfgfonts.readEntry( "dontChangeAASettings", true )) {
+      useAA_original = useAA = AASystem;
+      cbAA->setCurrentIndex( useAA );
+  }
+  aaSettingsButton->setEnabled( cbAA->currentIndex() == AAEnabled );
+#endif
+
+  emit changed(false);
+}
+
+void KFonts::save()
+{
+  QList<FontUseItem *>::Iterator it(fontUseList.begin()),
+                                 end(fontUseList.end());
+
+  for(; it!=end; ++it)
+      (*it)->writeFont();
+
+  KGlobal::config()->sync();
+
+  KConfig _cfgfonts( "kcmfonts" );
+  KConfigGroup cfgfonts(&_cfgfonts, "General");
+  DPISetting dpi = static_cast< DPISetting >( comboForceDpi->currentIndex());
+  const int dpi2value[] = { 0, 96, 120 };
+  cfgfonts.writeEntry( "forceFontDPI", dpi2value[ dpi ] );
+#ifdef HAVE_FONTCONFIG
+  cfgfonts.writeEntry( "dontChangeAASettings", cbAA->currentIndex() == AASystem );
+#endif
+  cfgfonts.sync();
+  // if the setting is reset in the module, remove the dpi value,
+  // otherwise don't explicitly remove it and leave any possible system-wide value
+  if( dpi == DPINone && dpi_original != DPINone ) {
+      KProcess proc;
+      proc << "xrdb" << "-quiet" << "-remove" << "-nocpp";
+      proc.start();
+      if (proc.waitForStarted()) {
+        proc.write( QByteArray( "Xft.dpi\n" ) );
+        proc.closeWriteChannel();
+        proc.waitForFinished();
+      }
+  }
+
+  // KDE-1.x support
+  {
+  KConfig config( QDir::homePath() + "/.kderc", KConfig::SimpleConfig);
+  KConfigGroup grp(&config, "General");
+
+  for(it=fontUseList.begin(); it!=end; ++it) {
+      if("font"==(*it)->rcKey())
+          QSettings().setValue("/qt/font", (*it)->font().toString());
+      kDebug(1208) << "write entry " <<  (*it)->rcKey();
+      grp.writeEntry( (*it)->rcKey(), (*it)->font() );
+  }
+  config.sync();
+  }
+
+  KGlobalSettings::self()->emitChange(KGlobalSettings::FontChanged);
+
+  kapp->processEvents(); // Process font change ourselves
+
+
+  // Don't overwrite global settings unless explicitly asked for - e.g. the system
+  // fontconfig setup may be much more complex than this module can provide.
+  // TODO: With AASystem the changes already made by this module should be reverted somehow.
+#ifdef HAVE_FONTCONFIG
+  bool aaSave = false;
+  if( cbAA->currentIndex() != AASystem )
+      aaSave = aaSettings->save( useAA == AAEnabled );
+
+  if( aaSave || (useAA != useAA_original) || dpi != dpi_original) {
+    KMessageBox::information(this,
+      i18n(
+        "<p>Some changes such as anti-aliasing will only affect newly started applications.</p>"
+      ), i18n("Font Settings Changed"), "FontSettingsChanged", false);
+    useAA_original = useAA;
+    dpi_original = dpi;
+  }
+#else
+  if(dpi != dpi_original) {
+    KMessageBox::information(this,
+      i18n(
+        "<p>Some changes such as DPI will only affect newly started applications.</p>"
+      ), i18n("Font Settings Changed"), "FontSettingsChanged", false);
+    dpi_original = dpi;
+  }
+#endif
+  runRdb(KRdbExportXftSettings);
+
+  emit changed(false);
+}
+
+
+void KFonts::slotApplyFontDiff()
+{
+  QFont font = QFont(fontUseList.first()->font());
+	KFontChooser::FontDiffFlags fontDiffFlags = 0;
+  int ret = KFontDialog::getFontDiff(font,fontDiffFlags,KFontChooser::NoDisplayFlags,this);
+
+  if (ret == KDialog::Accepted && fontDiffFlags)
+  {
+    for ( int i = 0; i < (int) fontUseList.count(); i++ )
+      fontUseList.at( i )->applyFontDiff( font,fontDiffFlags );
+    emit changed(true);
+  }
+}
+
+void KFonts::slotUseAntiAliasing()
+{
+#ifdef HAVE_FONTCONFIG
+    useAA = static_cast< AASetting >( cbAA->currentIndex());
+    aaSettingsButton->setEnabled( cbAA->currentIndex() == AAEnabled );
+    emit changed(true);
+#endif
+}
+
+void KFonts::slotCfgAa()
+{
+#ifdef HAVE_FONTCONFIG
+  if(aaSettings->exec())
+  {
+    emit changed(true);
+  }
+#endif
+}
+
+// vim:ts=2:sw=2:tw=78
diff -Nru kdebase-workspace-4.3.73svn1040395/kcontrol/kdm/background.cpp kdebase-workspace-4.3.73svn1040395-new/kcontrol/kdm/background.cpp
--- kdebase-workspace-4.3.73svn1040395/kcontrol/kdm/background.cpp	2009-08-05 11:56:09.000000000 +0200
+++ kdebase-workspace-4.3.73svn1040395-new/kcontrol/kdm/background.cpp	2009-10-28 22:58:08.000000000 +0100
@@ -44,7 +44,7 @@
 		" specified in the Setup= option in kdmrc (usually Xsetup).") );
 	m_simpleConf = KSharedConfig::openConfig(
 		config->group( "X-*-Greeter" ).readEntry(
-			"BackgroundCfg", KDE_CONFDIR "/kdm/backgroundrc" ) );
+			"BackgroundCfg", "/etc/X11/kdm/backgroundrc" ) );
 	m_background = new BGDialog( this, m_simpleConf );
 
 	connect( m_background, SIGNAL(changed( bool )), SIGNAL(changed()) );
diff -Nru kdebase-workspace-4.3.73svn1040395/kcontrol/kdm/background.cpp.orig kdebase-workspace-4.3.73svn1040395-new/kcontrol/kdm/background.cpp.orig
--- kdebase-workspace-4.3.73svn1040395/kcontrol/kdm/background.cpp.orig	1970-01-01 01:00:00.000000000 +0100
+++ kdebase-workspace-4.3.73svn1040395-new/kcontrol/kdm/background.cpp.orig	2009-08-05 11:56:09.000000000 +0200
@@ -0,0 +1,101 @@
+/*
+ * This file is part of the KDE project, module kcmdisplay.
+ * Copyright (C) 1999 Geert Jansen <g.t.jansen@stud.tue.nl>
+ *
+ * Modified 2000.07.14 by Brad Hughes <bhughes@trolltech.com>
+ * Improve layout and consistency with KDesktop's background selection
+ *
+ * Based on old backgnd.cpp:
+ *
+ * Copyright (c)  Martin R. Jones 1996
+ * Converted to a kcc module by Matthias Hoelzer 1997
+ * Gradient backgrounds by Mark Donohoe 1997
+ * Pattern backgrounds by Stephan Kulow 1998
+ * Randomizing & dnd & new display modes by Matej Koss 1998
+ *
+ * You can Freely distribute this program under the GNU General Public
+ * License. See the file "COPYING" for the exact licensing terms.
+ */
+
+#include "background.h"
+
+#include <config-workspace.h>
+
+#include "../background/bgdialog.h"
+
+#include <KLocale>
+#include <KConfig>
+
+#include <QCheckBox>
+#include <QVBoxLayout>
+
+extern KConfig *config;
+
+KBackground::KBackground( QWidget *parent )
+	: QWidget( parent )
+{
+
+	// Enabling checkbox
+	m_pCBEnable = new QCheckBox( i18n("E&nable background"), this );
+	m_pCBEnable->setWhatsThis( i18n(
+		"If this is checked, KDM will use the settings below for the background."
+		" If it is disabled, you have to look after the background yourself."
+		" This is done by running some program (possibly xsetroot) in the script"
+		" specified in the Setup= option in kdmrc (usually Xsetup).") );
+	m_simpleConf = KSharedConfig::openConfig(
+		config->group( "X-*-Greeter" ).readEntry(
+			"BackgroundCfg", KDE_CONFDIR "/kdm/backgroundrc" ) );
+	m_background = new BGDialog( this, m_simpleConf );
+
+	connect( m_background, SIGNAL(changed( bool )), SIGNAL(changed()) );
+
+	// Top layout
+	QVBoxLayout *top = new QVBoxLayout( this );
+	top->setMargin( KDialog::marginHint() );
+	top->setSpacing( KDialog::spacingHint() );
+	top->addWidget( m_pCBEnable );
+	top->addWidget( m_background );
+	top->addStretch();
+	connect( m_pCBEnable, SIGNAL(toggled( bool )), SLOT(slotEnableChanged()) );
+}
+
+KBackground::~KBackground()
+{
+}
+
+void KBackground::slotEnableChanged()
+{
+	bool en = m_pCBEnable->isChecked();
+	m_background->setEnabled( en );
+	emit changed();
+}
+
+void KBackground::makeReadOnly()
+{
+	m_pCBEnable->setEnabled( false );
+	m_background->makeReadOnly();
+}
+
+void KBackground::load()
+{
+	m_pCBEnable->setChecked( config->group( "X-*-Greeter" ).readEntry( "UseBackground", true ) );
+	m_background->load();
+	slotEnableChanged();
+}
+
+
+void KBackground::save()
+{
+	config->group( "X-*-Greeter" ).writeEntry( "UseBackground", m_pCBEnable->isChecked() );
+	m_background->save();
+}
+
+
+void KBackground::defaults()
+{
+	m_pCBEnable->setChecked( true );
+	slotEnableChanged();
+	m_background->defaults();
+}
+
+#include "background.moc"
diff -Nru kdebase-workspace-4.3.73svn1040395/kcontrol/kdm/kdm-users.cpp kdebase-workspace-4.3.73svn1040395-new/kcontrol/kdm/kdm-users.cpp
--- kdebase-workspace-4.3.73svn1040395/kcontrol/kdm/kdm-users.cpp	2009-08-05 11:56:09.000000000 +0200
+++ kdebase-workspace-4.3.73svn1040395-new/kcontrol/kdm/kdm-users.cpp	2009-10-28 22:58:08.000000000 +0100
@@ -85,7 +85,7 @@
 
 	// We assume that $kde_datadir/kdm exists, but better check for pics/ and pics/users,
 	// and create them if necessary.
-	m_userPixDir = config->group( "X-*-Greeter" ).readEntry( "FaceDir", KStandardDirs::installPath( "data" ) + "kdm/faces" ) + '/';
+	m_userPixDir = config->group( "X-*-Greeter" ).readEntry( "FaceDir", "/etc/X11/kdm/faces" ) + '/';
 	QDir testDir( m_userPixDir );
 	if (!testDir.exists() && !testDir.mkdir( testDir.absolutePath() ) && !geteuid())
 		KMessageBox::sorry( this, i18n("Unable to create folder %1", testDir.absolutePath() ) );
diff -Nru kdebase-workspace-4.3.73svn1040395/kcontrol/kdm/kdm-users.cpp.orig kdebase-workspace-4.3.73svn1040395-new/kcontrol/kdm/kdm-users.cpp.orig
--- kdebase-workspace-4.3.73svn1040395/kcontrol/kdm/kdm-users.cpp.orig	1970-01-01 01:00:00.000000000 +0100
+++ kdebase-workspace-4.3.73svn1040395-new/kcontrol/kdm/kdm-users.cpp.orig	2009-08-05 11:56:09.000000000 +0200
@@ -0,0 +1,548 @@
+/*
+    Copyright (C) 1997 Thomas Tanghus (tanghus@earthling.net)
+
+    This program is free software; you can redistribute it and/or
+    modify it under the terms of the GNU General Public
+    License as published by the Free Software Foundation; either
+    version 2 of the License, or (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    General Public License for more details.
+
+    You should have received a copy of the GNU Library General Public License
+    along with this library; see the file COPYING.LIB.  If not, write to
+    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+    Boston, MA 02110-1301, USA.
+*/
+
+#include "kdm-users.h"
+
+#include <KUrl>
+#include <KComboBox>
+#include <KIconDialog>
+#include <KLineEdit>
+#include <KLocale>
+#include <KMessageBox>
+#include <KConfig>
+#include <KConfigGroup>
+#include <KStandardDirs>
+#include <KStandardGuiItem>
+#include <KIO/NetAccess>
+
+#include <QButtonGroup>
+#include <QCheckBox>
+#include <QDir>
+#include <QDragEnterEvent>
+#include <QEvent>
+#include <QFile>
+#include <QGroupBox>
+#include <QIntValidator>
+#include <QLabel>
+#include <QPushButton>
+#include <QRadioButton>
+#include <QStackedWidget>
+#include <QStyle>
+#include <QTreeWidget>
+#include <QGridLayout>
+#include <QHBoxLayout>
+#include <QVBoxLayout>
+
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <limits.h>
+#include <unistd.h>
+#include <pwd.h>
+
+extern KConfig *config;
+
+KDMUsersWidget::KDMUsersWidget( QWidget *parent )
+	: QWidget( parent ), m_readOnly( false )
+{
+#ifdef __linux__
+	struct stat st;
+	if (!stat( "/etc/debian_version", &st )) { /* debian */
+		defminuid = "1000";
+		defmaxuid = "29999";
+	} else if (!stat( "/usr/portage", &st )) { /* gentoo */
+		defminuid = "1000";
+		defmaxuid = "65000";
+	} else if (!stat( "/etc/mandrake-release", &st )) { /* mandrake - check before redhat! */
+		defminuid = "500";
+		defmaxuid = "65000";
+	} else if (!stat( "/etc/redhat-release", &st )) { /* redhat */
+		defminuid = "100";
+		defmaxuid = "65000";
+	} else /* if (!stat( "/etc/SuSE-release", &st )) */ { /* suse */
+		defminuid = "500";
+		defmaxuid = "65000";
+	}
+#else
+	defminuid = "1000";
+	defmaxuid = "65000";
+#endif
+
+	// We assume that $kde_datadir/kdm exists, but better check for pics/ and pics/users,
+	// and create them if necessary.
+	m_userPixDir = config->group( "X-*-Greeter" ).readEntry( "FaceDir", KStandardDirs::installPath( "data" ) + "kdm/faces" ) + '/';
+	QDir testDir( m_userPixDir );
+	if (!testDir.exists() && !testDir.mkdir( testDir.absolutePath() ) && !geteuid())
+		KMessageBox::sorry( this, i18n("Unable to create folder %1", testDir.absolutePath() ) );
+	if (!getpwnam( "nobody" ) && !geteuid())
+		KMessageBox::sorry( this, i18n(
+			"User 'nobody' does not exist. "
+			"Displaying user images will not work in KDM.") );
+
+	m_defaultText = i18n("<placeholder>default</placeholder>");
+
+	QString wtstr;
+
+	minGroup = new QGroupBox( i18nc(
+		"@title:group UIDs belonging to system users like 'cron'", "System U&IDs"), this );
+	minGroup->setWhatsThis( i18n(
+		"Users with a UID (numerical user identification) outside this range "
+		"will not be listed by KDM and this setup dialog. "
+		"Note that users with the UID 0 (typically root) are not affected by "
+		"this and must be explicitly excluded in \"Inverse selection\" mode.") );
+	QSizePolicy sp_ign_fix( QSizePolicy::Ignored, QSizePolicy::Fixed );
+	QValidator *valid = new QIntValidator( 0, INT_MAX, minGroup );
+	QLabel *minlab = new QLabel( i18nc("UIDs", "Below:"), minGroup );
+	leminuid = new KLineEdit( minGroup );
+	minlab->setBuddy( leminuid );
+	leminuid->setSizePolicy( sp_ign_fix );
+	leminuid->setValidator( valid );
+	connect( leminuid, SIGNAL(textChanged( const QString & )), SIGNAL(changed()) );
+	connect( leminuid, SIGNAL(textChanged( const QString & )), SLOT(slotMinMaxChanged()) );
+	QLabel *maxlab = new QLabel( i18nc("UIDs", "Above:"), minGroup );
+	lemaxuid = new KLineEdit( minGroup );
+	maxlab->setBuddy( lemaxuid );
+	lemaxuid->setSizePolicy( sp_ign_fix );
+	lemaxuid->setValidator( valid );
+	connect( lemaxuid, SIGNAL(textChanged( const QString & )), SIGNAL(changed()) );
+	connect( lemaxuid, SIGNAL(textChanged( const QString & )), SLOT(slotMinMaxChanged()) );
+	QGridLayout *grid = new QGridLayout( minGroup );
+	grid->addWidget( minlab, 0, 0 );
+	grid->addWidget( leminuid, 0, 1 );
+	grid->addWidget( maxlab, 1, 0 );
+	grid->addWidget( lemaxuid, 1, 1 );
+
+	usrGroup = new QGroupBox( i18nc("@title:group", "Users"), this );
+	cbshowlist = new QCheckBox( i18nc("... of users", "Show list"), usrGroup );
+	cbshowlist->setWhatsThis( i18n(
+		"If this option is checked, KDM will show a list of users, so users can "
+		"click on their name or image rather than typing in their login.") );
+	cbcomplete = new QCheckBox( i18nc("user ...", "Autocompletion"), usrGroup );
+	cbcomplete->setWhatsThis( i18n(
+		"If this option is checked, KDM will automatically complete "
+		"user names while they are typed in the line edit.") );
+	cbinverted = new QCheckBox( i18nc(
+		"@option:check mode of the user selection", "Inverse selection"), usrGroup );
+	cbinverted->setWhatsThis( i18n(
+		"This option specifies how the users for \"Show list\" and \"Autocompletion\" "
+		"are selected in the \"Select users and groups\" list: "
+		"If not checked, select only the checked users. "
+		"If checked, select all non-system users, except the checked ones.") );
+	cbusrsrt = new QCheckBox( i18n("Sor&t users"), usrGroup );
+	cbusrsrt->setWhatsThis( i18n(
+		"If this is checked, KDM will alphabetically sort the user list. "
+		"Otherwise users are listed in the order they appear in the password file.") );
+	QButtonGroup *buttonGroup = new QButtonGroup( usrGroup );
+	buttonGroup->setExclusive( false );
+	connect( buttonGroup, SIGNAL(buttonClicked( int )), SLOT(slotShowOpts()) );
+	connect( buttonGroup, SIGNAL(buttonClicked( int )), SIGNAL(changed()) );
+	buttonGroup->addButton( cbshowlist );
+	buttonGroup->addButton( cbcomplete );
+	buttonGroup->addButton( cbinverted );
+	buttonGroup->addButton( cbusrsrt );
+	QBoxLayout *box = new QVBoxLayout( usrGroup );
+	box->addWidget( cbshowlist );
+	box->addWidget( cbcomplete );
+	box->addWidget( cbinverted );
+	box->addWidget( cbusrsrt );
+
+	wstack = new QStackedWidget( this );
+	s_label = new QLabel( i18n("S&elect users and groups:"), this );
+	s_label->setBuddy( wstack );
+	optinlv = new QTreeWidget( this );
+	optinlv->setRootIsDecorated( false );
+	optinlv->setHeaderLabel( i18n("Selected Users") );
+	optinlv->setWhatsThis( i18n(
+		"KDM will show all checked users. Entries denoted with '@' are user groups. "
+		"Checking a group is like checking all users in that group.") );
+	wstack->addWidget( optinlv );
+	connect( optinlv, SIGNAL(itemClicked( QTreeWidgetItem *, int )),
+	         SLOT(slotUpdateOptIn( QTreeWidgetItem * )) );
+	connect( optinlv, SIGNAL(itemClicked( QTreeWidgetItem *, int )),
+	         SIGNAL(changed()) );
+	optoutlv = new QTreeWidget( this );
+	optoutlv->setRootIsDecorated( false );
+	optoutlv->setHeaderLabel( i18n("Excluded Users") );
+	optoutlv->setWhatsThis( i18n(
+		"KDM will show all non-checked non-system users. Entries denoted with '@' "
+		"are user groups. Checking a group is like checking all users in that group.") );
+	wstack->addWidget( optoutlv );
+	connect( optoutlv, SIGNAL(itemClicked( QTreeWidgetItem *, int )),
+	         SLOT(slotUpdateOptOut( QTreeWidgetItem * )) );
+	connect( optoutlv, SIGNAL(itemClicked( QTreeWidgetItem *, int )),
+	         SIGNAL(changed()) );
+
+	faceGroup = new QGroupBox( i18nc(
+		"@title:group source for user faces", "User Image Source"), this );
+	faceGroup->setWhatsThis( i18n(
+		"Here you can specify where KDM will obtain the images that represent users. "
+		"\"System\" represents the global folder; these are the pictures you can set below. "
+		"\"User\" means that KDM should read the user's $HOME/.face.icon file. "
+		"The two selections in the middle define the order of preference if both sources are available.") );
+	rbadmonly = new QRadioButton( i18nc("@option:radio image source", "System"), faceGroup );
+	rbprefadm = new QRadioButton( i18nc("@option:radio image source", "System, user"), faceGroup );
+	rbprefusr = new QRadioButton( i18nc("@option:radio image source", "User, system"), faceGroup );
+	rbusronly = new QRadioButton( i18nc("@option:radio image source", "User"), faceGroup );
+	buttonGroup = new QButtonGroup( faceGroup );
+	connect( buttonGroup, SIGNAL(buttonClicked( int )), SLOT(slotFaceOpts()) );
+	connect( buttonGroup, SIGNAL(buttonClicked( int )), SIGNAL(changed()) );
+	buttonGroup->addButton( rbadmonly );
+	buttonGroup->addButton( rbprefadm );
+	buttonGroup->addButton( rbprefusr );
+	buttonGroup->addButton( rbusronly );
+	box = new QVBoxLayout( faceGroup );
+	box->addWidget( rbadmonly );
+	box->addWidget( rbprefadm );
+	box->addWidget( rbprefusr );
+	box->addWidget( rbusronly );
+
+	QGroupBox *picGroup = new QGroupBox( i18nc(
+		"@title:group user face assignments", "User Images"), this );
+	usercombo = new KComboBox( picGroup );
+	usercombo->setWhatsThis( i18n("The user the image below belongs to.") );
+	connect( usercombo, SIGNAL(activated( int )),
+	         SLOT(slotUserSelected()) );
+	QLabel *userlabel = new QLabel( i18n("User:"), picGroup );
+	userlabel->setBuddy( usercombo );
+	userbutton = new QPushButton( picGroup );
+	userbutton->setAcceptDrops( true );
+	userbutton->installEventFilter( this ); // for drag and drop
+	uint sz = style()->pixelMetric( QStyle::PM_ButtonMargin ) * 2 + 48;
+	userbutton->setFixedSize( sz, sz );
+	connect( userbutton, SIGNAL(clicked()),
+	         SLOT(slotUserButtonClicked()) );
+	userbutton->setToolTip( i18n("Click or drop an image here") );
+	userbutton->setWhatsThis( i18n(
+		"Here you can see the image assigned to the user selected in the combo "
+		"box above. Click on the image button to select from a list of images "
+		"or drag and drop your own image on to the button (e.g. from Konqueror).") );
+	rstuserbutton = new QPushButton( i18nc(
+		"@action:button assign default user face", "R&eset"), picGroup );
+	rstuserbutton->setWhatsThis( i18n(
+		"Click this button to make KDM use the default image for the selected user.") );
+	connect( rstuserbutton, SIGNAL(clicked()),
+	         SLOT(slotUnsetUserPix()) );
+	QGridLayout *hlpl = new QGridLayout( picGroup );
+	hlpl->setSpacing( KDialog::spacingHint() );
+	hlpl->addWidget( userlabel, 0, 0 );
+	hlpl->addWidget( usercombo, 0, 1 ); // XXX this makes the layout too wide
+	hlpl->addWidget( userbutton, 1, 0, 1, 2, Qt::AlignHCenter );
+	hlpl->addWidget( rstuserbutton, 2, 0, 1, 2, Qt::AlignHCenter );
+
+	QHBoxLayout *main = new QHBoxLayout( this );
+	main->setSpacing( 10 );
+
+	QVBoxLayout *lLayout = new QVBoxLayout();
+	main->addItem( lLayout );
+	lLayout->setSpacing( 10 );
+	lLayout->addWidget( minGroup );
+	lLayout->addWidget( usrGroup );
+	lLayout->addStretch( 1 );
+
+	QVBoxLayout *mLayout = new QVBoxLayout();
+	main->addItem( mLayout );
+	mLayout->setSpacing( 10 );
+	mLayout->addWidget( s_label );
+	mLayout->addWidget( wstack );
+	mLayout->setStretchFactor( wstack, 1 );
+	main->setStretchFactor( mLayout, 1 );
+
+	QVBoxLayout *rLayout = new QVBoxLayout();
+	main->addItem( rLayout );
+	rLayout->setSpacing( 10 );
+	rLayout->addWidget( faceGroup );
+	rLayout->addWidget( picGroup );
+	rLayout->addStretch( 1 );
+
+}
+
+void KDMUsersWidget::makeReadOnly()
+{
+	m_readOnly = true;
+	leminuid->setReadOnly( true );
+	lemaxuid->setReadOnly( true );
+	cbshowlist->setEnabled( false );
+	cbcomplete->setEnabled( false );
+	cbinverted->setEnabled( false );
+	cbusrsrt->setEnabled( false );
+	rbadmonly->setEnabled( false );
+	rbprefadm->setEnabled( false );
+	rbprefusr->setEnabled( false );
+	rbusronly->setEnabled( false );
+	wstack->setEnabled( false );
+	disconnect( userbutton, SIGNAL(clicked()), this, SLOT(slotUserButtonClicked()) );
+	userbutton->setAcceptDrops( false );
+	rstuserbutton->setEnabled( false );
+}
+
+void KDMUsersWidget::slotShowOpts()
+{
+	bool en = !m_readOnly && ( cbshowlist->isChecked() || cbcomplete->isChecked() );
+	cbinverted->setEnabled( en );
+	cbusrsrt->setEnabled( en );
+	wstack->setEnabled( en );
+	wstack->setCurrentWidget( cbinverted->isChecked() ? optoutlv : optinlv );
+	en = cbshowlist->isChecked();
+	faceGroup->setEnabled( en );
+	if (!en) {
+		usercombo->setEnabled( false );
+		userbutton->setEnabled( false );
+		rstuserbutton->setEnabled( false );
+	} else
+		slotFaceOpts();
+}
+
+void KDMUsersWidget::slotFaceOpts()
+{
+	bool en = !m_readOnly && !rbusronly->isChecked();
+	usercombo->setEnabled( en );
+	userbutton->setEnabled( en );
+	if (en)
+		slotUserSelected();
+	else
+		rstuserbutton->setEnabled( false );
+}
+
+void KDMUsersWidget::slotUserSelected()
+{
+	QString user = usercombo->currentText();
+	QImage p;
+	if (user != m_defaultText && p.load( m_userPixDir + user + ".face.icon" ))
+		rstuserbutton->setEnabled( !getuid() );
+	else {
+		p.load( m_userPixDir + ".default.face.icon" );
+		rstuserbutton->setEnabled( false );
+	}
+	userbutton->setIcon( QPixmap::fromImage( p.scaled( 48, 48, Qt::KeepAspectRatio, Qt::SmoothTransformation ) ) );
+}
+
+
+void KDMUsersWidget::changeUserPix( const QString &pix )
+{
+	QString user( usercombo->currentText() );
+	if (user == m_defaultText) {
+		user = ".default";
+		if (KMessageBox::questionYesNo( this, i18n("Save image as default?"),
+		                                QString(), KStandardGuiItem::save(),
+		                                KStandardGuiItem::cancel() ) != KMessageBox::Yes)
+			return;
+	}
+
+	QImage p( pix );
+	if (p.isNull()) {
+		KMessageBox::sorry( this,
+			i18n("There was an error loading the image\n%1", pix ) );
+		return;
+	}
+
+	p = p.scaled( 48, 48, Qt::KeepAspectRatio, Qt::SmoothTransformation );
+	QString userpix = m_userPixDir + user + ".face.icon";
+	if (!p.save( userpix, "PNG" ))
+		KMessageBox::sorry( this,
+			i18n("There was an error saving the image:\n%1", userpix ) );
+
+	slotUserSelected();
+}
+
+void KDMUsersWidget::slotUserButtonClicked()
+{
+	KIconDialog dlg;
+	dlg.setCustomLocation( KStandardDirs::installPath( "data" ) + "kdm/pics/users" );
+	dlg.setup( KIconLoader::NoGroup, KIconLoader::Any, false, 48, true, true, false );
+	QString ic = dlg.openDialog();
+	if (ic.isEmpty())
+		return;
+	changeUserPix( ic );
+}
+
+void KDMUsersWidget::slotUnsetUserPix()
+{
+	QFile::remove( m_userPixDir + usercombo->currentText() + ".face.icon" );
+	slotUserSelected();
+}
+
+bool KDMUsersWidget::eventFilter( QObject *, QEvent *e )
+{
+	if (e->type() == QEvent::DragEnter) {
+		QDragEnterEvent *ee = (QDragEnterEvent *)e;
+		ee->setAccepted( KUrl::List::canDecode( ee->mimeData() ) );
+		return true;
+	}
+
+	if (e->type() == QEvent::Drop) {
+		userButtonDropEvent( (QDropEvent *)e );
+		return true;
+	}
+
+	return false;
+}
+
+KUrl *decodeImgDrop( QDropEvent *e, QWidget *wdg );
+
+void KDMUsersWidget::userButtonDropEvent( QDropEvent *e )
+{
+	KUrl *url = decodeImgDrop( e, this );
+	if (url) {
+		QString pixpath;
+		KIO::NetAccess::download( *url, pixpath, parentWidget() );
+		changeUserPix( pixpath );
+		KIO::NetAccess::removeTempFile( pixpath );
+		delete url;
+	}
+}
+
+void KDMUsersWidget::save()
+{
+	KConfigGroup configGrp = config->group( "X-*-Greeter" );
+
+	configGrp.writeEntry( "MinShowUID", leminuid->text() );
+	configGrp.writeEntry( "MaxShowUID", lemaxuid->text() );
+
+	configGrp.writeEntry( "UserList", cbshowlist->isChecked() );
+	configGrp.writeEntry( "UserCompletion", cbcomplete->isChecked() );
+	configGrp.writeEntry( "ShowUsers",
+	                      cbinverted->isChecked() ? "NotHidden" : "Selected" );
+	configGrp.writeEntry( "SortUsers", cbusrsrt->isChecked() );
+
+	configGrp.writeEntry( "HiddenUsers", hiddenUsers );
+	configGrp.writeEntry( "SelectedUsers", selectedUsers );
+
+	configGrp.writeEntry( "FaceSource",
+	                      rbadmonly->isChecked() ? "AdminOnly" :
+	                      rbprefadm->isChecked() ? "PreferAdmin" :
+	                      rbprefusr->isChecked() ? "PreferUser" : "UserOnly" );
+}
+
+
+void KDMUsersWidget::updateOptList( QTreeWidgetItem *item, QStringList &list )
+{
+	if (!item)
+		return;
+	int ind = list.indexOf( item->text(0) );
+	if (item->checkState(0) == Qt::Checked) {
+		if (ind < 0)
+			list.append( item->text(0) );
+	} else {
+		if (ind >= 0)
+			list.removeAt( ind );
+	}
+}
+
+void KDMUsersWidget::slotUpdateOptIn( QTreeWidgetItem *item )
+{
+	updateOptList( item, selectedUsers );
+}
+
+void KDMUsersWidget::slotUpdateOptOut( QTreeWidgetItem *item )
+{
+	updateOptList( item, hiddenUsers );
+}
+
+void KDMUsersWidget::slotClearUsers()
+{
+	optinlv->clear();
+	optoutlv->clear();
+	usercombo->clear();
+	usercombo->addItem( m_defaultText );
+}
+
+void KDMUsersWidget::slotAddUsers( const QMap<QString,int> &users )
+{
+	QMap<QString,int>::const_iterator it;
+	for (it = users.begin(); it != users.end(); ++it) {
+		const QString *name = &it.key();
+		(new QTreeWidgetItem( optinlv, QStringList() << *name ))->
+			setCheckState( 0, selectedUsers.contains( *name ) ? Qt::Checked : Qt::Unchecked );
+		(new QTreeWidgetItem( optoutlv, QStringList() << *name ))->
+			setCheckState( 0, hiddenUsers.contains( *name ) ? Qt::Checked : Qt::Unchecked );
+		if ((*name)[0] != '@')
+			usercombo->addItem( *name );
+	}
+	optinlv->sortItems(0, Qt::AscendingOrder);
+	optoutlv->sortItems(0, Qt::AscendingOrder);
+	usercombo->model()->sort( 0 );
+	slotUserSelected();
+}
+
+void KDMUsersWidget::slotDelUsers( const QMap<QString,int> &users )
+{
+	QMap<QString,int>::const_iterator it;
+	for (it = users.begin(); it != users.end(); ++it) {
+		const QString *name = &it.key();
+		int idx = usercombo->findText( *name );
+		if (idx != -1)
+			usercombo->removeItem( idx );
+		qDeleteAll( optinlv->findItems( *name, 0, Qt::MatchExactly | Qt::MatchCaseSensitive ) );
+		qDeleteAll( optoutlv->findItems( *name, 0, Qt::MatchExactly | Qt::MatchCaseSensitive ) );
+	}
+}
+
+void KDMUsersWidget::load()
+{
+	QString str;
+
+	KConfigGroup configGrp = config->group( "X-*-Greeter" );
+
+	selectedUsers = configGrp.readEntry( "SelectedUsers", QStringList() );
+	hiddenUsers = configGrp.readEntry( "HiddenUsers", QStringList() );
+
+	leminuid->setText( configGrp.readEntry( "MinShowUID", defminuid ) );
+	lemaxuid->setText( configGrp.readEntry( "MaxShowUID", defmaxuid ) );
+
+	cbshowlist->setChecked( configGrp.readEntry( "UserList", true ) );
+	cbcomplete->setChecked( configGrp.readEntry( "UserCompletion", false ) );
+	cbinverted->setChecked( configGrp.readEntry( "ShowUsers" ) != "Selected" );
+	cbusrsrt->setChecked( configGrp.readEntry( "SortUsers", true ) );
+
+	QString ps = configGrp.readEntry( "FaceSource" );
+	if (ps == QLatin1String("UserOnly"))
+		rbusronly->setChecked( true );
+	else if (ps == QLatin1String("PreferUser"))
+		rbprefusr->setChecked( true );
+	else if (ps == QLatin1String("PreferAdmin"))
+		rbprefadm->setChecked( true );
+	else
+		rbadmonly->setChecked( true );
+
+	slotUserSelected();
+
+	slotShowOpts();
+	slotFaceOpts();
+}
+
+void KDMUsersWidget::defaults()
+{
+	leminuid->setText( defminuid );
+	lemaxuid->setText( defmaxuid );
+	cbshowlist->setChecked( true );
+	cbcomplete->setChecked( false );
+	cbinverted->setChecked( true );
+	cbusrsrt->setChecked( true );
+	rbadmonly->setChecked( true );
+	hiddenUsers.clear();
+	selectedUsers.clear();
+	slotShowOpts();
+	slotFaceOpts();
+}
+
+void KDMUsersWidget::slotMinMaxChanged()
+{
+	emit setMinMaxUID( leminuid->text().toInt(), lemaxuid->text().toInt() );
+}
+
+#include "kdm-users.moc"
diff -Nru kdebase-workspace-4.3.73svn1040395/kcontrol/kdm/main.cpp kdebase-workspace-4.3.73svn1040395-new/kcontrol/kdm/main.cpp
--- kdebase-workspace-4.3.73svn1040395/kcontrol/kdm/main.cpp	2009-04-05 22:00:13.000000000 +0200
+++ kdebase-workspace-4.3.73svn1040395-new/kcontrol/kdm/main.cpp	2009-10-28 22:58:08.000000000 +0100
@@ -186,7 +186,7 @@
 		kWarning() << "user(s) '" << tgmapci.value().join( "," )
 		<< "' have unknown GID " << tgmapci.key() << endl;
 
-	config = new KConfig( QString::fromLatin1(KDE_CONFDIR "/kdm/kdmrc"), KConfig::SimpleConfig );
+	config = new KConfig( QString::fromLatin1("/etc/X11/kdm/kdmrc"), KConfig::SimpleConfig );
 
 	QVBoxLayout *top = new QVBoxLayout( this );
 	top->setMargin( 0 );
diff -Nru kdebase-workspace-4.3.73svn1040395/kcontrol/kdm/main.cpp.orig kdebase-workspace-4.3.73svn1040395-new/kcontrol/kdm/main.cpp.orig
--- kdebase-workspace-4.3.73svn1040395/kcontrol/kdm/main.cpp.orig	1970-01-01 01:00:00.000000000 +0100
+++ kdebase-workspace-4.3.73svn1040395-new/kcontrol/kdm/main.cpp.orig	2009-04-05 22:00:13.000000000 +0200
@@ -0,0 +1,392 @@
+/*
+ * main.cpp
+ *
+ * Copyright (c) 1999 Matthias Hoelzer-Kluepfel <hoelzer@kde.org>
+ *
+ * Requires the Qt widget libraries, available at no cost at
+ * http://www.troll.no/
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ */
+
+#include "main.h"
+
+#include <config-workspace.h>
+
+#include "background.h"
+#include "kdm-gen.h"
+#include "kdm-dlg.h"
+#include "kdm-users.h"
+#include "kdm-shut.h"
+#include "kdm-conv.h"
+#include "kdm-theme.h"
+
+#include <kaboutdata.h>
+#include <kimageio.h>
+#include <klocale.h>
+#include <kmessagebox.h>
+#include <kdebug.h>
+#include <kmimetype.h>
+#include <kconfig.h>
+#include <kpluginfactory.h>
+#include <kpluginloader.h>
+
+#include <QDropEvent>
+#include <QFile>
+#include <QLabel>
+#include <QStackedWidget>
+#include <QTabWidget>
+#include <QVBoxLayout>
+
+#include <sys/types.h>
+#include <unistd.h>
+#include <locale.h>
+#include <pwd.h>
+#include <grp.h>
+
+
+K_PLUGIN_FACTORY(KDMFactory, registerPlugin<KDModule>();)
+K_EXPORT_PLUGIN(KDMFactory( "kdmconfig" ))
+
+KUrl *decodeImgDrop( QDropEvent *e, QWidget *wdg )
+{
+	KUrl::List uriList = KUrl::List::fromMimeData( e->mimeData() );
+	if (!uriList.isEmpty()) {
+		KUrl *url = new KUrl( uriList.first() );
+
+		KMimeType::Ptr mime = KMimeType::findByUrl( *url );
+		if (mime && KImageIO::isSupported( mime->name(), KImageIO::Reading ))
+			return url;
+
+		QStringList qs = KImageIO::pattern().split( '\n' );
+		qs.removeFirst();
+
+		QString msg = i18n( "%1 "
+		                    "does not appear to be an image file.\n"
+		                    "Please use files with these extensions:\n"
+		                    "%2",
+		                    url->fileName(),
+		                    qs.join( "\n" ));
+		KMessageBox::sorry( wdg, msg );
+		delete url;
+	}
+	return 0;
+}
+
+KConfig *config;
+
+KDModule::KDModule( QWidget *parent, const QVariantList & )
+	: KCModule( KDMFactory::componentData(), parent )
+	, minshowuid( 0 )
+	, maxshowuid( 0 )
+	, updateOK( false )
+{
+	KAboutData *about =
+		new KAboutData( "kcmkdm", "kdmconfig", ki18n("KDE Login Manager Config Module"),
+		                QByteArray(), KLocalizedString(), KAboutData::License_GPL,
+		                ki18n("(c) 1996-2008 The KDM Authors"), KLocalizedString(),
+		                "http://developer.kde.org/~ossi/sw/kdm.html" );
+
+	about->addAuthor( ki18n("Thomas Tanghus"), ki18n("Original author"), "tanghus@earthling.net" );
+	about->addAuthor( ki18n("Steffen Hansen"), KLocalizedString(), "hansen@kde.org" );
+	about->addAuthor( ki18n("Oswald Buddenhagen"), ki18n("Current maintainer"), "ossi@kde.org" );
+	about->addAuthor( ki18n("Stephen Leaf"), KLocalizedString(), "smileaf@smileaf.org" );
+
+	setQuickHelp( i18n(
+		"<h1>Login Manager</h1> In this module you can configure the "
+		"various aspects of the KDE Login Manager. This includes "
+		"the look and feel as well as the users that can be "
+		"selected for login. Note that you can only make changes "
+		"if you run the module with superuser rights. If you have not started the KDE "
+		"Control Center with superuser rights (which is absolutely the right thing to "
+		"do, by the way), click on the <em>Modify</em> button to acquire "
+		"superuser rights. You will be asked for the superuser password."
+		"<h2>General</h2> On this tab page, you can configure parts of "
+		"the Login Manager's look, and which language it should use. "
+		"The language settings made here have no influence on "
+		"the user's language settings."
+		"<h2>Dialog</h2>Here you can configure the look of the \"classical\" "
+		"dialog based mode if you have chosen to use it. "
+		"<h2>Background</h2>If you want to set a special background for the dialog based "
+		"login screen, this is where to do it."
+		"<h2>Themes</h2> Here you can specify a theme to be used by the Login Manager."
+		"<h2>Shutdown</h2> Here you can specify who is allowed to shutdown/reboot the machine "
+		"and whether a boot manager should be used."
+		"<h2>Users</h2>On this tab page, you can select which users the Login Manager "
+		"will offer you for logging in."
+		"<h2>Convenience</h2> Here you can specify a user to be logged in automatically, "
+		"users not needing to provide a password to log in, and other convenience features.<br/>"
+		"Note, that these settings are security holes by their nature, so use them very carefully.") );
+
+	setAboutData( about );
+
+	setlocale( LC_COLLATE, "C" );
+
+	KGlobal::locale()->insertCatalog( "kcmbackground" );
+
+	QStringList sl;
+	QMap<gid_t,QStringList> tgmap;
+	QMap<gid_t,QStringList>::Iterator tgmapi;
+	QMap<gid_t,QStringList>::ConstIterator tgmapci;
+	QMap<QString, QPair<int,QStringList> >::Iterator umapi;
+
+	struct passwd *ps;
+	for (setpwent(); (ps = getpwent()); ) {
+		QString un( QFile::decodeName( ps->pw_name ) );
+		if (usermap.find( un ) == usermap.end()) {
+			usermap.insert( un, QPair<int,QStringList>( ps->pw_uid, sl ) );
+			if ((tgmapi = tgmap.find( ps->pw_gid )) != tgmap.end())
+				(*tgmapi).append( un );
+			else
+				tgmap[ps->pw_gid] = QStringList(un);
+		}
+	}
+	endpwent();
+
+	struct group *grp;
+	for (setgrent(); (grp = getgrent()); ) {
+		QString gn( QFile::decodeName( grp->gr_name ) );
+		bool delme = false;
+		if ((tgmapi = tgmap.find( grp->gr_gid )) != tgmap.end()) {
+			if ((*tgmapi).count() == 1 && (*tgmapi).first() == gn)
+				delme = true;
+			else
+				for (QStringList::ConstIterator it = (*tgmapi).constBegin();
+				     it != (*tgmapi).constEnd(); ++it)
+			usermap[*it].second.append( gn );
+			tgmap.erase( tgmapi );
+		}
+		if (!*grp->gr_mem ||
+		    (delme && !grp->gr_mem[1] && gn == QFile::decodeName( *grp->gr_mem )))
+			continue;
+		do {
+			QString un( QFile::decodeName( *grp->gr_mem ) );
+			if ((umapi = usermap.find( un )) != usermap.end()) {
+				if (!(*umapi).second.contains( gn ))
+					(*umapi).second.append( gn );
+			} else
+				kWarning() << "group '" << gn << "' contains unknown user '" << un << "'" ;
+		} while (*++grp->gr_mem);
+	}
+	endgrent();
+
+	for (tgmapci = tgmap.constBegin(); tgmapci != tgmap.constEnd(); ++tgmapci)
+		kWarning() << "user(s) '" << tgmapci.value().join( "," )
+		<< "' have unknown GID " << tgmapci.key() << endl;
+
+	config = new KConfig( QString::fromLatin1(KDE_CONFDIR "/kdm/kdmrc"), KConfig::SimpleConfig );
+
+	QVBoxLayout *top = new QVBoxLayout( this );
+	top->setMargin( 0 );
+	tab = new QTabWidget( this );
+
+	general = new KDMGeneralWidget( this );
+	tab->addTab( general, i18n("&General") );
+	connect( general, SIGNAL(changed()), SLOT(changed()) );
+	connect( general, SIGNAL(useThemeChanged( bool )),
+	         SLOT(slotUseThemeChanged( bool )) );
+
+	dialog_stack = new QStackedWidget( this );
+	tab->addTab( dialog_stack, i18n("&Dialog") );
+	dialog = new KDMDialogWidget( dialog_stack );
+	dialog_stack->addWidget( dialog );
+	connect( dialog, SIGNAL(changed()), SLOT(changed()) );
+	QLabel *lbl = new QLabel(
+		i18n("There is no login dialog window in themed mode."),
+		dialog_stack );
+	lbl->setAlignment( Qt::AlignCenter );
+	dialog_stack->addWidget( lbl );
+
+	background_stack = new QStackedWidget( this );
+	tab->addTab( background_stack, i18n("&Background") );
+	background = new KBackground( background_stack );
+	background_stack->addWidget( background );
+	connect( background, SIGNAL(changed()), SLOT(changed()) );
+	lbl = new QLabel(
+		i18n("The background cannot be configured separately in themed mode."),
+		background_stack );
+	lbl->setAlignment( Qt::AlignCenter );
+	background_stack->addWidget( lbl );
+
+	theme_stack = new QStackedWidget( this );
+	tab->addTab( theme_stack, i18n("&Theme") );
+	lbl = new QLabel(
+		i18n("Themed mode is disabled. See \"General\" tab."),
+		theme_stack );
+	lbl->setAlignment( Qt::AlignCenter );
+	theme_stack->addWidget( lbl );
+	theme = new KDMThemeWidget( theme_stack );
+	theme_stack->addWidget( theme );
+	connect( theme, SIGNAL(changed()), SLOT(changed()) );
+
+	sessions = new KDMSessionsWidget( this );
+	tab->addTab( sessions, i18n("&Shutdown") );
+	connect( sessions, SIGNAL(changed()), SLOT(changed()) );
+
+	users = new KDMUsersWidget( this );
+	tab->addTab( users, i18n("&Users") );
+	connect( users, SIGNAL(changed()), SLOT(changed()) );
+	connect( users, SIGNAL(setMinMaxUID( int,int )), SLOT(slotMinMaxUID( int,int )) );
+	connect( this, SIGNAL(addUsers( const QMap<QString,int> & )),
+	         users, SLOT(slotAddUsers( const QMap<QString,int> & )) );
+	connect( this, SIGNAL(delUsers( const QMap<QString,int> & )),
+	         users, SLOT(slotDelUsers( const QMap<QString,int> & )) );
+	connect( this, SIGNAL(clearUsers()), users, SLOT(slotClearUsers()) );
+
+	convenience = new KDMConvenienceWidget( this );
+	tab->addTab( convenience, i18n("&Convenience") );
+	connect( convenience, SIGNAL(changed()), SLOT(changed()) );
+	connect( this, SIGNAL(addUsers( const QMap<QString,int> & )),
+	         convenience, SLOT(slotAddUsers( const QMap<QString,int> & )) );
+	connect( this, SIGNAL(delUsers( const QMap<QString,int> & )),
+	         convenience, SLOT(slotDelUsers( const QMap<QString,int> & )) );
+	connect( this, SIGNAL(clearUsers()), convenience, SLOT(slotClearUsers()) );
+
+	if (getuid() != 0 || !config->isConfigWritable( true )) {
+		general->makeReadOnly();
+		dialog->makeReadOnly();
+		background->makeReadOnly();
+		theme->makeReadOnly();
+		users->makeReadOnly();
+		sessions->makeReadOnly();
+		convenience->makeReadOnly();
+	}
+	top->addWidget( tab );
+}
+
+KDModule::~KDModule()
+{
+	delete config;
+}
+
+void KDModule::load()
+{
+	general->load();
+	dialog->load();
+	background->load();
+	theme->load();
+	users->load();
+	sessions->load();
+	convenience->load();
+	propagateUsers();
+
+	emit changed( false );
+}
+
+
+void KDModule::save()
+{
+	general->save();
+	dialog->save();
+	background->save();
+	theme->save();
+	users->save();
+	sessions->save();
+	convenience->save();
+	config->sync();
+
+	emit changed( false );
+}
+
+
+void KDModule::defaults()
+{
+	if (getuid() == 0) {
+		general->defaults();
+		dialog->defaults();
+		background->defaults();
+		theme->defaults();
+		users->defaults();
+		sessions->defaults();
+		convenience->defaults();
+		propagateUsers();
+	}
+}
+
+void KDModule::propagateUsers()
+{
+	groupmap.clear();
+	emit clearUsers();
+	QMap<QString,int> lusers;
+	QMap<QString, QPair<int,QStringList> >::const_iterator it;
+	QStringList::ConstIterator jt;
+	QMap<QString,int>::Iterator gmapi;
+	for (it = usermap.constBegin(); it != usermap.constEnd(); ++it) {
+		int uid = it.value().first;
+		if (!uid || (uid >= minshowuid && uid <= maxshowuid)) {
+			lusers[it.key()] = uid;
+			for (jt = it.value().second.begin(); jt != it.value().second.end(); ++jt)
+				if ((gmapi = groupmap.find( *jt )) == groupmap.end()) {
+					groupmap[*jt] = 1;
+					lusers['@' + *jt] = -uid;
+				} else
+					(*gmapi)++;
+		}
+	}
+	emit addUsers( lusers );
+	updateOK = true;
+}
+
+void KDModule::slotMinMaxUID( int min, int max )
+{
+	if (updateOK) {
+		QMap<QString,int> alusers, dlusers;
+		QMap<QString, QPair<int,QStringList> >::const_iterator it;
+		QStringList::ConstIterator jt;
+		QMap<QString,int>::Iterator gmapi;
+		for (it = usermap.constBegin(); it != usermap.constEnd(); ++it) {
+			int uid = it.value().first;
+			if (!uid)
+				continue;
+			if ((uid >= minshowuid && uid <= maxshowuid) &&
+			    !(uid >= min && uid <= max))
+			{
+				dlusers[it.key()] = uid;
+				for (jt = it.value().second.begin();
+				     jt != it.value().second.end(); ++jt) {
+					gmapi = groupmap.find( *jt );
+					if (!--(*gmapi)) {
+						groupmap.erase( gmapi );
+						dlusers['@' + *jt] = -uid;
+					}
+				}
+			} else if ((uid >= min && uid <= max) &&
+			           !(uid >= minshowuid && uid <= maxshowuid))
+			{
+				alusers[it.key()] = uid;
+				for (jt = it.value().second.begin();
+				     jt != it.value().second.end(); ++jt)
+					if ((gmapi = groupmap.find( *jt )) == groupmap.end()) {
+						groupmap[*jt] = 1;
+						alusers['@' + *jt] = -uid;
+					} else
+						(*gmapi)++;
+			}
+		}
+		emit delUsers( dlusers );
+		emit addUsers( alusers );
+	}
+	minshowuid = min;
+	maxshowuid = max;
+}
+
+void KDModule::slotUseThemeChanged( bool use )
+{
+	dialog_stack->setCurrentIndex( use );
+	background_stack->setCurrentIndex( use );
+	theme_stack->setCurrentIndex( use );
+}
+
+#include "main.moc"
diff -Nru kdebase-workspace-4.3.73svn1040395/kdm/config.def kdebase-workspace-4.3.73svn1040395-new/kdm/config.def
--- kdebase-workspace-4.3.73svn1040395/kdm/config.def	2009-10-26 10:14:48.000000000 +0100
+++ kdebase-workspace-4.3.73svn1040395-new/kdm/config.def	2009-10-28 22:58:08.000000000 +0100
@@ -29,7 +29,7 @@
 #define RCVERMAJOR 2
 #define RCVERMINOR 4
 
-#define KDMCONF KDE_CONFDIR "/kdm"
+#define KDMCONF "/etc/X11/kdm"
 #define KDMDATA KDE_DATADIR "/kdm"
 
 #ifdef _AIX
@@ -1099,7 +1099,7 @@
 Key: Xaccess
 Type: string
 # differs from xdm
-Default: *KDMCONF "/Xaccess"
+Default: *"/etc/X11/kdm/Xaccess"
 User: config(Xaccess)
 Instance: #""
 Update: mk_xaccess
@@ -1161,7 +1161,7 @@
 
 Key: Willing
 Type: string
-Default: ""
+Default: KDMCONF "/Xwilling"
 User: core
 # will be overwritten
 Instance: #
@@ -1600,7 +1600,7 @@
 
 Key: Startup
 Type: string
-Default: ""
+Default: KDMCONF "/Xsetup"
 User: core
 # will be overwritten
 Instance: #*/""
@@ -1618,7 +1618,7 @@
 
 Key: Reset
 Type: string
-Default: ""
+Default: KDMCONF "Xreset"
 User: core
 # will be overwritten
 Instance: #*/""
@@ -1636,7 +1636,7 @@
 
 Key: Session
 Type: string
-Default: XBINDIR "/xterm -ls -T"
+Default: KDMCONF "/Xsession"
 #Merge: xdm - incompatible!
 User: core
 # will be overwritten
@@ -1753,10 +1753,10 @@
 
 Key: AllowRootLogin
 Type: bool
-Default: true
+Default: false
 User: core
 User: greeter(showRoot)
-Instance: */false
+Instance: #*/true
 Merge: xdm
 Comment:
  Allow root logins?
@@ -1766,11 +1766,11 @@
 
 Key: AllowNullPasswd
 Type: bool
-Default: true
+Default: false
 User: core
 # sensible?
-Instance: */false
-Instance: :*/true
+Instance: #*/true
+Instance: #:*/true
 Merge: xdm
 Comment:
  Allow to log in, when user has set an empty password?
@@ -1928,10 +1928,10 @@
 
 Key: SessionsDirs
 Type: list
-Default: *KDMDATA "/sessions"
+Default: *"/usr/share/xsessions"
 User: core
 User: greeter-c
-Instance: */KDMCONF "/sessions," KDMDATA "/sessions"
+Instance: */"/etc/X11/sessions,/usr/share/xsessions"
 Update: upd_sessionsdirs
 Comment:
  The directories containing session type definitions in .desktop format,
@@ -2275,7 +2275,7 @@
 
 Key: MinShowUID
 Type: int
-Default: 0
+Default: 1000
 User: greeter(lowUserId)
 # will be overwritten
 Instance: #*/
@@ -2336,7 +2336,7 @@
 
 Key: FaceDir
 Type: string
-Default: *KDMDATA "/faces"
+Default: *"/etc/X11/kdm/faces"
 User: greeter
 Instance: #*/"/usr/share/faces"
 Update: upd_facedir
@@ -2419,7 +2419,7 @@
 
 Key: BackgroundCfg
 Type: string
-Default: *KDMCONF "/backgroundrc"
+Default: *"/etc/X11/kdm/backgroundrc"
 User: greeter-c
 Instance: #*/""
 Update: handleBgCfg
diff -Nru kdebase-workspace-4.3.73svn1040395/kdm/config.def.orig kdebase-workspace-4.3.73svn1040395-new/kdm/config.def.orig
--- kdebase-workspace-4.3.73svn1040395/kdm/config.def.orig	1970-01-01 01:00:00.000000000 +0100
+++ kdebase-workspace-4.3.73svn1040395-new/kdm/config.def.orig	2009-10-26 10:14:48.000000000 +0100
@@ -0,0 +1,2684 @@
+#
+# Copyright 2004-2007 Oswald Buddenhagen <ossi@kde.org>
+#
+# Permission to use, copy, modify, distribute, and sell this software and its
+# documentation for any purpose is hereby granted without fee, provided that
+# the above copyright notice appear in all copies and that both that
+# copyright notice and this permission notice appear in supporting
+# documentation.
+#
+# The above copyright notice and this permission notice shall be included
+# in all copies or substantial portions of the Software.
+#
+# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+# OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+# IN NO EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
+# OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+# ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+# OTHER DEALINGS IN THE SOFTWARE.
+#
+# Except as contained in this notice, the name of a copyright holders shall
+# not be used in advertising or otherwise to promote the sale, use or
+# other dealings in this Software without prior written authorization
+# from the copyright holders.
+#
+
+# The contents of this section are copied into config.ci verbatim.
+<code>
+#define RCVERMAJOR 2
+#define RCVERMINOR 4
+
+#define KDMCONF KDE_CONFDIR "/kdm"
+#define KDMDATA KDE_DATADIR "/kdm"
+
+#ifdef _AIX
+# define HALT_CMD	"/usr/sbin/shutdown -h now"
+# define REBOOT_CMD	"/usr/sbin/shutdown -r now"
+#elif defined(BSD)
+# define HALT_CMD	"/sbin/shutdown -p now"
+# define REBOOT_CMD	"/sbin/shutdown -r now"
+#elif defined(__SVR4)
+# define HALT_CMD	"/usr/sbin/halt"
+# define REBOOT_CMD	"/usr/sbin/reboot"
+#else
+# define HALT_CMD	"/sbin/halt"
+# define REBOOT_CMD	"/sbin/reboot"
+#endif
+
+#if defined(BSD) || defined(__linux__)
+# define DEF_USER_PATH KDM_DEF_USER_PATH
+# define DEF_SYSTEM_PATH KDM_DEF_SYSTEM_PATH
+#else
+# define DEF_USER_PATH KDM_DEF_USER_PATH ":/usr/ucb"
+# define DEF_SYSTEM_PATH KDM_DEF_SYSTEM_PATH ":/etc:/usr/ucb"
+#endif
+
+#if 0 /*def HASXDMAUTH*/
+# define DEF_AUTH_NAME	"XDM-AUTHORIZATION-1,MIT-MAGIC-COOKIE-1"
+#else
+# define DEF_AUTH_NAME	"MIT-MAGIC-COOKIE-1"
+#endif
+
+#ifdef HAVE_VTS
+#elif defined(__sun__)
+# define DEF_SERVER_TTY "console"
+#elif defined(_AIX)
+# define DEF_SERVER_TTY "lft0"
+#else
+# define DEF_SERVER_TTY ""
+#endif
+
+#ifdef _AIX
+# define DEF_SERVER_CMD XBINDIR "/X -T -force"
+#else
+# define DEF_SERVER_CMD XBINDIR "/X"
+#endif
+</code>
+
+# The contents of this section are copied mostly verbatim to the
+# default/example configuration file.
+# Everything indented with a space is considered a comment for the output;
+# it is prefixed with a hash mark but otherwise copied verbatim (except
+# for lines consisting of a single underscore, which generate empty comment
+# lines).
+# Section headers are "condensation seeds" for the Instance:s in the key
+# definitions below.
+<kdmrc>
+ &kdm; master configuration file
+ _
+ Definition: the greeter is the login dialog, i.e., the part of &kdm;
+ which the user sees.
+ _
+ You can configure every X-display individually.
+ Every display has a display name, which consists of a host name
+ (which is empty for local displays specified in {Static|Reserve}Servers),
+ a colon, and a display number. Additionally, a display belongs to a
+ display class (which can be ignored in most cases; the control center
+ does not support this feature at all).
+ Sections with display-specific settings have the formal syntax
+ "[X-" host [":" number [ "_" class ]] "-" sub-section "]"
+ You can use the "*" wildcard for host, number, and class. You may omit
+ trailing components; they are assumed to be "*" then.
+ The host part may be a domain specification like ".inf.tu-dresden.de".
+ It may also be "+", which means non-empty, i.e. remote displays only.
+ From which section a setting is actually taken is determined by these
+ rules:
+ - an exact match takes precedence over a partial match (for the host part),
+   which in turn takes precedence over a wildcard ("+" taking precedence
+   over "*")
+ - precedence decreases from left to right for equally exact matches
+ Example: display name "myhost:0", class "dpy".
+ [X-myhost:0_dpy] precedes
+ [X-myhost:0_*] (same as [X-myhost:0]) precedes
+ [X-myhost:*_dpy] precedes
+ [X-myhost:*_*] (same as [X-myhost]) precedes
+ [X-+:0_dpy] precedes
+ [X-*:0_dpy] precedes
+ [X-*:0_*] (same as [X-*:0]) precedes
+ [X-*:*_*] (same as [X-*])
+ These sections do NOT match this display:
+ [X-hishost], [X-myhost:0_dec], [X-*:1], [X-:*]
+ If a setting is not found in any matching section, the default is used.
+ _
+ Every comment applies to the following section or key. Note that all
+ comments will be lost if you change this file with the kcontrol frontend.
+ The defaults refer to &kdm;'s built-in values, not anything set in this file.
+ _
+ Special characters need to be backslash-escaped (leading and trailing
+ spaces (\\s), tab (\\t), linefeed (\\n), carriage return (\\r) and the
+ backslash itself (\\\\)).
+ In lists, fields are separated with commas without whitespace in between.
+ Some command strings are subject to simplified sh-style word splitting:
+ single quotes (') and double quotes (") have the usual meaning; the backslash
+ quotes everything (not only special characters). Note that the backslashes
+ need to be doubled because of the two levels of quoting.
+
+[General]
+
+[Xdmcp]
+
+[Shutdown]
+
+ Rough estimations about how many seconds &kdm; will spend at most on
+ - opening a connection to the X-server (OpenTime) if the attempt
+   - times out: OpenTimeout
+   - is refused: OpenRepeat * OpenDelay
+ - starting a local X-server (ServerTime):
+   ServerAttempts * (ServerTimeout + OpenDelay)
+ - starting a display:
+   - local display: ServerTime + OpenTime
+   - foreign display: StartAttempts * OpenTime
+   - &XDMCP; display: OpenTime (repeated indefinitely by client)
+
+ Core config for all displays
+[X-*-Core]
+
+ Greeter config for all displays
+[X-*-Greeter]
+
+ Core config for local displays
+[X-:*-Core]
+
+ Greeter config for local displays
+[X-:*-Greeter]
+
+ Core config for 1st local display
+[X-:0-Core]
+
+ Greeter config for 1st local display
+[X-:0-Greeter]
+</kdmrc>
+
+# The contents of this section are copied into kdmrc-ref.docbook.
+# The macro %REF% is replaced with the accumulated Description:s from the key
+# definitions below.
+<docu>
+<chapter id="kdm-files">
+<title>The Files &kdm; Uses for Configuration</title>
+
+<para>This chapter documents the files that control &kdm;'s behavior.
+Some of this can be also controlled from the &kcontrol; module, but
+not all.</para>
+
+<sect1 id="kdmrc">
+<title>&kdmrc; - The &kdm; master configuration file</title>
+
+<para>The basic format of the file is <quote>INI-like</quote>.
+Options are key/value pairs, placed in sections.
+Everything in the file is case sensitive.
+Syntactic errors and unrecognized key/section identifiers cause &kdm; to
+issue non-fatal error messages.</para>
+
+<para>Lines beginning with <literal>#</literal> are comments; empty lines
+are ignored as well.</para>
+
+<para>Sections are denoted by
+<literal>[</literal><replaceable>Name of Section</replaceable><literal>]</literal>.
+</para>
+
+<para>You can configure every X-display individually.</para>
+<para>Every display has a display name, which consists of a host name
+(which is empty for local displays specified in <option>StaticServers</option>
+or <option>ReserveServers</option>), a colon, and a display number.
+Additionally, a display belongs to a
+display class (which can be ignored in most cases).</para>
+
+<para>Sections with display-specific settings have the formal syntax
+<literal>[X-</literal>&nbsp;<replaceable>host</replaceable>&nbsp;[&nbsp;<literal>:</literal>&nbsp;<replaceable>number</replaceable>&nbsp;[&nbsp;<literal>_</literal>&nbsp;<replaceable>class</replaceable>&nbsp;]&nbsp;]&nbsp;<literal>-</literal>&nbsp;<replaceable>sub-section</replaceable>&nbsp;<literal>]</literal>
+</para>
+<para>All sections with the same <replaceable>sub-section</replaceable>
+make up a section class.</para>
+
+<para>You can use the wildcard <literal>*</literal> (match any) for
+<replaceable>host</replaceable>, <replaceable>number</replaceable>, 
+and <replaceable>class</replaceable>. You may omit trailing components;
+they are assumed to be <literal>*</literal> then. The host part may be a
+domain specification like <replaceable>.inf.tu-dresden.de</replaceable>
+or the wildcard <literal>+</literal> (match non-empty).</para>
+
+<para>From which section a setting is actually taken is determined by
+these rules:</para>
+
+<itemizedlist>
+<listitem>
+<para>An exact match takes precedence over a partial match (for the
+host part), which in turn takes precedence over a wildcard
+(<literal>+</literal> taking precendence over <literal>*</literal>).</para>
+</listitem>
+
+<listitem>
+<para>Precedence decreases from left to right for equally exact matches.</para>
+</listitem>
+
+<listitem>
+
+<para>
+Example: display name <quote>myhost.foo:0</quote>, class <quote>dpy</quote>
+</para>
+<itemizedlist>
+<listitem>
+<para>[X-myhost.foo:0_dpy] precedes</para>
+</listitem>
+<listitem>
+<para>[X-myhost.foo:0_*] (same as [X-myhost.foo:0]) precedes</para>
+</listitem>
+<listitem>
+<para>[X-myhost.foo:*_dpy] precedes</para>
+</listitem>
+<listitem>
+<para>[X-myhost.foo:*_*] (same as [X-myhost.foo]) precedes</para>
+</listitem>
+<listitem>
+<para>[X-.foo:*_*] (same as [X-.foo]) precedes</para>
+</listitem>
+<listitem>
+<para>[X-+:0_dpy] precedes</para>
+</listitem>
+<listitem>
+<para>[X-*:0_dpy] precedes</para>
+</listitem>
+<listitem>
+<para>[X-*:0_*] (same as [X-*:0]) precedes</para>
+</listitem>
+<listitem>
+<para>[X-*:*_*] (same as [X-*]).</para>
+</listitem>
+<listitem>
+<para>These sections do <emphasis>not</emphasis> match this display:</para>
+<para>[X-hishost], [X-myhost.foo:0_dec], [X-*:1], [X-:*]</para>
+</listitem>
+</itemizedlist>
+
+</listitem>
+
+</itemizedlist>
+
+<para>Common sections are [X-*] (all displays), [X-:*] (all local displays)
+and [X-:0] (the first local display).</para>
+
+<para>The format for all keys is
+<userinput><option><replaceable>key</replaceable></option>&nbsp;<literal>=</literal>&nbsp;<parameter>value</parameter></userinput>.
+Keys are only valid in the section class they are defined for.
+Some keys do not apply to particular displays, in which case they are ignored.
+</para>
+
+<para>If a setting is not found in any matching section, the default
+is used.</para>
+
+<para>Special characters need to be backslash-escaped (leading and trailing
+spaces (<literal>\s</literal>), tab (<literal>\t</literal>), linefeed
+(<literal>\n</literal>), carriage return (<literal>\r</literal>) and the
+backslash itself (<literal>\\</literal>)).</para>
+<para>In lists, fields are separated with commas without whitespace in between.
+</para>
+<para>Some command strings are subject to simplified sh-style word splitting:
+single quotes (<literal>'</literal>) and double quotes (<literal>"</literal>)
+have the usual meaning; the backslash quotes everything (not only special
+characters). Note that the backslashes need to be doubled because of the
+two levels of quoting.</para>
+
+<note><para>A pristine &kdmrc; is very thoroughly commented.
+All comments will be lost if you change this file with the
+kcontrol frontend.</para></note>
+
+%REF%
+
+</sect1>
+
+<sect1 id="kdmrc-xservers">
+<title>Specifying permanent &X-Server;s</title>
+
+<para>Each entry in the <option>StaticServers</option> list indicates a
+display which should constantly be
+managed and which is not using &XDMCP;. This method is typically used only for
+local &X-Server;s that are started by &kdm;, but &kdm; can manage externally
+started (<quote>foreign</quote>) &X-Server;s as well, may they run on the 
+local machine or rather remotely.</para>
+
+<para>The formal syntax of a specification is
+<screen>
+<userinput><replaceable>display&nbsp;name</replaceable>&nbsp;[<literal>_</literal><replaceable>display&nbsp;class</replaceable>]</userinput>
+</screen>
+for all &X-Server;s. <quote>Foreign</quote> displays differ in having
+a host name in the display name, may it be <literal>localhost</literal>.</para>
+
+<para>The <replaceable>display name</replaceable> must be something that can
+be passed in the <option>-display</option> option to an X program. This string
+is used to generate the display-specific section names, so be careful to match
+the names.
+The display name of &XDMCP; displays is derived from the display's address by
+reverse host name resolution. For configuration purposes, the
+<literal>localhost</literal> prefix from locally running &XDMCP; displays is
+<emphasis>not</emphasis> stripped to make them distinguishable from local
+&X-Server;s started by &kdm;.</para>
+
+<para>The <replaceable>display class</replaceable> portion is also used in the
+display-specific sections. This is useful if you have a large collection of
+similar displays (such as a corral of X terminals) and would like to set
+options for groups of them.
+When using &XDMCP;, the display is required to specify the display class,
+so the manual for your particular X terminal should document the display
+class string for your device. If it does not, you can run &kdm; in debug
+mode and <command>grep</command> the log for <quote>class</quote>.</para>
+
+<para>The displays specified in <option>ReserveServers</option> will not be
+started when &kdm; starts up, but when it is explicitly requested via
+the command socket.
+If reserve displays are specified, the &kde; menu will have a
+<guilabel>Start New Session</guilabel> item near the bottom; use that to
+activate a reserve display with a new login session. The monitor will switch
+to the new display, and you will have a minute to login. If there are no more
+reserve displays available, the menu item will be disabled.</para>
+
+<para>When &kdm; starts a session, it sets up authorization data for the
+&X-Server;. For local servers, &kdm; passes
+<command><option>-auth</option>&nbsp;<filename><replaceable>filename</replaceable></filename></command>
+on the &X-Server;'s command line to point it at its authorization data.
+For &XDMCP; displays, &kdm; passes the authorization data to the &X-Server;
+via the <quote>Accept</quote> &XDMCP; message.</para>
+
+</sect1>
+
+<sect1 id="kdmrc-xaccess">
+<title>&XDMCP; access control</title>
+
+<para>The file specified by the <option>AccessFile</option> option provides
+information which &kdm; uses to control access from displays requesting service
+via &XDMCP;.
+The file contains four types of entries: entries which control the response
+to <quote>Direct</quote> and <quote>Broadcast</quote> queries, entries which
+control the response to <quote>Indirect</quote> queries, macro definitions,
+and entries which control on which network interfaces &kdm; listens for &XDMCP;
+queries.
+Blank lines are ignored, <literal>#</literal> is treated as a comment
+delimiter causing the rest of that line to be ignored, and <literal>\</literal>
+causes an immediately following newline to be ignored, allowing host lists
+to span multiple lines.
+</para>
+
+<para>The format of the <quote>Direct</quote> entries is simple, either a
+host name or a pattern, which is compared against the host name of the display
+device. Alternatively, a macro may be used to make the entry match everything
+the macro expands to.
+Patterns are distinguished from host names by the inclusion of one or more
+meta characters; <literal>*</literal> matches any sequence of 0 or more
+characters, and <literal>?</literal> matches any single character.
+If the entry is a host name, all comparisons are done using network addresses,
+so any name which converts to the correct network address may be used. Note
+that only the first network address returned for a host name is used.
+For patterns, only canonical host names are used in the comparison, so ensure
+that you do not attempt to match aliases.
+Host names from &XDMCP; queries always contain the local domain name
+even if the reverse lookup returns a short name, so you can use
+patterns for the local domain.
+Preceding the entry with a <literal>!</literal> character causes hosts which
+match that entry to be excluded. Preceding it with an <literal>=</literal> has
+no effect but is required when specifying a macro to distinguish the entry
+from a macro definition.
+To only respond to <quote>Direct</quote> queries for a host or pattern,
+it can be followed by the optional <literal>NOBROADCAST</literal> keyword.
+This can be used to prevent a &kdm; server from appearing on menus based on
+<quote>Broadcast</quote> queries.</para>
+
+<para>An <quote>Indirect</quote> entry also contains a host name, pattern or
+macro, but follows it with a list of host names or macros to which the queries
+should be forwarded. <quote>Indirect</quote> entries can be excluding as well,
+in which case a (valid) dummy host name must be supplied to make the entry
+distinguishable from a <quote>Direct</quote> entry.
+If compiled with IPv6 support, multicast address groups may also be included
+in the list of addresses the queries are forwarded to.
+<!-- Not actually implemented!
+Multicast addresses may be followed by an optional <literal>/</literal>
+character and hop count. If no hop count is specified, the multicast hop count
+defaults to 1, keeping the packet on the local network. For IPv4 multicasting,
+the hop count is used as the TTL.
+-->
+If the indirect host list contains the keyword <literal>CHOOSER</literal>,
+<quote>Indirect</quote> queries are not forwarded, but instead a host chooser
+dialog is displayed by &kdm;. The chooser will send a <quote>Direct</quote>
+query to each of the remaining host names in the list and offer a menu of
+all the hosts that respond. The host list may contain the keyword
+<literal>BROADCAST</literal>, to make the chooser send a
+<quote>Broadcast</quote> query as well; note that on some operating systems,
+UDP packets cannot be broadcast, so this feature will not work.
+</para>
+
+<para>When checking access for a particular display host, each entry is scanned
+in turn and the first matching entry determines the response.
+<quote>Direct</quote> and <quote>Broadcast</quote> entries are ignored when
+scanning for an <quote>Indirect</quote> entry and vice-versa.</para>
+
+<para>A macro definition contains a macro name and a list of host names and
+other macros that the macro expands to. To distinguish macros from hostnames,
+macro names start with a <literal>%</literal> character.</para>
+
+<para>The last entry type is the <literal>LISTEN</literal> directive.
+The formal syntax is
+<screen>
+<userinput>&nbsp;<literal>LISTEN</literal>&nbsp;[<replaceable>interface</replaceable>&nbsp;[<replaceable>multicast&nbsp;list</replaceable>]]</userinput>
+</screen>
+If one or more <literal>LISTEN</literal> lines are specified, &kdm; listens
+for &XDMCP; requests only on the specified interfaces.
+<replaceable>interface</replaceable> may be a hostname or IP address
+representing a network interface on this machine, or the wildcard
+<literal>*</literal> to represent all available network interfaces.
+If multicast group addresses are listed on a <literal>LISTEN</literal> line,
+&kdm; joins the multicast groups on the given interface. For IPv6 multicasts,
+the IANA has assigned ff0<replaceable>X</replaceable>:0:0:0:0:0:0:12b as the
+permanently assigned range of multicast addresses for &XDMCP;. The
+<replaceable>X</replaceable> in the prefix may be replaced by any valid scope
+identifier, such as 1 for Node-Local, 2 for Link-Local, 5 for Site-Local, and
+so on (see IETF RFC 2373 or its replacement for further details and scope
+definitions). &kdm; defaults to listening on the Link-Local scope address
+ff02:0:0:0:0:0:0:12b to most closely match the IPv4 subnet broadcast behavior. 
+If no <literal>LISTEN</literal> lines are given, &kdm; listens on all
+interfaces and joins the default &XDMCP; IPv6 multicast group (when
+compiled with IPv6 support).
+To disable listening for &XDMCP; requests altogether, a
+<literal>LISTEN</literal> line with no addresses may be specified, but using
+the <literal>[Xdmcp]</literal> <option>Enable</option> option is preferred.
+</para>
+
+</sect1>
+
+<sect1 id="kdm-scripts">
+<title>Supplementary programs</title>
+
+<para>
+The following programs are run by &kdm; at various stages of a session.
+They typically are shell scripts.
+</para>
+
+<para>
+The Setup, Startup and Reset programs are run as
+<systemitem class="username">root</systemitem>, so they should be careful
+about security.
+Their first argument is <literal>auto</literal> if the session results
+from an automatic login; otherwise, no arguments are passed to them.
+</para>
+
+<sect2 id="kdmrc-xsetup">
+<title>Setup program</title>
+
+<para>
+The <filename>Xsetup</filename> program is run after the &X-Server; is
+started or reset, but before the greeter is offered.
+This is the place to change the root background (if
+<option>UseBackground</option> is disabled) or bring up other windows that
+should appear on the screen along with the greeter. Resources for this
+program can be put into the file named by <option>Resources</option>.
+</para>
+
+<para>
+In addition to any specified by <option>ExportList</option>,
+the following environment variables are passed:</para>
+<variablelist>
+ <varlistentry>
+  <term>DISPLAY</term>
+  <listitem><para>the associated display name</para></listitem>
+ </varlistentry>
+ <varlistentry>
+  <term>PATH</term>
+  <listitem><para>the value of <option>SystemPath</option></para></listitem>
+ </varlistentry>
+ <varlistentry>
+  <term>SHELL</term>
+  <listitem><para>the value of <option>SystemShell</option></para></listitem>
+ </varlistentry>
+ <varlistentry>
+  <term>XAUTHORITY</term>
+  <listitem><para>may be set to an authority file</para></listitem>
+ </varlistentry>
+ <varlistentry>
+  <term>DM_CONTROL</term>
+  <listitem><para>the value of <option>FifoDir</option></para></listitem>
+ </varlistentry>
+</variablelist>
+
+<note><para><option>GrabInput</option> can make &kdm; grab the
+keyboard and mouse, making any other windows unable to receive input.
+If <option>GrabServer</option> is set, <filename>Xsetup</filename>
+will not be able to connect to the display at all.</para></note>
+
+</sect2>
+
+<sect2 id="kdmrc-xstartup">
+<title>Startup program</title>
+
+<para>The <filename>Xstartup</filename> program is run as
+<systemitem class="username">root</systemitem> when the user logs in.
+This is the place to put commands which add entries to
+<filename>utmp</filename> (the <command>sessreg</command> program
+may be useful here), mount users' home directories from file servers,
+or abort the session if some requirements are not met (but note that on
+modern systems, many of these tasks are already taken care of by
+<acronym>PAM</acronym> modules).</para>
+
+<para>In addition to any specified by <option>ExportList</option>,
+the following environment variables are passed:</para>
+<variablelist>
+ <varlistentry>
+  <term>DISPLAY</term>
+  <listitem><para>the associated display name</para></listitem>
+ </varlistentry>
+ <varlistentry>
+  <term>HOME</term>
+  <listitem><para>the initial working directory of the user</para></listitem>
+ </varlistentry>
+ <varlistentry>
+  <term>LOGNAME</term>
+  <listitem><para>the username</para></listitem>
+ </varlistentry>
+ <varlistentry>
+  <term>USER</term>
+  <listitem><para>the username</para></listitem>
+ </varlistentry>
+ <varlistentry>
+  <term>PATH</term>
+  <listitem><para>the value of <option>SystemPath</option></para></listitem>
+ </varlistentry>
+ <varlistentry>
+  <term>SHELL</term>
+  <listitem><para>the value of <option>SystemShell</option></para></listitem>
+ </varlistentry>
+ <varlistentry>
+  <term>XAUTHORITY</term>
+  <listitem><para>may be set to an authority file</para></listitem>
+ </varlistentry>
+ <varlistentry>
+  <term>DM_CONTROL</term>
+  <listitem><para>the value of <option>FifoDir</option></para></listitem>
+ </varlistentry>
+</variablelist>
+
+<para>&kdm; waits until this program exits before starting the user session.
+If the exit value of this program is non-zero, &kdm; discontinues the session
+and starts another authentication cycle.</para>
+
+</sect2>
+
+<sect2 id="kdmrc-xsession">
+<title>Session program</title>
+
+<para>The <filename>Xsession</filename> program is the command which is run
+as the user's session. It is run with the permissions of the authorized user.
+One of the keywords <literal>failsafe</literal>, <literal>default</literal>
+or <literal>custom</literal>, or a string to <command>eval</command> by a
+Bourne-compatible shell is passed as the first argument.</para>
+
+<para>In addition to any specified by <option>ExportList</option>,
+the following environment variables are passed:</para>
+<variablelist>
+ <varlistentry>
+  <term>DISPLAY</term>
+  <listitem><para>the associated display name</para></listitem>
+ </varlistentry>
+ <varlistentry>
+  <term>HOME</term>
+  <listitem><para>the initial working directory of the user</para></listitem>
+ </varlistentry>
+ <varlistentry>
+  <term>LOGNAME</term>
+  <listitem><para>the username</para></listitem>
+ </varlistentry>
+ <varlistentry>
+  <term>USER</term>
+  <listitem><para>the username</para></listitem>
+ </varlistentry>
+ <varlistentry>
+  <term>PATH</term>
+  <listitem><para>the value of <option>UserPath</option>
+   (or <option>SystemPath</option> for
+   <systemitem class="username">root</systemitem> user sessions)</para>
+  </listitem>
+ </varlistentry>
+ <varlistentry>
+  <term>SHELL</term>
+  <listitem><para>the user's default shell</para></listitem>
+ </varlistentry>
+ <varlistentry>
+  <term>XAUTHORITY</term>
+  <listitem><para>may be set to a non-standard authority file</para></listitem>
+ </varlistentry>
+ <varlistentry>
+  <term>KRBTKFILE</term>
+  <listitem><para>may be set to a Kerberos4 credentials cache name</para>
+  </listitem>
+ </varlistentry>
+ <varlistentry>
+  <term>KRB5CCNAME</term>
+  <listitem><para>may be set to a Kerberos5 credentials cache name</para>
+  </listitem>
+ </varlistentry>
+ <varlistentry>
+  <term>DM_CONTROL</term>
+  <listitem><para>the value of <option>FifoDir</option></para></listitem>
+ </varlistentry>
+ <varlistentry>
+  <term>XDM_MANAGED</term>
+  <listitem><para>will contain a comma-separated list of parameters the
+   session might find interesting, like which conversation
+   plugin was used for the login</para>
+  </listitem>
+ </varlistentry>
+ <varlistentry>
+  <term>DESKTOP_SESSION</term>
+  <listitem><para>the name of the session the user has chosen to run</para>
+  </listitem>
+ </varlistentry>
+</variablelist>
+
+</sect2>
+
+<sect2 id="kdmrc-xreset">
+<title>Reset program</title>
+
+<para>Symmetrical with <filename>Xstartup</filename>, the
+<filename>Xreset</filename> program is run after the user session has
+terminated. Run as <systemitem class="username">root</systemitem>, it should
+contain commands that undo the effects of commands in 
+<filename>Xstartup</filename>, removing entries from <filename>utmp</filename>
+or unmounting directories from file servers.</para>
+
+<para>The environment variables that were passed to
+<filename>Xstartup</filename> are also passed to <filename>Xreset</filename>.
+</para>
+
+</sect2>
+
+</sect1>
+
+</chapter>
+</docu>
+
+
+# The rest of this file are section and key definitions for the options.
+# The order of the keywords is fixed and everything is case sensitive.
+# A keyword may expect supplementary data in the form of space-indented
+# lines following it. Definitions are delimited by empty lines.
+#
+# Section definition:
+#   Section: <name>
+#     Section name. Section classes start with a dash.
+#   If: <expression>
+#     C preprocessor conditional for supporting this section.
+#     If it evaluates to false, all keys in this section are disabled as well.
+#   Description:
+#     A docbook description of this section is expected in the next lines.
+#     The contents are automatically enclosed in <para></para>.
+#
+# Option key definition:
+#   Key: <name>
+#     Option name.
+#   If: <expression>
+#     C preprocessor conditional for supporting this option.
+#   Type: (int|bool|enum|group|string|path|list)
+#     The option's data type.
+#     If the type is enum, the element definitions follow in the next lines:
+#       <term>[/<c #define>]: <docbook style description>
+#   Default: <default>
+#     Default value. string, path and list are copied verbatim and therefore
+#     must be already quoted appropriately. The other types are auto-quoted.
+#     If the default value is prefixed with a "*", a c #define def_<Key> is
+#     created.
+#     The default is automatically appended to the kdmrc comment and the
+#     documentation entry.
+#   CDefault: <verbose default>
+#     Append this instead of the real default to the two docs. The quoting
+#     rules are the same as for Default.
+#   DDefault: -
+#     If specified, the default value will not be appended to the documentation
+#     entry. The Description should mention the default then. Use this when
+#     the default is system-dependent.
+#   PostProc: <function>
+#     A function to postprocess the read config value before using it.
+#   User: (dummy|(core|greeter|greeter-c|dep|config)[(<variable>)][:font])
+#     These entries specify which parts of kdm need the option in question:
+#       dummy: no user; entry is there only for syntactical correctness.
+#       dep: this option is an internal dependency for another option.
+#       config: this option configures the config reader itself.
+#       core: the kdm backend needs this option.
+#       greeter-c: the kdm frontend needs this option as a C data type.
+#       greeter: the kdm frontend needs this option as a C++/Qt data type.
+#         If a :font tag is appended, a string entry is converted to a QFont.
+#     If no variable name is specified, it will be derived from the Key by
+#     un-capitalizing it.
+#   Instance: (-|[#][<display spec>/](!|<value>))
+#     These entries specify option instances for the default/example kdmrc.
+#     A "-" entry is a dummy for syntactical correctness.
+#     A prefixing hash mark will be copied to kdmrc.
+#     For options in a section class a display must be specified.
+#     For bool options "!" can be used as the value to specify the negation
+#     of the default.
+#   Update: <function>[/<number>]
+#     Call this function on each occurence of this option in genkdmconf.
+#     Options with higher numbers (default is 0) will be processed later.
+#   Merge: xdm[:<resource>][(<function>)]
+#   Merge: kdm:[<section>/][<key>][(<function>)]
+#     Specify config options to merge from xdm and older kdm versions.
+#     Kdm options from the current version are automatically merged.
+#     When merging an xdm resource and no resource name is specified, it is
+#     derived from the Key by un-capitalizing it.
+#     When merging a kdm option, at least one of <section> and <key> must
+#     be given; an unspecified entity defaults to the current Section/Key.
+#     <section> may be a dash-prefixed section class.
+#     A function to postprocess the read value can be specified.
+#   Comment: [&|-]
+#     A kdmrc comment for this option is expected in the next lines.
+#     If "-" is given to Comment, no comment is generated at all.
+#     If "&" is given, the comment is derived from the Description below by
+#     applying some simple docbook interpretation to it. Note that the
+#     Description must be preformatted in this case. Use
+#        sed -ne 's/^\(.\{79,\}\)$/\1/p' < kdmrc
+#     after running "make install" to see whether all lines still fit.
+#     If Type is enum, a list of the previously defined element/description
+#     pairs is appended; the descriptions undergo docbook interpretation.
+#     Finally, a sentence with the Default (or CDefault, if given) is appended.
+#   Description: [!|-]
+#     A docbook description of this option is expected in the next lines.
+#     The contents are automatically enclosed in <para></para>.
+#     If "-" is given to Description, no comment is generated at all.
+#     If "!" is given, enums are not treated specially; otherwise, the macro
+#     %ENUM% is replaced with a list of the defined element/description pairs,
+#     or - if the macro is not present - the list is appended to the
+#     description.
+#     Finally, a sentence with the Default (or CDefault, if given) is appended,
+#     unless "DDefault: -" was specified.
+#     Each option entry generates an anchor named option-<lowercase(Key)>;
+#     it can be referenced in the main documentation.
+#     Do not forget to run "make ref" in kdebase/doc/kdm after changing
+#     Descriptions.
+
+Section: General
+Description:
+ This section contains global options that do not fit into any specific section.
+
+Key: ConfigVersion
+Type: string
+Default: ""
+CDefault: -
+User: dummy
+# will be overwritten
+Instance:
+Comment:
+ This option exists solely for the purpose of a clean automatic upgrade.
+ Do not even think about changing it!
+Description:
+ This option exists solely for the purpose of clean automatic upgrades.
+ <emphasis>Do not</emphasis> change it, you may interfere with future
+ upgrades and this could result in &kdm; failing to run.
+
+Key: PAMService
+If: defined(USE_PAM)
+Type: string
+Default: KDM_PAM_SERVICE
+User: core
+Instance: -
+Comment: -
+Description: -
+
+<legacy>
+Proc: absorbXservers
+# note: this can miss Xservers from kdm for kde 2.2 because of stupid default.
+Source: kdm:General/Xservers
+Source: xdm:servers
+</legacy>
+
+Key: StaticServers
+Type: list
+Default: ":0"
+User: core
+Instance: ":0"
+Comment:
+ List of permanent displays. Displays with a hostname are foreign. A display
+ class may be specified separated by an underscore.
+Description:
+ List of displays (&X-Server;s) permanently managed by &kdm;. Displays with a
+ hostname are foreign displays which are expected to be already running,
+ the others are local displays for which &kdm; starts an own &X-Server;;
+ see <option>ServerCmd</option>. Each display may belong to a display class;
+ append it to the display name separated by an underscore.
+ See <xref linkend="kdmrc-xservers"/> for the details.
+
+Key: ReserveServers
+Type: list
+Default: ""
+User: core
+Instance: ":1,:2,:3"
+Comment: &
+Description:
+ List of on-demand displays. See <option>StaticServers</option> for syntax.
+
+Key: ServerVTs
+If: defined(HAVE_VTS)
+Type: list
+Default: ""
+User: core
+Instance: #"7,8,-9,-10"
+Update: upd_servervts
+Comment:
+ VTs to allocate to &X-Server;s. A negative number means that the VT will be
+ used only if it is free. If all VTs in this list are used up, the next free
+ one greater than the last one in this list will be allocated.
+Description:
+ List of Virtual Terminals to allocate to &X-Server;s. For negative numbers the
+ absolute value is used, and the <acronym>VT</acronym> will be allocated only
+ if the kernel says it is free. If &kdm; exhausts this list, it will allocate
+ free <acronym>VT</acronym>s greater than the absolute value of the last entry
+ in this list.
+ Currently Linux only.
+
+Key: ConsoleTTYs
+If: defined(HAVE_VTS)
+Type: list
+Default: ""
+User: core
+Instance: #"tty1,tty2,tty3,tty4,tty5,tty6"
+Update: upd_consolettys
+Comment:
+ TTYs (without /dev/) to monitor for activity while in console mode.
+Description:
+ This option is for operating systems (<acronym>OS</acronym>s) with support
+ for virtual terminals (<acronym>VT</acronym>s), by both &kdm; and the
+ <acronym>OS</acronym>s itself.
+ Currently this applies only to Linux.
+ </para><para>
+ When &kdm; switches to console mode, it starts monitoring all
+ <acronym>TTY</acronym> lines listed here (without the leading
+ <literal>/dev/</literal>).
+ If none of them is active for some time, &kdm; switches back to the X login.
+
+Key: PidFile
+Type: string
+Default: ""
+User: core
+Instance: "/var/run/kdm.pid"
+Merge: xdm
+Comment:
+ Where &kdm; should store its PID (do not store if empty).
+Description:
+ The filename specified will be created to contain an ASCII representation
+ of the process ID of the main &kdm; process; the PID will not be stored
+ if the filename is empty.
+
+Key: LockPidFile
+Type: bool
+Default: true
+User: core
+Instance: #!
+Merge: xdm
+Comment:
+ Whether &kdm; should lock the PID file to prevent having multiple &kdm;
+ instances running at once. Do not change unless you are brave.
+Description:
+ This option controls whether &kdm; uses file locking to keep multiple
+ display managers from running onto each other.
+
+Key: AuthDir
+Type: path
+# differs from XDM
+Default: "/var/run/xauth"
+User: core
+Instance: #"/tmp"
+Merge: xdm(P_authDir)
+Comment:
+ Where to store authorization files.
+Description:
+ This names a directory under which &kdm; stores &X-Server; authorization
+ files while initializing the session. &kdm; expects the system to clean up
+ this directory from stale files on reboot.
+ </para><para>
+ The authorization file to be used for a particular display can be
+ specified with the <option>AuthFile</option> option in [X-*-Core].
+
+Key: AutoRescan
+Type: bool
+Default: true
+User: core
+Instance: #!
+Merge: xdm
+Comment:
+ Whether &kdm; should automatically re-read configuration files, if it
+ finds them having changed.
+Description:
+ This boolean controls whether &kdm; automatically re-reads its
+ configuration files if it finds them to have changed.
+
+Key: ExportList
+Type: list
+Default: ""
+User: core
+Instance: #"LD_LIBRARY_PATH,ANOTHER_IMPORTANT_VAR"
+Merge: xdm(P_list)
+Comment: &
+Description:
+ Additional environment variables &kdm; should pass on to all programs it runs.
+ <envar>LD_LIBRARY_PATH</envar> and <envar>XCURSOR_THEME</envar> are good candidates;
+ otherwise, it should not be necessary very often.
+
+Key: RandomFile
+If: !defined(ARC4_RANDOM) && !defined(DEV_RANDOM)
+Type: string
+Default: "/dev/mem"
+User: core
+Instance: #""
+Merge: xdm
+Comment:
+ A file &kdm; should read entropy from.
+Description:
+ If the system has no native entropy source like /dev/urandom (see
+ <option>RandomDevice</option>) and no entropy daemon like EGD (see
+ <option>PrngdSocket</option> and <option>PrngdPort</option>) is running,
+ &kdm; will fall back to its own pseudo-random number generator
+ that will, among other things, successively checksum parts of this file
+ (which, obviously, should change frequently).
+ </para><para>
+ This option does not exist on Linux and various BSDs.
+
+Key: PrngdSocket
+If: !defined(ARC4_RANDOM) && !defined(DEV_RANDOM)
+Type: string
+# differs from xdm!
+Default: ""
+User: core
+Instance: #"/tmp/entropy"
+Merge: xdm
+Comment:
+ A UNIX domain socket &kdm; should read entropy from.
+Description:
+ If the system has no native entropy source like /dev/urandom (see
+ <option>RandomDevice</option>), read random data from a Pseudo-Random
+ Number Generator Daemon,
+ like EGD (http://egd.sourceforge.net) via this UNIX domain socket.
+ </para><para>
+ This option does not exist on Linux and various BSDs.
+
+Key: PrngdPort
+If: !defined(ARC4_RANDOM) && !defined(DEV_RANDOM)
+Type: int
+Default: 0
+User: core
+Instance: #4840
+Merge: xdm
+Comment:
+ A TCP socket on localhost &kdm; should read entropy from.
+Description:
+ Same as <option>PrngdSocket</option>, only use a TCP socket on localhost.
+
+Key: RandomDevice
+If: !defined(ARC4_RANDOM)
+Type: string
+Default: ""
+User: core
+Instance: #"/dev/altrandom"
+Merge: xdm
+Comment:
+ A character device &kdm; should read entropy from.
+ Empty means use the system's preferred entropy device.
+Description:
+ The path to a character device which &kdm; should read random data from.
+ Empty means to use the system's preferred entropy device if there is one.
+ </para><para>
+ This option does not exist on OpenBSD, as it uses the arc4_random
+ function instead.
+
+Key: FifoDir
+Type: path
+Default: *"/var/run/xdmctl"
+User: core
+Instance: #"/tmp"
+Update: upd_fifodir
+Comment:
+ Where the command sockets should be created; make it empty to disable
+ them.
+Description:
+ The directory in which the command sockets should
+ be created; make it empty to disable them.
+# See <xref linkend="kdm-fifos"/> for the details.
+
+Key: FifoGroup
+Type: group
+Default: 0
+User: core
+Instance: #xdmctl
+Comment: &
+Description:
+ The group to which the global command socket should belong;
+ can be either a name or a numerical ID.
+
+Key: DataDir
+Type: path
+Default: *"/var/lib/kdm"
+User: greeter
+Instance: #""
+Update: upd_datadir
+Comment:
+ The directory in which &kdm; should store persistent working data.
+Description:
+ The directory in which &kdm; should store persistent working data; such data
+ is, for example, the previous user that logged in on a particular display.
+
+Key: DmrcDir
+Type: path
+Default: ""
+User: core
+Instance: #"/nfs-shared/var/dmrcs"
+Comment: &
+Description:
+ The directory in which &kdm; should store users' <filename>.dmrc</filename> files. This is only
+ needed if the home directories are not readable before actually logging in
+ (like with AFS).
+
+
+Section: Xdmcp
+If: defined(XDMCP)
+Description:
+ This section contains options that control &kdm;'s handling of
+ &XDMCP; requests.
+# See <xref linkend="xdmcp-with-kdm"/> to find out what &XDMCP; is.
+
+Key: Enable
+Type: bool
+Default: true
+User: dep(xdmcpEnable)
+Instance: false
+Comment: &
+Description:
+ Whether &kdm; should listen to incoming &XDMCP; requests.
+
+Key: Port
+Type: int
+Default: 177
+PostProc: PrequestPort
+User: core(requestPort)
+Instance: #
+Merge: xdm:requestPort(P_requestPort)
+Comment:
+ The UDP port on which &kdm; should listen for &XDMCP; requests. Do not change.
+Description:
+ This indicates the UDP port number which &kdm; uses to listen for incoming
+ &XDMCP; requests. Unless you need to debug the system, leave this with its
+ default value.
+
+Key: KeyFile
+Type: string
+Default: ""
+User: core
+Instance: #KDMCONF "/kdmkeys"
+Update: cp_keyfile
+Merge: xdm
+Comment:
+ File with the private keys of X-terminals. Required for XDM authentication.
+Description:
+ XDM-AUTHENTICATION-1 style &XDMCP; authentication requires a private
+ key to be shared between &kdm; and the terminal. This option specifies
+ the file containing those values. Each entry in the file consists of a
+ display name and the shared key.
+
+Key: Xaccess
+Type: string
+# differs from xdm
+Default: *KDMCONF "/Xaccess"
+User: config(Xaccess)
+Instance: #""
+Update: mk_xaccess
+Merge: xdm:accessFile
+Comment:
+ &XDMCP; access control file in the usual XDM-Xaccess format.
+Description:
+ To prevent unauthorized &XDMCP; service and to allow forwarding of &XDMCP;
+ IndirectQuery requests, this file contains a database of hostnames which
+ are either allowed direct access to this machine, or have a list of hosts
+ to which queries should be forwarded to. The format of this file is
+ described in <xref linkend="kdmrc-xaccess"/>.
+
+Key: ChoiceTimeout
+Type: int
+Default: 15
+User: core
+Instance: #10
+Merge: xdm
+Comment:
+ Number of seconds to wait for display to respond after the user has
+ selected a host from the chooser.
+Description:
+ Number of seconds to wait for the display to respond after the user has
+ selected a host from the chooser. If the display sends an &XDMCP;
+ IndirectQuery within this time, the request is forwarded to the chosen
+ host; otherwise, it is assumed to be from a new session and the chooser
+ is offered again.
+
+Key: RemoveDomainname
+Type: bool
+Default: true
+User: core
+Instance: #!
+Merge: xdm
+Comment:
+ Strip domain name from remote display names if it is equal to the local
+ domain.
+Description:
+ When computing the display name for &XDMCP; clients, the name resolver will
+ typically create a fully qualified host name for the terminal. As this is
+ sometimes confusing, &kdm; will remove the domain name portion of the host
+ name if it is the same as the domain name of the local host when this option
+ is enabled.
+
+Key: SourceAddress
+Type: bool
+Default: false
+User: core
+Instance: #!
+Merge: xdm
+Comment:
+ Use the numeric IP address of the incoming connection on multihomed hosts
+ instead of the host name.
+Description:
+ Use the numeric IP address of the incoming connection on multihomed hosts
+ instead of the host name. This is to avoid trying to connect on the wrong
+ interface which might be down at this time.
+
+Key: Willing
+Type: string
+Default: ""
+User: core
+# will be overwritten
+Instance: #
+Update: mk_willing
+Merge: xdm
+Merge: kdm:Xwilling
+Comment:
+ The program which is invoked to dynamically generate replies to &XDMCP;
+ DirectQuery or BroadcastQuery requests.
+ If empty, no program is invoked and "Willing to manage" is sent.
+Description:
+ This specifies a program which is run (as
+ <systemitem class="username">root</systemitem>) when an &XDMCP;
+ DirectQuery or BroadcastQuery is received and this host is configured
+ to offer &XDMCP; display management. The output of this program may be
+ displayed in a chooser window. If no program is specified, the string
+ <quote>Willing to manage</quote> is sent.
+
+
+Section: Shutdown
+Description:
+ This section contains global options concerning system shutdown.
+
+Key: HaltCmd
+Type: string
+Default: HALT_CMD
+DDefault: -
+User: core(cmdHalt)
+Instance: #""
+Comment:
+ The command (subject to word splitting) to run to halt the system.
+Description:
+ The command (subject to word splitting) to run to halt/poweroff the system.
+ </para><para>
+ The default is something reasonable for the system on which &kdm; was built, like
+ <command>/sbin/shutdown&nbsp;<option>-h</option>&nbsp;<parameter>now</parameter></command>.
+
+Key: RebootCmd
+Type: string
+Default: REBOOT_CMD
+DDefault: -
+User: core(cmdReboot)
+Instance: #""
+Comment:
+ The command (subject to word splitting) to run to reboot the system.
+Description:
+ The command (subject to word splitting) to run to reboot the system.
+ </para><para>
+ The default is something reasonable for the system &kdm; on which was built, like
+ <command>/sbin/shutdown&nbsp;<option>-r</option>&nbsp;<parameter>now</parameter></command>.
+
+Key: AllowFifo
+Type: bool
+Default: false
+User: core(fifoAllowShutdown)
+Instance: #!
+Comment: &
+Description:
+ Whether it is allowed to shut down the system via the global command socket.
+
+Key: AllowFifoNow
+Type: bool
+Default: true
+User: core(fifoAllowNuke)
+Instance: #!
+Comment:
+ Whether it is allowed to abort active sessions when shutting down the
+ system via the global command socket.
+Description:
+ Whether it is allowed to abort active sessions when shutting down the
+ system via the global command socket.
+ </para><para>
+ This will have no effect unless <option>AllowFifo</option> is enabled.
+
+Key: BootManager
+Type: enum
+ None/BO_NONE: no boot manager
+ Grub/BO_GRUB: Grub boot manager
+ Lilo/BO_LILO: Lilo boot manager (Linux on i386 &amp; x86-64 only)
+Default: None
+User: core
+User: greeter
+Instance: #Grub
+Merge: kdm:UseLilo(P_UseLilo)
+Comment: &
+Description:
+ The boot manager &kdm; should use for offering boot options in the
+ shutdown dialog.
+
+
+Section: -Core
+Description:
+ This section class contains options concerning the configuration
+ of the &kdm; backend (core).
+
+Key: OpenDelay
+Type: int
+Default: 15
+User: core
+Instance: #*/
+Merge: xdm(P_openDelay)
+Comment:
+ How long to wait before retrying to connect a display.
+Description:
+ See <option>OpenRepeat</option>.
+
+Key: OpenTimeout
+Type: int
+Default: 120
+User: core
+Instance: #*/
+Merge: xdm
+Comment:
+ How long to wait before timing out a display connection attempt.
+Description:
+ See <option>OpenRepeat</option>.
+
+Key: OpenRepeat
+Type: int
+Default: 5
+User: core
+Instance: #*/
+Merge: xdm
+Comment:
+ How many connection attempts to make during a start attempt. Note that
+ a timeout aborts the entire start attempt.
+Description:
+ These options control the behavior of &kdm; when attempting to open a
+ connection to an &X-Server;. <option>OpenDelay</option> is the length
+ of the pause (in seconds) between successive attempts,
+ <option>OpenRepeat</option> is the number of attempts to make and
+ <option>OpenTimeout</option> is the amount of time to spend on a
+ connection attempt. After <option>OpenRepeat</option> attempts have been
+ made, or if <option>OpenTimeout</option> seconds elapse in any particular
+ connection attempt, the start attempt is considered failed.
+
+Key: StartAttempts
+Type: int
+Default: 4
+User: core
+Instance: #*/
+Merge: xdm
+Comment:
+ Try at most that many times to start a display. If this fails, the display
+ is disabled.
+Description:
+ How many times &kdm; should attempt to start a <literal>foreign</literal>
+ display listed in <option>StaticServers</option> before giving up
+ and disabling it.
+ Local displays are attempted only once, and &XDMCP; displays are retried
+ indefinitely by the client (unless the option <option>-once</option>
+ was given to the &X-Server;).
+
+Key: ServerAttempts
+Type: int
+Default: 1
+User: core
+Instance: #:*/
+Merge: xdm
+Comment:
+ How often to try to run the &X-Server;. Running includes executing it and
+ waiting for it to come up.
+Description:
+ How many times &kdm; should attempt to start up a local &X-Server;.
+ Starting up includes executing it and waiting for it to come up.
+
+Key: ServerTimeout
+Type: int
+Default: 15
+User: core
+Instance: #:*/
+Comment:
+ How long to wait for a local &X-Server; to come up.
+Description:
+ How many seconds &kdm; should wait for a local &X-Server; to come up.
+
+Key: ServerCmd
+Type: string
+Default: DEF_SERVER_CMD
+DDefault: -
+User: core
+Instance: :*/DEF_SERVER_CMD
+Update: upd_servercmd
+Comment:
+ The command line to start the &X-Server;, without display number and VT spec.
+ This string is subject to word splitting.
+Description:
+ The command line to start the &X-Server;, without display number and VT spec.
+ This string is subject to word splitting.
+ </para><para>
+ The default is something reasonable for the system on which &kdm; was built,
+ like <command>/usr/X11R6/bin/X</command>.
+
+Key: ServerArgsLocal
+Type: string
+Default: ""
+User: core
+Instance: :*/"-nolisten tcp"
+Comment: &
+Description:
+ Additional arguments for the &X-Server;s for local sessions.
+ This string is subject to word splitting.
+
+Key: ServerArgsRemote
+Type: string
+Default: ""
+User: core
+Instance: #:*/""
+Comment: &
+Description:
+ Additional arguments for the &X-Server;s for remote sessions.
+ This string is subject to word splitting.
+
+Key: ServerVT
+If: defined(HAVE_VTS)
+Type: int
+Default: 0
+User: core(reqSrvVT)
+Instance: #:0/7
+Comment:
+ The VT the &X-Server; should run on; auto-assign if zero, don't assign if -1.
+ Better leave it zero and use ServerVTs.
+Description:
+ The VT the &X-Server; should run on.
+ <option>ServerVTs</option> should be used instead of this option.
+ Leave it zero to let &kdm; assign a <acronym>VT</acronym> automatically.
+ Set it to <literal>-1</literal> to avoid assigning a <acronym>VT</acronym>
+ alltogether - this is required for setups with multiple physical consoles.
+ Currently Linux only.
+
+Key: ServerTTY
+If: !defined(HAVE_VTS)
+Type: string
+Default: ""
+User: core(console)
+Instance: :0/DEF_SERVER_TTY
+Comment:
+ The TTY line (without /dev/) the &X-Server; covers physically.
+Description:
+ This option is for <acronym>OS</acronym>s without support for
+ <acronym>VT</acronym>s, either by &kdm; or the <acronym>OS</acronym> itself.
+ Currently this applies to all <acronym>OS</acronym>s but Linux.
+ </para><para>
+ When &kdm; switches to console mode, it starts monitoring this
+ <acronym>TTY</acronym> line (specified without the leading
+ <literal>/dev/</literal>) for activity. If the line is not used for some time,
+ &kdm; switches back to the X login.
+
+Key: PingInterval
+Type: int
+Default: 5
+User: core
+User: greeter
+Instance: #*/
+Merge: xdm
+Comment:
+ Ping remote display every that many minutes.
+Description:
+ See <option>PingTimeout</option>.
+
+Key: PingTimeout
+Type: int
+Default: 5
+User: core
+User: greeter
+Instance: #*/
+Merge: xdm
+Comment:
+ Wait for a Pong that many minutes.
+Description:
+ To discover when <emphasis>remote</emphasis> displays disappear, &kdm;
+ regularly pings them.
+ <option>PingInterval</option> specifies the time (in minutes) between the
+ pings and <option>PingTimeout</option> specifies the maximum amount of
+ time (in minutes) to wait for the terminal to respond to the request. If
+ the terminal does not respond, the session is declared dead and terminated.
+ </para><para>
+ If you frequently use X terminals which can become isolated from
+ the managing host, you may wish to increase the timeout. The only worry
+ is that sessions will continue to exist after the terminal has been
+ accidentally disabled.
+
+Key: TerminateServer
+Type: bool
+Default: false
+User: core
+Instance: #:*/!
+Merge: xdm
+Comment:
+ Restart instead of resetting the local &X-Server; after session exit.
+ Use it if the server leaks memory etc.
+Description:
+ Whether &kdm; should restart the local &X-Server; after session exit instead
+ of resetting it. Use this if the &X-Server; leaks memory or crashes the system
+ on reset attempts.
+
+Key: ResetSignal
+Type: int
+Default: 1
+CDefault: 1 (SIGHUP)
+User: core
+Instance: #:*/
+Merge: xdm
+Comment:
+ The signal needed to reset the local &X-Server;.
+Description:
+ The signal number to use to reset the local &X-Server;.
+
+Key: TermSignal
+Type: int
+Default: 15
+CDefault: 15 (SIGTERM)
+User: core
+Instance: #:*/
+Merge: xdm
+Comment:
+ The signal needed to terminate the local &X-Server;.
+Description:
+ The signal number to use to terminate the local &X-Server;.
+
+Key: Authorize
+Type: bool
+Default: true
+User: core
+Instance: #:*/!
+Merge: xdm
+Comment:
+ Create X-authorizations for local displays.
+Description:
+ Controls whether &kdm; generates and uses authorization for
+ <emphasis>local</emphasis> &X-Server; connections.
+ For &XDMCP; displays the authorization requested by the display is used;
+ foreign non-&XDMCP; displays do not support authorization at all.
+
+Key: AuthNames
+Type: list
+Default: DEF_AUTH_NAME
+User: core
+Instance: #:*/""
+Merge: xdm:authName
+Comment:
+ Which X-authorization mechanisms should be used.
+Description:
+ If <option>Authorize</option> is true, use the authorization mechanisms
+ listed herein. The MIT-MAGIC-COOKIE-1 authorization is always available;
+ XDM-AUTHORIZATION-1, SUN-DES-1 and MIT-KERBEROS-5 might be available as well,
+ depending on the build configuration.
+
+Key: ResetForAuth
+Type: bool
+Default: false
+User: core
+Instance: #:*/!
+Merge: xdm
+Comment:
+ Need to reset the &X-Server; to make it read initial Xauth file.
+Description:
+ Some <emphasis>old</emphasis> &X-Server;s re-read the authorization file
+ at &X-Server; reset time, instead of when checking the initial connection.
+ As &kdm; generates the authorization information just before connecting to
+ the display, an old &X-Server; would not get up-to-date authorization
+ information. This option causes &kdm; to send SIGHUP to the &X-Server;
+ after setting up the file, causing an additional &X-Server; reset to occur,
+ during which time the new authorization information will be read.
+
+Key: AuthFile
+Type: string
+Default: ""
+User: core(clientAuthFile)
+Instance: #*/""
+Merge: xdm
+Comment:
+ The name of this &X-Server;'s Xauth file.
+ If empty, a random name in the AuthDir directory will be used.
+Description:
+ This file is used to communicate the authorization data from &kdm; to
+ the &X-Server;, using the <option>-auth</option> &X-Server; command line
+ option. It should be kept in a directory which is not world-writable
+ as it could easily be removed, disabling the authorization mechanism in
+ the &X-Server;. If not specified, a random name is generated from
+ <option>AuthDir</option> and the name of the display.
+
+Key: Resources
+# XXX strictly speaking this is supposed to be a string list, i think.
+Type: string
+Default: ""
+User: core
+Instance: #*/""
+Update: cp_resources
+Merge: xdm
+Comment:
+ Specify a file with X-resources for the greeter, chooser and background.
+ The KDE frontend does not use this file, so you do not need it unless you
+ use another background generator than krootimage.
+Description:
+ This option specifies the name of the file to be loaded by
+ <command>xrdb</command> as the resource database onto the root window
+ of screen 0 of the display. KDE programs generally do not use
+ X-resources, so this option is only needed if the <option>Setup</option>
+ program needs some X-resources.
+
+Key: Xrdb
+Type: string
+Default: XBINDIR "/xrdb"
+User: core
+Instance: #*/""
+Merge: xdm
+Comment:
+ The xrdb program to use to read the above specified recources.
+ Subject to word splitting.
+Description:
+ The <command>xrdb</command> program to use to read the X-resources file
+ specified in <option>Recources</option>.
+ The command is subject to word splitting.
+
+Key: Setup
+Type: string
+Default: ""
+User: core
+# will be overwritten
+Instance: #*/""
+Update: mk_setup
+Merge: xdm
+Comment:
+ A program to run before the greeter is shown. Can be used to start an
+ xconsole or an alternative background generator. Subject to word splitting.
+Description:
+ This string is subject to word splitting.
+ It specifies a program which is run (as
+ <systemitem class="username">root</systemitem>) before offering the
+ greeter window. This may be used to change the appearance of the screen
+ around the greeter window or to put up other windows (e.g., you may want
+ to run <command>xconsole</command> here).
+ Usually, a script named <command>Xsetup</command> is used here.
+ See <xref linkend="kdmrc-xsetup"/>.
+
+Key: Startup
+Type: string
+Default: ""
+User: core
+# will be overwritten
+Instance: #*/""
+Update: mk_startup
+Merge: xdm
+Comment:
+ A program to run before a user session starts. Subject to word splitting.
+Description:
+ This string is subject to word splitting.
+ It specifies a program which is run (as
+ <systemitem class="username">root</systemitem>) after the user
+ authentication process succeeds.
+ Usually, a script named <command>Xstartup</command> is used here.
+ See <xref linkend="kdmrc-xstartup"/>.
+
+Key: Reset
+Type: string
+Default: ""
+User: core
+# will be overwritten
+Instance: #*/""
+Update: mk_reset
+Merge: xdm
+Comment:
+ A program to run after a user session exits. Subject to word splitting.
+Description:
+ This string is subject to word splitting.
+ It specifies a program which is run (as
+ <systemitem class="username">root</systemitem>) after the session
+ terminates.
+ Usually, a script named <command>Xreset</command> is used here.
+ See <xref linkend="kdmrc-xreset"/>.
+
+Key: Session
+Type: string
+Default: XBINDIR "/xterm -ls -T"
+#Merge: xdm - incompatible!
+User: core
+# will be overwritten
+Instance: #*/""
+Update: mk_session
+Comment:
+ The program which is run as the user which logs in. It is supposed to
+ interpret the session argument (see SessionsDirs) and start an appropriate
+ session according to it. Subject to word splitting.
+Description:
+ This string is subject to word splitting.
+ It specifies the session program to be executed (as the user owning
+ the session).
+ Usually, a script named <command>Xsession</command> is used here.
+ See <xref linkend="kdmrc-xsession"/>.
+
+Key: FailsafeClient
+Type: string
+Default: XBINDIR "/xterm"
+User: core
+Instance: #*/""
+Merge: xdm
+Comment:
+ The program to run if Session fails.
+Description:
+ If the <option>Session</option> program fails to execute, &kdm; will
+ fall back to this program. This program is executed with no arguments,
+ but executes using the same environment variables as the session would
+ have had (see <xref linkend="kdmrc-xsession"/>).
+
+Key: UserPath
+Type: string
+Default: DEF_USER_PATH
+DDefault: -
+User: core
+Instance: #*/""
+Merge: xdm
+Comment:
+ The PATH for the Session program.
+Description:
+ The <envar>PATH</envar> environment variable for
+ non-<systemitem class="username">root</systemitem> <option>Session</option>s.
+ </para><para>
+ The default depends on the system &kdm; was built on.
+
+Key: SystemPath
+Type: string
+Default: DEF_SYSTEM_PATH
+DDefault: -
+User: core
+Instance: #*/""
+Merge: xdm
+Comment:
+ The PATH for Setup, Startup and Reset, etc.
+Description:
+ The <envar>PATH</envar> environment variable for all programs but
+ non-<systemitem class="username">root</systemitem>
+ <option>Session</option>s. Note that it is good practice not to include
+ <literal>.</literal> (the current directory) into this entry.
+ </para><para>
+ The default depends on the system &kdm; was built on.
+
+Key: SystemShell
+Type: string
+Default: "/bin/sh"
+User: core
+Instance: #*/"/bin/bash"
+Merge: xdm
+Comment:
+ The default system shell.
+Description:
+ The <envar>SHELL</envar> environment variable for all programs but the 
+ <option>Session</option>.
+
+Key: UserAuthDir
+Type: path
+Default: "/tmp"
+User: core
+Instance: #*/""
+Merge: xdm
+Comment:
+ Where to put the user's &X-Server; authorization file if ~/.Xauthority
+ cannot be created.
+Description:
+ When &kdm; is unable to write to the usual user authorization file
+ ($<envar>HOME</envar>/.Xauthority), it creates a unique file name in this
+ directory and points the environment variable <envar>XAUTHORITY</envar>
+ at the created file.
+
+Key: ForceUserAuthDir
+Type: bool
+Default: false
+User: core
+Instance: #*/!
+Comment: &
+Description:
+ If true, <option>UserAuthDir</option> will be used unconditionally.
+
+Key: AutoReLogin
+Type: bool
+Default: false
+User: core
+Instance: #*/!
+Merge: xdm
+Comment:
+ Whether to automatically restart sessions after &X-Server; crashes.
+ Note that enabling this makes circumventing screen lockers other than
+ KDE's built-in one possible!
+Description:
+ If enabled, &kdm; will automatically restart a session after an &X-Server;
+ crash (or if it is killed by Alt-Ctrl-BackSpace). Note that enabling this
+ feature opens a security hole: a secured display lock can be circumvented
+ (unless &kde;'s built-in screen locker is used).
+
+Key: AllowRootLogin
+Type: bool
+Default: true
+User: core
+User: greeter(showRoot)
+Instance: */false
+Merge: xdm
+Comment:
+ Allow root logins?
+Description:
+ If disabled, do not allow <systemitem class="username">root</systemitem>
+ (and any other user with UID = 0) to log in directly.
+
+Key: AllowNullPasswd
+Type: bool
+Default: true
+User: core
+# sensible?
+Instance: */false
+Instance: :*/true
+Merge: xdm
+Comment:
+ Allow to log in, when user has set an empty password?
+Description:
+ If disabled, only users that have passwords assigned can log in.
+
+Key: AllowShutdown
+Type: enum
+ None/SHUT_NONE: no <guilabel>Shutdown...</guilabel> menu entry is shown at all
+ Root/SHUT_ROOT: the <systemitem class="username">root</systemitem> password must be entered to shut down
+ All/SHUT_ALL: everybody can shut down the machine
+Default: All
+User: core
+User: greeter
+Instance: */Root
+Instance: :*/All
+Merge: kdm:-Greeter/
+Comment: &
+Description:
+ Who is allowed to shut down the system. This applies both to the
+ greeter and to the command sockets.
+
+Key: AllowSdForceNow
+Type: enum
+ None: no forced shutdown is allowed at all
+ Root: the <systemitem class="username">root</systemitem> password must be entered to shut down forcibly
+ All: everybody can shut down the machine forcibly
+Default: All
+User: core(allowNuke)
+User: greeter(allowNuke)
+Instance: #*/Root
+Comment: &
+Description:
+ Who is allowed to abort active sessions when shutting down.
+
+Key: DefaultSdMode
+Type: enum
+ Schedule: shut down after all active sessions exit (possibly at once)
+ TryNow: shut down, if no active sessions are open; otherwise, do nothing
+ ForceNow: shut down unconditionally
+Default: Schedule
+User: core(defSdMode)
+User: greeter(defSdMode)
+Instance: #*/ForceNow
+Comment: &
+Description:
+ The default choice for the shutdown condition/timing.
+
+Key: ScheduledSd
+Type: enum
+ Never/SHUT_NEVER: not at all
+ Optional/SHUT_OPTION: as a button in the simple shutdown dialogs
+ Always/SHUT_ALWAYS: instead of the simple shutdown dialogs
+Default: Never
+User: greeter
+Instance: #*/Optional
+Comment: &
+Description:
+ How to offer shutdown scheduling options:
+
+Key: NoPassEnable
+Type: bool
+Default: false
+User: dep
+Instance: #:*/true
+Comment: &
+Description:
+ Enable password-less logins on this display. <emphasis>Use with extreme care!</emphasis>
+
+Key: NoPassUsers
+Type: list
+Default: ""
+PostProc: PnoPassUsers
+User: core
+Instance: #:*/"fred,ethel"
+Merge: xdm(P_noPassUsers)
+Comment:
+ The users that do not need to provide a password to log in. NEVER list root!
+ "*" means all non-root users. @<group> means all users in that group.
+Description:
+ The users that do not need to provide a password to log in.
+ Items which are prefixed with <literal>@</literal> represent all users in the
+ user group named by that item.
+ <literal>*</literal> means all users but
+ <systemitem class="username">root</systemitem>
+ (and any other user with UID = 0).
+ <emphasis>Never</emphasis> list <systemitem class="username">root</systemitem>.
+
+Key: AutoLoginEnable
+Type: bool
+Default: false
+User: dep
+Instance: #:0/true
+Comment: &
+Description:
+ Enable automatic login. <emphasis>Use with extreme care!</emphasis>
+
+Key: AutoLoginAgain
+Type: bool
+Default: false
+User: core(autoAgain)
+User: greeter
+Instance: #:0/true
+Comment: &
+Description:
+ If true, auto-login after logout. If false, auto-login is performed only
+ when a display session starts up.
+
+Key: AutoLoginDelay
+Type: int
+Default: 0
+User: core(autoDelay)
+User: greeter
+Instance: #:0/10
+Comment:
+ The delay in seconds before automatic login kicks in.
+Description:
+ The delay in seconds before automatic login kicks in. This is also known as
+ <quote>Timed Login</quote>.
+
+Key: AutoLoginUser
+Type: string
+Default: ""
+PostProc: PautoLoginX
+User: core(autoUser)
+User: greeter
+Instance: #:0/"fred"
+Merge: xdm:autoUser(P_autoUser)
+Comment: &
+Description:
+ The user to log in automatically. <emphasis>Never</emphasis> specify <systemitem class="username">root</systemitem>!
+
+Key: AutoLoginPass
+Type: string
+Default: ""
+PostProc: PautoLoginX
+User: core(autoPass)
+Instance: #:0/"secret!"
+Merge: xdm:autoPass(P_autoPass)
+Comment: &
+Description:
+ The password for the user to log in automatically. This is <emphasis>not</emphasis> required
+ unless the user is logged into a <acronym>NIS</acronym> or Kerberos domain. If you use this
+ option, you should <command>chmod&nbsp;<option>600</option>&nbsp;<filename>kdmrc</filename></command> for obvious reasons.
+
+Key: AutoLoginLocked
+Type: bool
+Default: false
+User: core(autoLock)
+Instance: #:0/!
+Comment: &
+Description:
+ Immediately lock the automatically started session. This works only with
+ KDE sessions.
+
+Key: SessionsDirs
+Type: list
+Default: *KDMDATA "/sessions"
+User: core
+User: greeter-c
+Instance: */KDMCONF "/sessions," KDMDATA "/sessions"
+Update: upd_sessionsdirs
+Comment:
+ The directories containing session type definitions in .desktop format,
+ ordered by falling priority.
+Description:
+ A list of directories containing session type definitions.
+ Ordered by falling priority.
+# See <xref linkend="kdmrc-sessions"> for details.
+
+Key: ClientLogFile
+Type: string
+Default: ".xsession-errors"
+User: core
+Instance: */".xsession-errors-%d"
+Instance: :0/".xsession-errors"
+Update: upd_userlogfile
+Comment:
+ The file (relative to $HOME) to redirect the session output to. The
+ following character pairs are replaced:
+ - %d -> current display
+ - %u -> current user
+ - %r -> empty at first. See below.
+ - %% -> a single %
+ When the constructed filename cannot be used safely and the specification
+ contains %<stuff>r, other names will be tried - this time expanding %<stuff>r
+ to <stuff> followed by a random number.
+Description:
+ The file (relative to the user's home directory) to redirect the session
+ output to.
+ </para><para>
+ The following character pairs are replaced by their value:
+ <variablelist>
+ <varlistentry>
+ <term><parameter>%d</parameter></term>
+ <listitem><para>name of the current display</para></listitem>
+ </varlistentry>
+ <varlistentry>
+ <term><parameter>%u</parameter></term>
+ <listitem><para>login name of the current user</para></listitem>
+ </varlistentry>
+ <varlistentry>
+ <term><parameter>%r</parameter></term>
+ <listitem><para>empty at first. See below.</para></listitem>
+ </varlistentry>
+ <varlistentry>
+ <term><parameter>%%</parameter></term>
+ <listitem><para>a single <literal>%</literal></para></listitem>
+ </varlistentry>
+ </variablelist>
+ When the constructed filename cannot be used safely and the specification
+ contains
+ <literal>%</literal><replaceable>stuff</replaceable><literal>r</literal>,
+ other names will be tried - this time expanding
+ <literal>%</literal><replaceable>stuff</replaceable><literal>r</literal>
+ to <replaceable>stuff</replaceable> followed by a random number.
+
+Key: ClientLogFallback
+Type: string
+Default: "/tmp/xerr-%u-%d%-r"
+User: core
+Instance: #*/"/var/log/xsession-errors/%u-%d%-r"
+Comment: &
+Description:
+ Fallback when <option>ClientLogFile</option> cannot be used. The same expansions are
+ supported. <emphasis>Do not</emphasis> use relative paths here.
+
+Key: UseSessReg
+Type: bool
+Default: true
+User: core
+Instance: #*/!
+Comment:
+ Whether &kdm;'s built-in utmp/wtmp/lastlog registration should be used.
+Description:
+ Specify whether &kdm;'s built-in utmp/wtmp/lastlog registration should
+ be used. If it is not, the tool <command>sessreg</command> should be used
+ in the <option>Startup</option> and <option>Reset</option> scripts, or,
+ alternatively, the pam_lastlog module should be used on
+ <acronym>PAM</acronym>-enabled systems.
+
+
+Section: -Greeter
+Description:
+ This section class contains options concerning the configuration
+ of the &kdm; frontend (greeter).
+
+Key: GUIStyle
+Type: string
+Default: ""
+User: greeter
+Instance: #*/"Plastique"
+Update: upd_guistyle
+Comment: &
+Description:
+ Specify the widget style for the greeter. Empty means to use the
+ built-in default which currently is <literal>Oxygen-air</literal>.
+
+Key: ColorScheme
+Type: string
+Default: ""
+User: greeter
+Instance: #*/"MidnightMeadow"
+Comment: &
+Description:
+ Specify the widget color scheme for the greeter. Empty means to use the
+ built-in default which currently is <literal>Oxygen-air</literal>.
+
+Key: LogoArea
+Type: enum
+ None/LOGO_NONE: nothing
+ Logo/LOGO_LOGO: the image specified by <option>LogoPixmap</option>
+ Clock/LOGO_CLOCK: a neat analog clock
+Default: Clock
+User: greeter
+Instance: */Logo
+Comment:
+ What should be shown in the greeter's logo are:
+Description:
+ What should be shown in the greeter righthand of the input lines (if
+ <option>UserList</option> is disabled) or above them (if
+ <option>UserList</option> is enabled):
+
+Key: LogoPixmap
+Type: string
+Default: ""
+User: greeter(logo)
+Instance: */KDMDATA "/pics/kdelogo.png"
+Comment:
+ The image to show when LogoArea=Logo.
+Description:
+ The image to show in the greeter if <option>LogoArea</option> is
+ <literal>Logo</literal>.
+
+Key: GreeterPos
+Type: string
+Default: "50,50"
+User: greeter-c
+Instance: #*/"30,40"
+Comment:
+ The relative coordinates (X,Y in percent) of the center of the greeter.
+Description:
+ The relative coordinates (percentages of the screen size; X,Y) at which
+ the center of the greeter is put. &kdm; aligns the greeter to the edges
+ of the screen it would cross otherwise.
+
+Key: GreeterScreen
+Type: int
+Default: 0
+User: greeter
+Instance: #*/-1
+Comment: &
+Description:
+ The screen the greeter should be displayed on in multi-headed and Xinerama
+ setups. The numbering starts with 0. For Xinerama, it corresponds to the
+ listing order in the active ServerLayout section of XF86Config; -1 means
+ to use the upper-left screen, -2 means to use the upper-right screen.
+
+Key: GreetString
+Type: string
+Default: "Welcome to %s at %n"
+User: greeter
+Instance: #*/"K Desktop Environment (%n)"
+Comment:
+ The headline in the greeter. The following character pairs are replaced:
+ - %d -> current display
+ - %h -> host name, possibly with domain name
+ - %n -> node name, most probably the host name without domain name
+ - %s -> the operating system
+ - %r -> the operating system's version
+ - %m -> the machine (hardware) type
+ - %% -> a single %
+Description:
+ The headline in the greeter. An empty greeting means none at all.
+ </para><para>
+ The following character pairs are replaced by their value:
+ <variablelist>
+ <varlistentry>
+ <term><parameter>%d</parameter></term>
+ <listitem><para>name of the current display</para></listitem>
+ </varlistentry>
+ <varlistentry>
+ <term><parameter>%h</parameter></term>
+ <listitem><para>local host name, possibly with the
+  domain name</para></listitem>
+ </varlistentry>
+ <varlistentry>
+ <term><parameter>%n</parameter></term>
+ <listitem><para>local node name, most probably the host name without the
+  domain name</para></listitem>
+ </varlistentry>
+ <varlistentry>
+ <term><parameter>%s</parameter></term>
+ <listitem><para>operating system</para></listitem>
+ </varlistentry>
+ <varlistentry>
+ <term><parameter>%r</parameter></term>
+ <listitem><para>operating system version</para></listitem>
+ </varlistentry>
+ <varlistentry>
+ <term><parameter>%m</parameter></term>
+ <listitem><para>machine (hardware) type</para></listitem>
+ </varlistentry>
+ <varlistentry>
+ <term><parameter>%%</parameter></term>
+ <listitem><para>a single <literal>%</literal></para></listitem>
+ </varlistentry>
+ </variablelist>
+
+# This needs to come _in front_ of the font settings to be effective!
+Key: AntiAliasing
+Type: bool
+Default: false
+User: greeter
+Instance: #*/!
+Comment: &
+Description:
+ Whether the fonts used in the greeter should be antialiased.
+
+Key: GreetFont
+Type: string
+Default: "Serif,20,5,0,50,0"
+CDefault: "Serif,20,bold"
+User: greeter:font
+Instance: #*/"Serif,20,5,0,50,0"
+Comment: &
+Description:
+ The font for the greeter headline.
+
+Key: StdFont
+Type: string
+Default: "Sans Serif,10,5,0,50,0"
+CDefault: "Sans Serif,10"
+User: greeter(normalFont):font
+Instance: #*/"Sans Serif,10,5,0,50,0"
+Comment: &
+Description:
+ The normal font used in the greeter.
+
+Key: FailFont
+Type: string
+Default: "Sans Serif,10,5,0,75,0"
+CDefault: "Sans Serif,10,bold"
+User: greeter:font
+Instance: #*/"Sans Serif,10,5,0,75,0"
+Comment: &
+Description:
+ The font used for the <quote>Login Failed</quote> message.
+
+Key: NumLock
+Type: enum
+ Off: turn off
+ On: turn on
+ Keep: do not change the state
+Default: Keep
+User: greeter(numLockStatus)
+Instance: #*/Off
+Comment: &
+Description:
+ What to do with the Num Lock modifier for the time the greeter is running:
+
+Key: Language
+Type: string
+Default: ""
+User: greeter-c
+Instance: #*/"de_DE"
+Update: upd_language
+Comment: &
+Description:
+ Language and locale to use in the greeter, encoded like $<envar>LANGUAGE</envar>.
+ If empty, the settings from the environment are used.
+
+Key: UserCompletion
+Type: bool
+Default: false
+User: greeter
+Instance: #*/!
+Comment: &
+Description:
+ Enable autocompletion in the username line edit.
+
+Key: UserList
+Type: bool
+Default: true
+User: greeter
+Instance: #*/!
+Comment:
+ Enable user list (names along with images) in the greeter.
+Description:
+ Show a user list with unix login names, real names, and images in the greeter.
+
+Key: ShowUsers
+Type: enum
+ NotHidden/SHOW_ALL: all users except those listed in HiddenUsers
+ Selected/SHOW_SEL: only the users listed in SelectedUsers
+Default: NotHidden
+User: greeter
+Instance: #*/Selected
+Update: upd_showusers
+Comment:
+ User selection for UserCompletion and UserList:
+Description: !
+ This option controls which users will be shown in the user view
+ (<option>UserList</option>) and/or offered for autocompletion
+ (<option>UserCompletion</option>).
+ If it is <literal>Selected</literal>, <option>SelectedUsers</option> contains
+ the final list of users.
+ If it is <literal>NotHidden</literal>, the initial user list contains all
+ users found on the system. Users contained in <option>HiddenUsers</option> are
+ removed from the list, just like all users with a UID greater than specified
+ in <option>MaxShowUID</option> and users with a non-zero UID less than
+ specified in <option>MinShowUID</option>.
+ Items in <option>SelectedUsers</option> and <option>HiddenUsers</option>
+ which are prefixed with <literal>@</literal> represent all users in the
+ user group named by that item.
+ Finally, the user list will be sorted alphabetically, if
+ <option>SortUsers</option> is enabled. 
+
+Key: SelectedUsers
+Type: list
+Default: ""
+User: greeter-c(users)
+Instance: #*/"root,johndoe"
+Merge: kdm:Users
+Comment:
+ For ShowUsers=Selected. @<group> means all users in that group.
+Description:
+ See <option>ShowUsers</option>.
+
+Key: HiddenUsers
+Type: list
+Default: ""
+User: greeter-c(noUsers)
+Instance: #*/"root"
+# depends on {Min,Max}ShowUID
+Update: upd_hiddenusers/1
+Merge: kdm:NoUsers
+Comment:
+ For ShowUsers=NotHidden. @<group> means all users in that group.
+Description:
+ See <option>ShowUsers</option>.
+
+Key: MinShowUID
+Type: int
+Default: 0
+User: greeter(lowUserId)
+# will be overwritten
+Instance: #*/
+Update: upd_minshowuid
+Comment:
+ Special case of HiddenUsers: users with a non-zero UID less than this number
+ will not be shown as well.
+Description:
+ See <option>ShowUsers</option>.
+
+Key: MaxShowUID
+Type: int
+Default: 65535
+User: greeter(highUserId)
+# will be overwritten
+Instance: #*/
+Update: upd_maxshowuid
+Comment:
+ Complement to MinShowUID: users with a UID greater than this number will
+ not be shown as well.
+Description:
+ See <option>ShowUsers</option>.
+
+Key: SortUsers
+Type: bool
+Default: true
+User: greeter
+Instance: #*/!
+Comment:
+ If false, the users are listed in the order they appear in /etc/passwd.
+ If true, they are sorted alphabetically.
+Description:
+ See <option>ShowUsers</option>.
+
+Key: FaceSource
+Type: enum
+ AdminOnly/FACE_ADMIN_ONLY: from <filename>&lt;<option>FaceDir</option>&gt;/$<envar>USER</envar>.face[.icon]</filename>
+ PreferAdmin/FACE_PREFER_ADMIN: prefer &lt;<option>FaceDir</option>&gt;, fallback on $<envar>HOME</envar>
+ PreferUser/FACE_PREFER_USER: ... and the other way round
+ UserOnly/FACE_USER_ONLY: from the user's <filename>$<envar>HOME</envar>/.face[.icon]</filename>
+Default: AdminOnly
+User: greeter
+Instance: #*/PreferUser
+Comment:
+ Specify, where the users' pictures should be taken from.
+Description:
+ If <option>UserList</option> is enabled, this specifies where &kdm; gets the
+ images from:
+ </para>
+ %ENUM%
+ <para>
+ The images can be in any format Qt recognizes, but the filename
+ must match &kdm;'s expectations: <literal>.face.icon</literal> should be a
+ 48x48 icon, while <literal>.face</literal> should be a 300x300 image.
+ Currently the big image is used only as a fallback and is scaled down,
+ but in the future it might be displayed full-size in the logo area or a
+ tooltip.
+
+Key: FaceDir
+Type: string
+Default: *KDMDATA "/faces"
+User: greeter
+Instance: #*/"/usr/share/faces"
+Update: upd_facedir
+Comment:
+ The directory containing the user images if FaceSource is not UserOnly.
+Description:
+ See <option>FaceSource</option>.
+
+Key: PreselectUser
+Type: enum
+ None/PRESEL_NONE: do not preselect any user
+ Previous/PRESEL_PREV: the user which successfully logged in last time
+ Default/PRESEL_DEFAULT: the user specified in the <option>DefaultUser</option> option
+Default: None
+User: greeter(preselUser)
+Instance: #*/Previous
+Instance: :*/Previous
+Instance: #:0/Default
+Comment:
+ Specify, if/which user should be preselected for log in.
+Description:
+ Specify, if/which user should be preselected for log in:
+ </para>
+ %ENUM%
+ <para>
+ If <option>FocusPasswd</option> is enabled and a user was preselected,
+ the cursor is placed in the password input field automatically.
+ </para>
+ <note><para>Enabling user preselection can be considered a security hole,
+ as it presents a valid login name to a potential attacker, so he
+ <quote>only</quote> needs to guess the password. On the other hand,
+ one could set <option>DefaultUser</option> to a fake login name.</para></note>
+ <para>
+
+Key: DefaultUser
+Type: string
+Default: ""
+User: greeter
+Instance: #:0/"johndoe"
+Comment:
+ The user to preselect if PreselectUser=Default.
+Description:
+ See <option>PreselectUser</option>.
+
+Key: FocusPasswd
+Type: bool
+Default: false
+User: greeter
+Instance: #*/!
+Instance: :*/true
+Comment:
+ If this is true, the password input line is focused automatically if
+ a user is preselected.
+Description:
+ See <option>PreselectUser</option>.
+
+Key: EchoPasswd
+Type: bool
+Default: true
+User: greeter
+Instance: #*/!
+Merge: kdm:EchoMode(P_EchoMode)
+Comment: &
+Description:
+ If this is true, the entered password is echoed as bullets. Otherwise,
+ no feedback is given at all.
+
+Key: UseBackground
+Type: bool
+Default: true
+User: greeter
+Instance: #*/!
+Comment:
+ If true, krootimage will be automatically started by &kdm;; otherwise, the
+ Setup script should be used to setup the background.
+Description:
+ If enabled, &kdm; will automatically start the <command>krootimage</command>
+ program to set up the background; otherwise, the <option>Setup</option>
+ program is responsible for the background.
+
+Key: BackgroundCfg
+Type: string
+Default: *KDMCONF "/backgroundrc"
+User: greeter-c
+Instance: #*/""
+Update: handleBgCfg
+Comment:
+ The configuration file to be used by krootimage.
+Description:
+ The configuration file to be used by <command>krootimage</command>.
+ It contains a section named <literal>[Desktop0]</literal> like
+ <filename>kdesktoprc</filename> does. Its options are not described
+ herein; guess their meanings or use the control center.
+
+Key: GrabInput
+Type: enum
+ Never/GRAB_NEVER: never grab
+ IfNoAuth/GRAB_IFNOAUTH: grab if the display requires no X authorization
+ Always/GRAB_ALWAYS: always grab
+Default: IfNoAuth
+User: greeter-c(grabInputPre)
+Instance: #*/Always
+Comment:
+ Whether to grab keyboard and mouse while the greeter is visible. Grabs
+ may improve security, but make on-screen keyboards, etc. unusable.
+Description:
+ To improve security, the greeter may grab mouse and keyboard input so
+ no other X clients can eavesdrop it. However, the X authorization
+ mechanism will usually prevent malicious X clients from connecting
+ in the first place. Consequently, enabling grabs for local displays
+ is pointless and only marginally improves security for remote displays.
+ </para>
+ <note><para>The mouse grab will make on-screen keyboards unusable.
+ </para></note>
+ <para>
+
+Key: GrabServer
+Type: bool
+Default: false
+User: greeter-c
+Instance: #*/!
+Comment:
+ Hold the &X-Server; grabbed the whole time the greeter is visible. This
+ may be more secure, but it will disable any background and other
+ X-clients started from the Setup script.
+Description:
+ To improve security, the greeter grabs the &X-Server; and then the input
+ when it starts up. This option specifies if the &X-Server; grab should be held
+ for the duration of the name/password reading. When disabled, the &X-Server;
+ is ungrabbed after the input grabs succeed; otherwise, the &X-Server; is
+ grabbed until just before the session begins.
+ </para>
+ <note><para>Enabling this option disables <option>UseBackground</option> and
+ <option>Setup</option>.</para></note>
+ <para>
+
+Key: GrabTimeout
+Type: int
+Default: 3
+User: greeter
+Instance: #*/
+Comment:
+ How many seconds to wait for grab to succeed.
+Description:
+ This option specifies the maximum time &kdm; will wait for the grabs to
+ succeed. A grab may fail if some other X-client has the &X-Server; or the
+ keyboard grabbed, or possibly if the network latencies are very high. You
+ should be cautious when raising the timeout, as a user can be spoofed by
+ a look-alike window on the display. If a grab fails, &kdm; kills and
+ restarts the &X-Server; (if possible) and the session. 
+
+Key: AuthComplain
+Type: bool
+Default: true
+User: greeter
+Instance: #*/!
+Merge: xdm
+Comment:
+ Warn, if display has no X-authorization (local auth cannot be created,
+ &XDMCP; display wants no auth, or display is foreign from StaticServers).
+Description:
+ Warn, if a display has no X-authorization. This will be the case if
+ <itemizedlist>
+  <listitem><para>
+   the authorization file for a local &X-Server; could not be created,
+  </para></listitem>
+  <listitem><para>
+   a remote display from &XDMCP; did not request any authorization or
+  </para></listitem>
+  <listitem><para>
+   the display is a <quote>foreign</quote> display specified in
+   <option>StaticServers</option>.
+  </para></listitem>
+ </itemizedlist>
+
+Key: LoginMode
+If: defined(XDMCP)
+Type: enum
+ LocalOnly/LOGIN_LOCAL_ONLY: only local login possible
+ DefaultLocal/LOGIN_DEFAULT_LOCAL: start up in local mode, but allow switching to remote mode
+ DefaultRemote/LOGIN_DEFAULT_REMOTE: ... and the other way round
+ RemoteOnly/LOGIN_REMOTE_ONLY: only choice of remote host possible
+Default: LocalOnly
+User: core
+User: greeter
+Instance: :*/DefaultLocal
+# from make_it_cool branch and SuSE 8.1
+Merge: kdm:EnableChooser(P_EnableChooser)
+Comment: &
+Description:
+ Specify whether the greeter of local displays should start up in host chooser
+ (remote) or login (local) mode and whether it is allowed to switch to the
+ other mode.
+
+Key: ChooserHosts
+If: defined(XDMCP)
+Type: list
+Default: "*"
+User: core
+Instance: #:*/"*,ugly,sky,dino,kiste.local,login.crap.com"
+Comment:
+ A list of hosts to be automatically added to the remote login menu. The
+ special name "*" means broadcast.
+Description:
+ A list of hosts to be automatically added to the remote login menu.
+ The special name <literal>*</literal> means broadcast.
+ Has no effect if <option>LoginMode</option> is <literal>LocalOnly</literal>.
+
+Key: ForgingSeed
+Type: int
+Default: 0
+User: greeter
+Instance: #*/
+Update: upd_forgingseed
+Comment:
+ Random seed for forging saved session types, etc. of unknown users.
+ This value should be random but constant across the login domain.
+Description:
+ Use this number as a random seed when forging saved session types, etc. of
+ unknown users. This is used to avoid telling an attacker about existing users
+ by reverse conclusion. This value should be random but constant across the
+ login domain.
+
+Key: ShowLog
+If: defined(WITH_KDM_XCONSOLE)
+Type: bool
+Default: false
+User: greeter
+Instance: :0/true
+Comment:
+ Enable &kdm;'s built-in xconsole. Note that this can be enabled for only
+ one display at a time.
+Description:
+ Enable &kdm;'s built-in <command>xconsole</command>.
+ Note that this can be enabled for only one display at a time.
+ This option is available only if &kdm; was <command>configure</command>d
+ with <option>--enable-kdm-xconsole</option>.
+
+Key: LogSource
+If: defined(WITH_KDM_XCONSOLE)
+Type: string
+Default: ""
+User: greeter-c
+Instance: :0/"/dev/xconsole"
+Comment:
+ The data source for &kdm;'s built-in xconsole.
+ If empty, a console log redirection is requested from /dev/console.
+Description:
+ The data source for &kdm;'s built-in <command>xconsole</command>.
+ If empty, a console log redirection is requested from
+ <filename>/dev/console</filename>.
+ Has no effect if <option>ShowLog</option> is disabled.
+
+Key: PluginsLogin
+Type: list
+Default: "classic"
+User: greeter
+Instance: #*/"sign"
+Comment:
+ Specify conversation plugins for the login dialog. Each plugin can be
+ specified as a base name (which expands to $kde_modulesdir/kgreet_$base)
+ or as a full pathname.
+Description:
+ Specify conversation plugins for the login dialog; the first in the list
+ is selected initially.
+ Each plugin can be specified as a base name (which expands to
+ <filename>$<envar>kde_modulesdir</envar>/kgreet_<replaceable>base</replaceable></filename>)
+ or as a full pathname.
+ </para><para>
+ Conversation plugins are modules for the greeter which obtain authentication
+ data from the user. Currently only the <literal>classic</literal> plugin is
+ shipped with &kde;; it presents the well-known username and password form.
+
+Key: PluginsShutdown
+Type: list
+Default: "classic"
+User: greeter
+Instance: #*/"modern"
+Comment: &
+Description:
+ Same as <option>PluginsLogin</option>, but for the shutdown dialog.
+
+Key: PluginOptions
+Type: list
+Default: ""
+User: greeter
+Instance: #*/"SomeKey=randomvalue,Foo=bar"
+Comment:
+ A list of options of the form Key=Value. The conversation plugins can query
+ these settings; it is up to them what possible keys are.
+Description:
+ A list of options of the form
+ <replaceable>Key</replaceable><literal>=</literal><replaceable>Value</replaceable>.
+ The conversation plugins can query these settings; it is up to them what
+ possible keys are.
+
+Key: AllowConsole
+Type: bool
+Default: true
+User: greeter(hasConsole)
+Instance: #*/!
+Comment: &
+Description:
+ Show the <guilabel>Console Login</guilabel> action in the greeter (if <option>ServerTTY</option>/<option>ConsoleTTYs</option>
+ is configured).
+
+Key: AllowClose
+Type: bool
+Default: true
+User: greeter
+Instance: :*/false
+Comment: &
+Description:
+ Show the <guilabel>Restart X Server</guilabel>/<guilabel>Close Connection</guilabel> action in the greeter.
+
+Key: Preloader
+Type: string
+Default: ""
+User: greeter-c
+Instance: */KDE_BINDIR "/preloadkde"
+Update: upd_preloader
+Comment: &
+Description:
+ A program to run while the greeter is visible. It is supposed to preload
+ as much as possible of the session that is going to be started (most
+ probably).
+
+Key: UseTheme
+Type: bool
+Default: false
+User: greeter
+Instance: */true
+Comment: &
+Description:
+ Whether the greeter should be themed.
+
+Key: Theme
+Type: string
+Default: ""
+User: greeter
+Instance: */KDMDATA "/themes/oxygen-air"
+Comment: &
+Description:
+ The theme to use for the greeter. Can point to either a directory or an XML
+ file.
diff -Nru kdebase-workspace-4.3.73svn1040395/kdm/kfrontend/CMakeLists.txt kdebase-workspace-4.3.73svn1040395-new/kdm/kfrontend/CMakeLists.txt
--- kdebase-workspace-4.3.73svn1040395/kdm/kfrontend/CMakeLists.txt	2009-10-02 16:54:04.000000000 +0200
+++ kdebase-workspace-4.3.73svn1040395-new/kdm/kfrontend/CMakeLists.txt	2009-10-28 22:58:08.000000000 +0100
@@ -112,5 +112,5 @@
 
 ## use 'GENKDMCONF_FLAGS=... make install' to add flags to the config generation (try genkdmconf -h)
 install(CODE "
-exec_program(\"${CMAKE_CURRENT_BINARY_DIR}/genkdmconf\" ARGS --in \\\"\\\$DESTDIR${CONFIG_INSTALL_DIR}/kdm\\\" --no-in-notice --face-src \\\"${CMAKE_CURRENT_SOURCE_DIR}/pics\\\" \\\$GENKDMCONF_FLAGS)
+exec_program(\"${CMAKE_CURRENT_BINARY_DIR}/genkdmconf\" ARGS --in \\\"\\\${DESTDIR}/etc/X11/kdm\\\" --no-in-notice --face-src \\\"${CMAKE_CURRENT_SOURCE_DIR}/pics\\\" \\\$GENKDMCONF_FLAGS)
 ")
diff -Nru kdebase-workspace-4.3.73svn1040395/kdm/kfrontend/CMakeLists.txt.orig kdebase-workspace-4.3.73svn1040395-new/kdm/kfrontend/CMakeLists.txt.orig
--- kdebase-workspace-4.3.73svn1040395/kdm/kfrontend/CMakeLists.txt.orig	1970-01-01 01:00:00.000000000 +0100
+++ kdebase-workspace-4.3.73svn1040395-new/kdm/kfrontend/CMakeLists.txt.orig	2009-10-02 16:54:04.000000000 +0200
@@ -0,0 +1,116 @@
+include(MacroAddFileDependencies)
+
+add_subdirectory( themes )
+add_subdirectory( pics )
+add_subdirectory( sessions )
+
+include_directories(
+	${KDEBASE_WORKSPACE_SOURCE_DIR}/kcontrol/kdm/background
+	${KDEBASE_WORKSPACE_SOURCE_DIR}/libs/kdm
+	${QIMAGEBLITZ_INCLUDES}
+)
+
+set(kdmthemer_SRCS
+	themer/kdmthemer.cpp
+	themer/kdmthemer.h
+	themer/kdmitem.cpp
+	themer/kdmitem.h
+	themer/kdmpixmap.cpp
+	themer/kdmpixmap.h
+	themer/kdmrect.cpp
+	themer/kdmrect.h
+	themer/kdmlist.cpp
+	themer/kdmlist.h
+	themer/kdmlabel.cpp
+	themer/kdmlabel.h
+	themer/kdmbutton.cpp
+	themer/kdmbutton.h
+	themer/kdmlayout.cpp
+	themer/kdmlayout.h
+	themer/parse.cpp
+	themer/parse.h
+)
+set(kdm_greet_SRCS
+	kdm_greet.c
+	kdm_greet.h
+	kdmconfig.cpp
+	kdmconfig.h
+	kdmclock.cpp
+	kdmclock.h
+	kfdialog.cpp
+	kfdialog.h
+	kgdialog.cpp
+	kgdialog.h
+	kgverify.cpp
+	kgverify.h
+	kdmshutdown.cpp
+	kdmshutdown.h
+	kgreeter.cpp
+	kgreeter.h
+	kgapp.cpp
+	kgapp.h
+	utils.cpp
+	utils.h
+	${kdmthemer_SRCS}
+)
+
+if (XDMCP)
+	set(kdm_greet_SRCS ${kdm_greet_SRCS}
+		kchooser.cpp
+		kchooser.h
+	)
+endif (XDMCP)
+
+if (WITH_KDM_XCONSOLE)
+	set(kdm_greet_SRCS ${kdm_greet_SRCS}
+		kconsole.cpp
+		kconsole.h
+	)
+endif (WITH_KDM_XCONSOLE)
+
+macro_add_file_dependencies(kdm_greet.h ${confci})
+kde4_add_executable(kdm_greet ${kdm_greet_SRCS})
+target_link_libraries(kdm_greet ${KDE4_KDEUI_LIBS} ${QT_QTXML_LIBRARY} ${X11_X11_LIB} ${POSIX4_LIBRARIES})
+if (X11_XTest_FOUND)
+  target_link_libraries(kdm_greet ${X11_XTest_LIB})
+endif (X11_XTest_FOUND)
+if (WITH_KDM_XCONSOLE)
+  target_link_libraries(kdm_greet ${KDE4_KPTY_LIBS})
+endif (WITH_KDM_XCONSOLE)
+
+install(TARGETS kdm_greet DESTINATION ${LIBEXEC_INSTALL_DIR})
+
+set(kdm_config_SRCS kdm_config.c)
+macro_add_file_dependencies(kdm_config.c ${confci})
+kde4_add_executable(kdm_config NOGUI ${kdm_config_SRCS})
+macro_add_compile_flags(kdm_config -U_REENTRANT)
+target_link_libraries(kdm_config ${SOCKET_LIBRARIES} ${RESOLV_LIBRARIES} ${POSIX4_LIBRARIES})
+add_dependencies(kdm_config ConfigCi)
+install(TARGETS kdm_config DESTINATION ${LIBEXEC_INSTALL_DIR})
+
+set(krootimage_SRCS krootimage.cpp krootimage.h ${backgroundlib_SRCS})
+kde4_add_executable(krootimage ${krootimage_SRCS})
+target_link_libraries(krootimage ${KDE4_KDEUI_LIBS} ${X11_X11_LIB} ${QIMAGEBLITZ_LIBRARIES})
+install(TARGETS krootimage DESTINATION ${LIBEXEC_INSTALL_DIR})
+
+set(genkdmconf_SRCS genkdmconf.c)
+macro_add_file_dependencies(genkdmconf.c ${confci})
+kde4_add_executable(genkdmconf NOGUI ${genkdmconf_SRCS})
+macro_add_compile_flags(genkdmconf -U_REENTRANT)
+target_link_libraries(genkdmconf ${X11_LIBRARIES})
+add_dependencies(genkdmconf ConfigCi)
+install(TARGETS genkdmconf ${INSTALL_TARGETS_DEFAULT_ARGS})
+
+set(kdmctl_SRCS kdmctl.c)
+kde4_add_executable(kdmctl ${kdmctl_SRCS})
+macro_add_compile_flags(kdmctl -U_REENTRANT)
+target_link_libraries(kdmctl ${SOCKET_LIBRARIES})
+add_dependencies(kdmctl ConfigCi)
+
+install(TARGETS kdmctl ${INSTALL_TARGETS_DEFAULT_ARGS})
+
+
+## use 'GENKDMCONF_FLAGS=... make install' to add flags to the config generation (try genkdmconf -h)
+install(CODE "
+exec_program(\"${CMAKE_CURRENT_BINARY_DIR}/genkdmconf\" ARGS --in \\\"\\\$DESTDIR${CONFIG_INSTALL_DIR}/kdm\\\" --no-in-notice --face-src \\\"${CMAKE_CURRENT_SOURCE_DIR}/pics\\\" \\\$GENKDMCONF_FLAGS)
+")
diff -Nru kdebase-workspace-4.3.73svn1040395/kdm/kfrontend/genkdmconf.c kdebase-workspace-4.3.73svn1040395-new/kdm/kfrontend/genkdmconf.c
--- kdebase-workspace-4.3.73svn1040395/kdm/kfrontend/genkdmconf.c	2009-10-26 10:14:48.000000000 +0100
+++ kdebase-workspace-4.3.73svn1040395-new/kdm/kfrontend/genkdmconf.c	2009-10-28 22:58:55.000000000 +0100
@@ -3162,7 +3162,7 @@
 	f = createFile( "README", 0644 );
 	fprintf_( f,
 "This automatically generated configuration consists of the following files:\n" );
-	fprintf_( f, "- " KDMCONF "/kdmrc\n" );
+	fprintf( f, "- /etc/X11/kdm/kdmrc\n" );
 	for (fp = aflist; fp; fp = fp->next)
 		fprintf_( f, "- %s\n", fp->str );
 	if (use_destdir && !no_in_notice)
diff -Nru kdebase-workspace-4.3.73svn1040395/kdm/kfrontend/genkdmconf.c.orig kdebase-workspace-4.3.73svn1040395-new/kdm/kfrontend/genkdmconf.c.orig
--- kdebase-workspace-4.3.73svn1040395/kdm/kfrontend/genkdmconf.c.orig	1970-01-01 01:00:00.000000000 +0100
+++ kdebase-workspace-4.3.73svn1040395-new/kdm/kfrontend/genkdmconf.c.orig	2009-10-26 10:14:48.000000000 +0100
@@ -0,0 +1,3211 @@
+/*
+
+Create a suitable configuration for kdm taking previous xdm/kdm
+installations into account
+
+Copyright (C) 2001-2005 Oswald Buddenhagen <ossi@kde.org>
+
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+
+*/
+
+#include <greet.h>
+
+#include <X11/Xlib.h>
+#include <X11/Xresource.h>
+
+#include <sys/types.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <string.h>
+#include <ctype.h>
+#include <stdarg.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <utime.h>
+#include <dirent.h>
+#include <errno.h>
+#include <pwd.h>
+#include <time.h>
+#include <limits.h>
+#include <sys/stat.h>
+#include <sys/param.h>
+#ifdef BSD
+# include <utmp.h>
+#endif
+
+#define WANT_CONF_GEN
+#include <config.ci>
+
+#define RCVERSTR stringify(RCVERMAJOR) "." stringify(RCVERMINOR)
+
+static int old_scripts, no_old_scripts, old_confs, no_old,
+	no_backup, no_in_notice, use_destdir, mixed_scripts;
+static const char *newdir = KDMCONF, *facesrc = KDMDATA "/pics/users",
+	*oldxdm, *oldkde, *oldkdepfx;
+
+static int oldver;
+
+
+typedef struct StrList {
+	struct StrList *next;
+	const char *str;
+} StrList;
+
+typedef struct StrMap {
+	struct StrMap *next;
+	const char *key, *value;
+} StrMap;
+
+
+static void *
+mmalloc( size_t sz )
+{
+	void *ptr;
+
+	if (!(ptr = malloc( sz ))) {
+		fprintf( stderr, "Out of memory\n" );
+		exit( 1 );
+	}
+	return ptr;
+}
+
+static void *
+mcalloc( size_t sz )
+{
+	void *ptr;
+
+	if (!(ptr = calloc( 1, sz ))) {
+		fprintf( stderr, "Out of memory\n" );
+		exit( 1 );
+	}
+	return ptr;
+}
+
+static void *
+mrealloc( void *optr, size_t sz )
+{
+	void *ptr;
+
+	if (!(ptr = realloc( optr, sz ))) {
+		fprintf( stderr, "Out of memory\n" );
+		exit( 1 );
+	}
+	return ptr;
+}
+
+static char *
+mstrdup( const char *optr )
+{
+	char *ptr;
+
+	if (!optr)
+		return 0;
+	if (!(ptr = strdup( optr ))) {
+		fprintf( stderr, "Out of memory\n" );
+		exit( 1 );
+	}
+	return ptr;
+}
+
+
+#define NO_LOGGER
+#define STATIC static
+#include <printf.c>
+
+typedef struct {
+	char *buf;
+	int clen, blen, tlen;
+} OCABuf;
+
+static void
+outCh_OCA( void *bp, char c )
+{
+	OCABuf *ocabp = (OCABuf *)bp;
+
+	ocabp->tlen++;
+	if (ocabp->clen >= ocabp->blen) {
+		ocabp->blen = ocabp->blen * 3 / 2 + 100;
+		ocabp->buf = mrealloc( ocabp->buf, ocabp->blen );
+	}
+	ocabp->buf[ocabp->clen++] = c;
+}
+
+static int
+VASPrintf( char **strp, const char *fmt, va_list args )
+{
+	OCABuf ocab = { 0, 0, 0, -1 };
+
+	doPrint( outCh_OCA, &ocab, fmt, args );
+	outCh_OCA( &ocab, 0 );
+	*strp = realloc( ocab.buf, ocab.clen );
+	if (!*strp)
+		*strp = ocab.buf;
+	return ocab.tlen;
+}
+
+static int
+ASPrintf( char **strp, const char *fmt, ... )
+{
+	va_list args;
+	int len;
+
+	va_start( args, fmt );
+	len = VASPrintf( strp, fmt, args );
+	va_end( args );
+	return len;
+}
+
+static void
+strCat( char **strp, const char *fmt, ... )
+{
+	char *str, *tstr;
+	va_list args;
+	int el;
+
+	va_start( args, fmt );
+	el = VASPrintf( &str, fmt, args );
+	va_end( args );
+	if (*strp) {
+		int ol = strlen( *strp );
+		tstr = mmalloc( el + ol + 1 );
+		memcpy( tstr, *strp, ol );
+		memcpy( tstr + ol, str, el + 1 );
+		free( *strp );
+		free( str );
+		*strp = tstr;
+	} else
+		*strp = str;
+}
+
+
+#define WANT_CLOSE 1
+
+typedef struct File {
+	char *buf, *eof, *cur;
+#if defined(HAVE_MMAP) && defined(WANT_CLOSE)
+	int ismapped;
+#endif
+} File;
+
+static int
+readFile( File *file, const char *fn )
+{
+	off_t flen;
+	int fd;
+
+	if ((fd = open( fn, O_RDONLY )) < 0)
+		return False;
+
+	flen = lseek( fd, 0, SEEK_END );
+#ifdef HAVE_MMAP
+# ifdef WANT_CLOSE
+	file->ismapped = False;
+# endif
+	file->buf = mmap( 0, flen + 1, PROT_READ | PROT_WRITE, MAP_PRIVATE, fd, 0 );
+# ifdef WANT_CLOSE
+	if (file->buf)
+		file->ismapped = True;
+	else
+# else
+	if (!file->buf)
+# endif
+#endif
+	{
+		file->buf = mmalloc( flen + 1 );
+		lseek( fd, 0, SEEK_SET );
+		if (read( fd, file->buf, flen ) != flen) {
+			free( file->buf );
+			close( fd );
+			fprintf( stderr, "Cannot read file\n" );
+			return False; /* maybe better abort? */
+		}
+	}
+	file->eof = file->buf + flen;
+	close( fd );
+	return True;
+}
+
+#ifdef WANT_CLOSE
+static void
+freeBuf( File *file )
+{
+# ifdef HAVE_MMAP
+	if (file->ismapped)
+		munmap( file->buf, file->eof - file->buf );
+	else
+# endif
+		free( file->buf );
+}
+#endif
+
+static int
+isTrue( const char *val )
+{
+	return !strcmp( val, "true" ) ||
+	       !strcmp( val, "yes" ) ||
+	       !strcmp( val, "on" ) ||
+	       atoi( val );
+}
+
+
+static int
+mkpdirs( const char *name, const char *what )
+{
+	char *mfname = mstrdup( name );
+	int i;
+	struct stat st;
+
+	for (i = 1; mfname[i]; i++)
+		if (mfname[i] == '/') {
+			mfname[i] = 0;
+			if (stat( mfname, &st )) {
+				if (mkdir( mfname, 0755 )) {
+					fprintf( stderr, "Cannot create parent %s of %s directory %s: %s\n",
+					         mfname, what, name, strerror( errno ) );
+					free( mfname );
+					return False;
+				}
+				chmod( mfname, 0755 );
+			}
+			mfname[i] = '/';
+		}
+	free( mfname );
+	return True;
+}
+
+static int
+mkdirp( const char *name, int mode, const char *what, int existok )
+{
+	struct stat st;
+
+	if (stat( name, &st )) {
+		mkpdirs( name, what );
+		if (mkdir( name, mode )) {
+			fprintf( stderr, "Cannot create %s directory %s: %s\n",
+			         what, name, strerror( errno ) );
+			return False;
+		}
+		chmod( name, mode );
+		return True;
+	}
+	return existok;
+}
+
+
+static void
+displace( const char *fn )
+{
+	if (!no_backup) {
+		char bn[PATH_MAX + 4];
+		sprintf( bn, "%s.bak", fn ); /* won't overflow if only existing paths are passed */
+		rename( fn, bn );
+	} else
+		unlink( fn );
+}
+
+
+static char *curName;
+
+/* Create a new file in KDMCONF */
+static FILE *
+createFile( const char *fn, int mode )
+{
+	FILE *f;
+
+	free( curName );
+	ASPrintf( &curName, "%s/%s", newdir, fn );
+	displace( curName );
+	if (!(f = fopen( curName, "w" ))) {
+		fprintf( stderr, "Cannot create %s\n", curName );
+		exit( 1 );
+	}
+	chmod( curName, mode );
+	return f;
+}
+
+static void
+writeError()
+{
+	fprintf( stderr, "Warning: cannot write %s (disk full?)\n", curName );
+	unlink( curName );
+	exit( 1 );
+}
+
+static void
+fputs_( const char *str, FILE *f )
+{
+	if (fputs( str, f ) == EOF)
+		writeError();
+}
+
+static void
+ATTR_PRINTFLIKE(2, 3)
+fprintf_( FILE *f, const char *fmt, ... )
+{
+	va_list args;
+
+	va_start( args, fmt );
+	if (vfprintf( f, fmt, args ) < 0)
+		writeError();
+	va_end( args );
+}
+
+static void
+fclose_( FILE *f )
+{
+	if (fclose( f ) == EOF)
+		writeError();
+}
+
+
+static char *
+locate( const char *exe )
+{
+	int len;
+	char *path, *pathe, *name, *thenam, nambuf[PATH_MAX+1];
+
+	if (!(path = getenv( "PATH" )))
+		return 0;
+	len = strlen( exe );
+	name = nambuf + PATH_MAX - len;
+	memcpy( name, exe, len + 1 );
+	*--name = '/';
+	do {
+		if (!(pathe = strchr( path, ':' )))
+			pathe = path + strlen( path );
+		len = pathe - path;
+		if (len && !(len == 1 && *path == '.')) {
+			thenam = name - len;
+			if (thenam >= nambuf) {
+				memcpy( thenam, path, len );
+				if (!access( thenam, X_OK ))
+					return mstrdup( thenam );
+			}
+		}
+		path = pathe;
+	} while (*path++ != '\0');
+	return 0;
+}
+
+
+/*
+ * target data to be written to kdmrc
+ */
+
+typedef struct Entry {
+	struct Entry *next;
+	struct Ent *spec;
+	const char *value;
+	int active:1;
+	int written:1;
+} Entry;
+
+typedef struct Section {
+	struct Section *next;
+	struct Sect *spec;
+	const char *name;
+	const char *comment;
+	Entry *ents;
+} Section;
+
+static Section *config; /* the kdmrc data to be written */
+
+/*
+ * Specification of the (currently possible) kdmrc entries
+ */
+
+typedef struct Ent {
+	const char *key;
+	int prio;
+	void (*func)( Entry *ce, Section *cs );
+	const char *comment;
+} Ent;
+
+typedef struct Sect {
+	const char *name;
+	Ent *ents;
+	int nents;
+} Sect;
+
+static Sect *findSect( const char *name );
+static Ent *findEnt( Sect *sect, const char *key );
+
+/*
+ * Functions to manipulate the current kdmrc data
+ */
+
+static const char *
+getFqVal( const char *sect, const char *key, const char *defval )
+{
+	Section *cs;
+	Entry *ce;
+
+	for (cs = config; cs; cs = cs->next)
+		if (!strcmp( cs->name, sect )) {
+			for (ce = cs->ents; ce; ce = ce->next)
+				if (!strcmp( ce->spec->key, key )) {
+					if (ce->active && ce->written)
+						return ce->value;
+					break;
+				}
+			break;
+		}
+	return defval;
+}
+
+static void
+putFqVal( const char *sect, const char *key, const char *value )
+{
+	Section *cs, **csp;
+	Entry *ce, **cep;
+
+	if (!value)
+		return;
+
+	for (csp = &config; (cs = *csp); csp = &(cs->next))
+		if (!strcmp( sect, cs->name ))
+			goto havesec;
+	cs = mcalloc( sizeof(*cs) );
+	ASPrintf( (char **)&cs->name, "%s", sect );
+	cs->spec = findSect( sect );
+	*csp = cs;
+  havesec:
+
+	for (cep = &(cs->ents); (ce = *cep); cep = &(ce->next))
+		if (!strcmp( key, ce->spec->key ))
+			goto haveent;
+	ce = mcalloc( sizeof(*ce) );
+	ce->spec = findEnt( cs->spec, key );
+	*cep = ce;
+  haveent:
+	ASPrintf( (char **)&ce->value, "%s", value );
+	ce->written = ce->active = True;
+}
+
+static const char *csect;
+
+#define setSect(se) csect = se
+
+static void
+putVal( const char *key, const char *value )
+{
+	putFqVal( csect, key, value );
+}
+
+
+static void
+writeKdmrc( FILE *f )
+{
+	Section *cs;
+	Entry *ce;
+	StrList *sl = 0, *sp;
+	const char *cmt;
+
+	putFqVal( "General", "ConfigVersion", RCVERSTR );
+	for (cs = config; cs; cs = cs->next) {
+		fprintf_( f, "%s[%s]\n",
+		          cs->comment ? cs->comment : "\n", cs->name );
+		for (ce = cs->ents; ce; ce = ce->next) {
+			if (ce->spec->comment) {
+				cmt = ce->spec->comment;
+				for (sp = sl; sp; sp = sp->next)
+					if (sp->str == cmt) {
+						cmt = "# See above\n";
+						goto havit;
+					}
+				if (!(sp = malloc( sizeof(*sp) )))
+					fprintf_( stderr, "Warning: Out of memory\n" );
+				else {
+					sp->str = cmt;
+					sp->next = sl; sl = sp;
+				}
+			} else
+				cmt = "";
+		  havit:
+			fprintf_( f, "%s%s%s=%s\n",
+			          cmt, ce->active ? "" : "#", ce->spec->key, ce->value );
+		}
+	}
+}
+
+
+/*
+ * defaults
+ */
+#ifdef XDMCP
+static const char def_xaccess[] =
+"# Xaccess - Access control file for XDMCP connections\n"
+"#\n"
+"# To control Direct and Broadcast access:\n"
+"#\n"
+"#	pattern\n"
+"#\n"
+"# To control Indirect queries:\n"
+"#\n"
+"#	pattern		list of hostnames and/or macros ...\n"
+"#\n"
+"# To use the chooser:\n"
+"#\n"
+"#	pattern		CHOOSER BROADCAST\n"
+"#\n"
+"# or\n"
+"#\n"
+"#	pattern		CHOOSER list of hostnames and/or macros ...\n"
+"#\n"
+"# To define macros:\n"
+"#\n"
+"#	%name		list of hosts ...\n"
+"#\n"
+"# The first form tells xdm which displays to respond to itself.\n"
+"# The second form tells xdm to forward indirect queries from hosts matching\n"
+"# the specified pattern to the indicated list of hosts.\n"
+"# The third form tells xdm to handle indirect queries using the chooser;\n"
+"# the chooser is directed to send its own queries out via the broadcast\n"
+"# address and display the results on the terminal.\n"
+"# The fourth form is similar to the third, except instead of using the\n"
+"# broadcast address, it sends DirectQuerys to each of the hosts in the list\n"
+"#\n"
+"# In all cases, xdm uses the first entry which matches the terminal;\n"
+"# for IndirectQuery messages only entries with right hand sides can\n"
+"# match, for Direct and Broadcast Query messages, only entries without\n"
+"# right hand sides can match.\n"
+"#\n"
+"\n"
+"*					#any host can get a login window\n"
+"\n"
+"#\n"
+"# To hardwire a specific terminal to a specific host, you can\n"
+"# leave the terminal sending indirect queries to this host, and\n"
+"# use an entry of the form:\n"
+"#\n"
+"\n"
+"#terminal-a	host-a\n"
+"\n"
+"\n"
+"#\n"
+"# The nicest way to run the chooser is to just ask it to broadcast\n"
+"# requests to the network - that way new hosts show up automatically.\n"
+"# Sometimes, however, the chooser cannot figure out how to broadcast,\n"
+"# so this may not work in all environments.\n"
+"#\n"
+"\n"
+"*		CHOOSER BROADCAST	#any indirect host can get a chooser\n"
+"\n"
+"#\n"
+"# If you would prefer to configure the set of hosts each terminal sees,\n"
+"# then just uncomment these lines (and comment the CHOOSER line above)\n"
+"# and edit the %hostlist line as appropriate\n"
+"#\n"
+"\n"
+"#%hostlist	host-a host-b\n"
+"\n"
+"#*		CHOOSER %hostlist	#\n";
+#endif
+
+#ifdef XDMCP
+static const char def_willing[] =
+"#! /bin/sh\n"
+"# The output of this script is displayed in the chooser window\n"
+"# (instead of \"Willing to manage\").\n"
+"\n"
+"load=`uptime|sed -e 's/^.*load[^0-9]*//'`\n"
+"nrusers=`who|cut -c 1-8|sort -u|wc -l|sed 's/^[ \t]*//'`\n"
+"s=\"\"; [ \"$nrusers\" != 1 ] && s=s\n"
+"\n"
+"echo \"${nrusers} user${s}, load: ${load}\"\n";
+#endif
+
+static const char def_setup[] =
+"#! /bin/sh\n"
+"# Xsetup - run as root before the login dialog appears\n"
+"\n"
+"#xconsole -geometry 480x130-0-0 -notify -verbose -fn fixed -exitOnFail -file /dev/xconsole &\n";
+
+static const char def_startup[] =
+"#! /bin/sh\n"
+"# Xstartup - run as root before session starts\n"
+"\n"
+"# By convention, both xconsole and xterm -C check that the\n"
+"# console is owned by the invoking user and is readable before attaching\n"
+"# the console output.  This way a random user can invoke xterm -C without\n"
+"# causing serious grief; still, it can cause havoc, so xconsole is started\n"
+"# by Xsetup usually.\n"
+"# This is not required if you use PAM with the pam_console module.\n"
+"#\n"
+"#chown $USER /dev/console\n"
+"\n"
+#ifdef _AIX
+"# We create a pseudodevice for finger.  (host:0 becomes xdm/host_0)\n"
+"# Without it, finger errors out with \"Cannot stat /dev/host:0\".\n"
+"#\n"
+"#devname=`echo $DISPLAY | cut -c1-8`\n"
+"#if [ ! -d /dev/xdm ]; then\n"
+"#  mkdir /dev/xdm\n"
+"#  chmod 755 /dev/xdm\n"
+"#fi\n"
+"#touch /dev/xdm/$devname\n"
+"#chmod 644 /dev/xdm/$devname\n"
+"#exec sessreg -a -l xdm/$devname -h \"`echo $DISPLAY | cut -d: -f1`\""
+#else
+"#exec sessreg -a -l $DISPLAY -h \"`echo $DISPLAY | cut -d: -f1`\""
+# ifdef BSD
+" -x " KDMCONF "/Xservers"
+# endif
+#endif /* _AIX */
+" $USER\n"
+"\n# NOTE: The session is aborted if the last command returns non-zero.\n";
+
+static const char def_reset[] =
+"#! /bin/sh\n"
+"# Xreset - run as root after session exits\n"
+"\n"
+"# Reassign ownership of the console to root, this should disallow\n"
+"# assignment of console output to any random users's xterm. See Xstartup.\n"
+"#\n"
+"#chown root /dev/console\n"
+"#chmod 622 /dev/console\n"
+"\n"
+#ifdef _AIX
+"#devname=`echo $DISPLAY | cut -c1-8`\n"
+"#exec sessreg -d -l xdm/$devname -h \"`echo $DISPLAY | cut -d: -f1`\""
+#else
+"#exec sessreg -d -l $DISPLAY -h \"`echo $DISPLAY | cut -d: -f1`\""
+# ifdef BSD
+" -x " KDMCONF "/Xservers"
+# endif
+#endif /* _AIX */
+" $USER\n";
+
+static const char def_session1[] =
+"#! /bin/sh\n"
+"# Xsession - run as user\n"
+"\n"
+"session=$1\n"
+"\n"
+"# Note that the respective logout scripts are not sourced.\n"
+"case $SHELL in\n"
+"  */bash)\n"
+"    [ -z \"$BASH\" ] && exec $SHELL $0 \"$@\"\n"
+"    set +o posix\n"
+"    [ -f /etc/profile ] && . /etc/profile\n"
+"    if [ -f $HOME/.bash_profile ]; then\n"
+"      . $HOME/.bash_profile\n"
+"    elif [ -f $HOME/.bash_login ]; then\n"
+"      . $HOME/.bash_login\n"
+"    elif [ -f $HOME/.profile ]; then\n"
+"      . $HOME/.profile\n"
+"    fi\n"
+"    ;;\n"
+"  */zsh)\n"
+"    [ -z \"$ZSH_NAME\" ] && exec $SHELL $0 \"$@\"\n"
+"    emulate -R zsh\n"
+"    [ -d /etc/zsh ] && zdir=/etc/zsh || zdir=/etc\n"
+"    zhome=${ZDOTDIR:-$HOME}\n"
+"    # zshenv is always sourced automatically.\n"
+"    [ -f $zdir/zprofile ] && . $zdir/zprofile\n"
+"    [ -f $zhome/.zprofile ] && . $zhome/.zprofile\n"
+"    [ -f $zdir/zlogin ] && . $zdir/zlogin\n"
+"    [ -f $zhome/.zlogin ] && . $zhome/.zlogin\n"
+"    ;;\n"
+"  */csh|*/tcsh)\n"
+"    # [t]cshrc is always sourced automatically.\n"
+"    # Note that sourcing csh.login after .cshrc is non-standard.\n"
+"    xsess_tmp=";
+static const char def_session2[] =
+"\n"
+"    $SHELL -c \"if (-f /etc/csh.login) source /etc/csh.login; if (-f ~/.login) source ~/.login; /bin/sh -c export -p >! $xsess_tmp\"\n"
+"    . $xsess_tmp\n"
+"    rm -f $xsess_tmp\n"
+"    ;;\n"
+"  *) # Plain sh, ksh, and anything we do not know.\n"
+"    [ -f /etc/profile ] && . /etc/profile\n"
+"    [ -f $HOME/.profile ] && . $HOME/.profile\n"
+"    ;;\n"
+"esac\n"
+"\n"
+"[ -f /etc/xprofile ] && . /etc/xprofile\n"
+"[ -f $HOME/.xprofile ] && . $HOME/.xprofile\n"
+"\n"
+"case $session in\n"
+"  \"\")\n"
+"    exec xmessage -center -buttons OK:0 -default OK \"Sorry, $DESKTOP_SESSION is no valid session.\"\n"
+"    ;;\n"
+"  failsafe)\n"
+"    exec xterm -geometry 80x24-0-0\n"
+"    ;;\n"
+"  custom)\n"
+"    exec $HOME/.xsession\n"
+"    ;;\n"
+"  default)\n"
+"    exec " KDE_BINDIR "/startkde\n"
+"    ;;\n"
+"  *)\n"
+"    eval exec \"$session\"\n"
+"    ;;\n"
+"esac\n"
+"exec xmessage -center -buttons OK:0 -default OK \"Sorry, cannot execute $session. Check $DESKTOP_SESSION.desktop.\"\n";
+
+static const char def_background[] =
+"[Desktop0]\n"
+"BackgroundMode=Flat\n"
+"BlendBalance=100\n"
+"BlendMode=NoBlending\n"
+"ChangeInterval=60\n"
+"Color1=0,0,200\n"
+"Color2=192,192,192\n"
+"CurrentWallpaper=0\n"
+"LastChange=0\n"
+"MinOptimizationDepth=1\n"
+"MultiWallpaperMode=NoMulti\n"
+"Pattern=fish\n"
+"Program=\n"
+"ReverseBlending=false\n"
+"UseSHM=false\n"
+"Wallpaper=default_blue.jpg\n"
+"WallpaperList=\n"
+"WallpaperMode=Scaled\n";
+
+/* Create a copy of a file under KDMCONF and fill it */
+static void
+writeCopy( const char *fn, int mode, time_t stamp, const char *buf, size_t len )
+{
+	char *nname;
+	int fd;
+	struct utimbuf utim;
+
+	ASPrintf( &nname, "%s/%s", newdir, fn );
+	displace( nname );
+	mkpdirs( nname, "target" );
+	if ((fd = creat( nname, mode )) < 0) {
+		fprintf( stderr, "Cannot create %s\n", nname );
+		exit( 1 );
+	}
+	if (write( fd, buf, len ) != (ssize_t)len || close( fd ) < 0) {
+		fprintf( stderr, "Cannot write %s (disk full?)\n", nname );
+		unlink( nname );
+		exit( 1 );
+	}
+	if (stamp) {
+		utim.actime = utim.modtime = stamp;
+		utime( nname, &utim );
+	}
+	free( nname );
+}
+
+
+/* returns static array! */
+static const char *
+reSect( const char *sec, const char *name )
+{
+	static char sname[64];
+	char *p;
+
+	if ((p = strrchr( sec, '-' ))) {
+		sprintf( sname, "%.*s-%s", (int)(p - sec), sec, name );
+		return sname;
+	} else
+		return name;
+}
+
+static int
+inNewDir( const char *name )
+{
+	return !memcmp( name, KDMCONF "/", sizeof(KDMCONF) );
+}
+
+static const char *
+getMapping( StrMap *sm, const char *k )
+{
+	for (; sm; sm = sm->next)
+		if (!strcmp( sm->key, k ))
+			return sm->value;
+	return 0;
+}
+
+static void
+addMapping( StrMap **sm, const char *k, const char *v )
+{
+	for (; *sm; sm = &(*sm)->next)
+		if (!strcmp( (*sm)->key, k ))
+			return;
+	*sm = mcalloc( sizeof(**sm) );
+	ASPrintf( (char **)&(*sm)->key, "%s", k );
+	ASPrintf( (char **)&(*sm)->value, "%s", v );
+}
+
+static int
+inList( StrList *sp, const char *s )
+{
+	for (; sp; sp = sp->next)
+		if (!strcmp( sp->str, s ))
+			return True;
+	return False;
+}
+
+static void
+addStr( StrList **sp, const char *s )
+{
+	for (; *sp; sp = &(*sp)->next)
+		if (!strcmp( (*sp)->str, s ))
+			return;
+	*sp = mcalloc( sizeof(**sp) );
+	ASPrintf( (char **)&(*sp)->str, "%s", s );
+}
+
+static StrList *
+splitList( const char *str )
+{
+	StrList *sp, **spp = &sp;
+	const char *e;
+	if (!*str)
+		return 0;
+	for (;;) {
+		*spp = mcalloc( sizeof(**spp) );
+		if (!(e = strchr( str, ',' )))
+			break;
+		ASPrintf( (char **)&(*spp)->str, "%.*s", (int)(e - str), str );
+		str = e + 1;
+		spp = &(*spp)->next;
+	}
+	(*spp)->str = mstrdup( str );
+	(*spp)->next = 0;
+	return sp;
+}
+
+static char *
+joinList( StrList *sp )
+{
+	char *s = 0;
+	if (!sp)
+		return mstrdup( "" );
+	s = mstrdup( sp->str );
+	for (;;) {
+		sp = sp->next;
+		if (!sp)
+			return s;
+		strCat( &s, ",%s", sp->str );
+	}
+}
+
+StrMap *cfmap;
+StrList *aflist, *uflist, *eflist, *cflist, *lflist;
+
+/* file is part of new config */
+static void
+addedFile( const char *fn )
+{
+	addStr( &aflist, fn );
+}
+
+/* file from old config was parsed */
+static void
+usedFile( const char *fn )
+{
+	addStr( &uflist, fn );
+}
+
+/* file from old config was copied with slight modifications */
+static void
+editedFile( const char *fn )
+{
+	addStr( &eflist, fn );
+}
+
+/* file from old config was copied verbatim */
+static void
+copiedFile( const char *fn )
+{
+	addStr( &cflist, fn );
+}
+
+/* file from old config is still being used */
+static void
+linkedFile( const char *fn )
+{
+	addStr( &lflist, fn );
+}
+
+/*
+ * NOTE: This code will not correctly deal with default files colliding
+ * with pre-existing files. This should be OK, as for each class of files
+ * (scripts, configs) only one origin is used, and conflicts between classes
+ * are rather unlikely.
+ */
+
+/* Make a possibly modified copy of a file under KDMCONF */
+static int
+copyFile( Entry *ce, int mode, int (*proc)( File * ) )
+{
+	const char *tptr;
+	char *nname;
+	File file;
+	int rt;
+
+	if (!*ce->value)
+		return True;
+
+	if ((nname = (char *)getMapping( cfmap, ce->value ))) {
+		rt = inList( aflist, nname );
+		goto doret;
+	}
+	if (oldkde) {
+		int olen = strlen( oldkde );
+		if (!memcmp( ce->value, oldkde, olen )) {
+			if (!memcmp( ce->value + olen, "/kdm/", 5 )) {
+				tptr = ce->value + olen + 4;
+				goto gotn;
+			}
+			if (ce->value[olen] == '/') {
+				tptr = ce->value + olen;
+				goto gotn;
+			}
+		}
+	}
+	if (oldxdm) {
+		int olen = strlen( oldxdm );
+		if (!memcmp( ce->value, oldxdm, olen ) && ce->value[olen] == '/') {
+			tptr = ce->value + olen;
+			goto gotn;
+		}
+	}
+	if (!(tptr = strrchr( ce->value, '/' ))) {
+		fprintf( stderr, "Warning: cannot cope with relative path %s\n", ce->value );
+		return False;
+	}
+  gotn:
+	ASPrintf( &nname, KDMCONF "%s", tptr );
+	if (inList( aflist, nname )) {
+		int cnt = 1;
+		do {
+			free( nname );
+			ASPrintf( &nname, KDMCONF "%s-%d", tptr , ++cnt );
+		} while (inList( aflist, nname ));
+	}
+	addMapping( &cfmap, ce->value, nname );
+	if (!readFile( &file, ce->value )) {
+		fprintf( stderr, "Warning: cannot copy file %s\n", ce->value );
+		rt = False;
+	} else {
+		if (!proc || !proc( &file )) {
+			if (!use_destdir && !strcmp( ce->value, nname ))
+				linkedFile( nname );
+			else {
+				struct stat st;
+				stat( ce->value, &st );
+				writeCopy( nname + sizeof(KDMCONF), mode, st.st_mtime,
+				           file.buf, file.eof - file.buf );
+				copiedFile( ce->value );
+			}
+		} else {
+			writeCopy( nname + sizeof(KDMCONF), mode, 0,
+			           file.buf, file.eof - file.buf );
+			editedFile( ce->value );
+		}
+		if (strcmp( ce->value, nname ) && inNewDir( ce->value ) && !use_destdir)
+			displace( ce->value );
+		addedFile( nname );
+		rt = True;
+	}
+  doret:
+	ce->value = nname;
+	return rt;
+}
+
+static void
+doLinkFile( const char *name )
+{
+	File file;
+
+	if (inList( aflist, name ))
+		return;
+	if (!readFile( &file, name )) {
+		fprintf( stderr, "Warning: cannot read file %s\n", name );
+		return;
+	}
+	if (inNewDir( name ) && use_destdir) {
+		struct stat st;
+		stat( name, &st );
+		writeCopy( name + sizeof(KDMCONF), st.st_mode, st.st_mtime,
+		           file.buf, file.eof - file.buf );
+		copiedFile( name );
+	} else
+		linkedFile( name );
+	addedFile( name );
+}
+
+/* Incorporate an existing file */
+static void
+linkFile( Entry *ce )
+{
+	if (ce->written && *ce->value)
+		doLinkFile( ce->value );
+}
+
+/* Create a new file in KDMCONF and fill it */
+static void
+writeFile( const char *tname, int mode, const char *cont )
+{
+	FILE *f = createFile( tname + sizeof(KDMCONF), mode );
+	fputs_( cont, f );
+	fclose_( f );
+	addedFile( tname );
+}
+
+
+static void
+handleBgCfg( Entry *ce, Section *cs ATTR_UNUSED )
+{
+	if (!ce->active) /* can be only the X-*-Greeter one */
+		writeFile( def_BackgroundCfg, 0644, def_background );
+#if 0 /* risk of kcontrol clobbering the original file */
+	else if (old_confs)
+		linkFile( ce );
+#endif
+	else {
+		if (!copyFile( ce, 0644, 0 )) {
+			if (!strcmp( cs->name, "X-*-Greeter" ))
+				writeFile( def_BackgroundCfg, 0644, def_background );
+			ce->active = False;
+		}
+	}
+}
+
+
+#ifdef HAVE_VTS
+static char *
+memMem( char *mem, int lmem, const char *smem, int lsmem )
+{
+	for (; lmem >= lsmem; mem++, lmem--)
+		if (!memcmp( mem, smem, lsmem ))
+			return mem + lsmem;
+	return 0;
+}
+
+static int maxTTY, TTYmask;
+
+static void
+getInitTab( void )
+{
+	File it;
+	char *p, *eol, *ep;
+	int tty;
+
+	if (maxTTY)
+		return;
+	if (readFile( &it, "/etc/inittab" )) {
+		usedFile( "/etc/inittab" );
+		for (p = it.buf; p < it.eof; p = eol + 1) {
+			for (eol = p; eol < it.eof && *eol != '\n'; eol++);
+			if (*p != '#') {
+				if ((ep = memMem( p, eol - p, " tty", 4 )) &&
+				    ep < eol && isdigit( *ep ))
+				{
+					if (ep + 1 == eol || isspace( *(ep + 1) ))
+						tty = *ep - '0';
+					else if (isdigit( *(ep + 1) ) &&
+					         (ep + 2 == eol || isspace( *(ep + 2) )))
+						tty = (*ep - '0') * 10 + (*(ep + 1) - '0');
+					else
+						continue;
+					TTYmask |= 1 << (tty - 1);
+					if (tty > maxTTY)
+						maxTTY = tty;
+				}
+			}
+		}
+		freeBuf( &it );
+	}
+	if (!maxTTY) {
+		maxTTY = 6;
+		TTYmask = 0x3f;
+	}
+}
+#endif
+
+
+/* TODO: handle solaris' local_uid specs */
+
+static char *
+readWord( File *file, int EOFatEOL )
+{
+	char *wordp, *wordBuffer;
+	int quoted;
+	char c;
+
+  rest:
+	wordp = wordBuffer = file->cur;
+  mloop:
+	quoted = False;
+  qloop:
+	if (file->cur == file->eof) {
+	  doeow:
+		if (wordp == wordBuffer)
+			return 0;
+	  retw:
+		*wordp = '\0';
+		return wordBuffer;
+	}
+	c = *file->cur++;
+	switch (c) {
+	case '#':
+		if (quoted)
+			break;
+		do {
+			if (file->cur == file->eof)
+				goto doeow;
+			c = *file->cur++;
+		} while (c != '\n');
+	case '\0':
+	case '\n':
+		if (EOFatEOL && !quoted) {
+			file->cur--;
+			goto doeow;
+		}
+		if (wordp != wordBuffer) {
+			file->cur--;
+			goto retw;
+		}
+		goto rest;
+	case ' ':
+	case '\t':
+		if (wordp != wordBuffer)
+			goto retw;
+		goto rest;
+	case '\\':
+		if (!quoted) {
+			quoted = True;
+			goto qloop;
+		}
+		break;
+	}
+	*wordp++ = c;
+	goto mloop;
+}
+
+/* backslashes are double-escaped - first parseArgs, then KConfig */
+
+static StrList *
+splitArgs( const char *string )
+{
+	const char *word;
+	char *str;
+	int wlen;
+	StrList *args, **argp = &args;
+
+	while (*string) {
+		if (isspace( *string )) {
+			string++;
+			continue;
+		}
+		word = string;
+		wlen = 0;
+		do {
+			if (*string == '\\') {
+				if (*++string != '\\')
+					string--;
+				if (*++string != '\\')
+					string--;
+				if (!*++string)
+					string--;
+				wlen++;
+			} else if (*string == '\'') {
+				while (*++string != '\'' && *string) {
+					if (*string == '\\' && *++string != '\\')
+						string--;
+					wlen++;
+				}
+			} else if (*string == '"') {
+				while (*++string != '"' && *string) {
+					if (*string == '\\') {
+						if (*++string != '\\')
+							string--;
+						if (*++string != '\\')
+							string--;
+						if (!*++string)
+							string--;
+					}
+					wlen++;
+				}
+			} else
+				wlen++;
+		} while (*++string && !isspace( *string ));
+		*argp = mmalloc( sizeof(**argp) );
+		(*argp)->str = str = mmalloc( wlen + 1 );
+		do {
+			if (*word == '\\') {
+				if (*++word != '\\')
+					word--;
+				if (*++word != '\\')
+					word--;
+				if (!*++word)
+					word--;
+				*str++ = *word;
+			} else if (*word == '\'') {
+				while (*++word != '\'' && *word) {
+					if (*word == '\\' && *++word != '\\')
+						word--;
+					*str++ = *word;
+				}
+			} else if (*word == '"') {
+				while (*++word != '"' && *word) {
+					if (*word == '\\') {
+						if (*++word != '\\')
+							word--;
+						if (*++word != '\\')
+							word--;
+						if (!*++word)
+							word--;
+					}
+					*str++ = *word;
+				}
+			} else
+				*str++ = *word;
+		} while (*++word && !isspace( *word ));
+		*str = 0;
+		argp = &(*argp)->next;
+	}
+	*argp = 0;
+	return args;
+}
+
+static const char *
+joinArgs( StrList *argv )
+{
+	StrList *av;
+	const char *s, *rs;
+	char *str;
+	int slen;
+
+	if (!argv)
+		return "";
+	for (slen = 0, av = argv; slen++, av; av = av->next) {
+		int nq = 0;
+		for (s = av->str; *s; s++, slen++)
+			if (isspace( *s ) || *s == '\'')
+				nq = 2;
+			else if (*s == '"')
+				slen += 2;
+			else if (*s == '\\')
+				slen += 3;
+		slen += nq;
+	}
+	rs = str = mmalloc( slen );
+	for (av = argv; av; av = av->next) {
+		int nq = 0;
+		for (s = av->str; *s; s++)
+			if (isspace( *s ) || *s == '\'')
+				nq = 2;
+		if (av != argv)
+			*str++ = ' ';
+		if (nq)
+			*str++ = '"';
+		for (s = av->str; *s; s++) {
+			if (*s == '\\')
+				*str++ = '\\';
+			if (*s == '"' || *s == '\\') {
+				*str++ = '\\';
+				*str++ = '\\';
+			}
+			*str++ = *s;
+		}
+		if (nq)
+			*str++ = '"';
+	}
+	*str = 0;
+	return rs;
+}
+
+static struct displayMatch {
+	const char *name;
+	int len, local;
+} displayTypes[] = {
+	{ "local", 5, True },
+	{ "foreign", 7, False },
+};
+
+static int
+parseDisplayType( const char *string, const char **atPos )
+{
+	struct displayMatch *d;
+
+	*atPos = 0;
+	for (d = displayTypes; d < displayTypes + as(displayTypes); d++) {
+		if (!memcmp( d->name, string, d->len ) &&
+		    (!string[d->len] || string[d->len] == '@'))
+		{
+			if (string[d->len] == '@' && string[d->len + 1])
+				*atPos = string + d->len + 1;
+			return d->local;
+		}
+	}
+	return -1;
+}
+
+typedef struct serverEntry {
+	struct serverEntry *next;
+	const char *name, *class2, *console, *argvs, *arglvs;
+	StrList *argv, *arglv;
+	int local, reserve, vt;
+} ServerEntry;
+
+static void
+absorbXservers( const char *sect ATTR_UNUSED, char **value )
+{
+	ServerEntry *se, *se1, *serverList, **serverPtr;
+	const char *word, *word2;
+	char *sdpys, *rdpys;
+	StrList **argp, **arglp, *ap, *ap2;
+	File file;
+	int nldpys = 0, nrdpys = 0, dpymask = 0;
+	int cpcmd, cpcmdl;
+#ifdef HAVE_VTS
+	int dn, cpvt, mtty;
+#endif
+
+	if (**value == '/') {
+		if (!readFile( &file, *value ))
+			return;
+		usedFile( *value );
+	} else {
+		file.buf = *value;
+		file.eof = *value + strlen( *value );
+	}
+	file.cur = file.buf;
+
+	serverPtr = &serverList;
+#ifdef HAVE_VTS
+  bustd:
+#endif
+	while ((word = readWord( &file, 0 ))) {
+		se = mcalloc( sizeof(*se) );
+		se->name = word;
+		if (!(word = readWord( &file, 1 )))
+			continue;
+		se->local = parseDisplayType( word, &se->console );
+		if (se->local < 0) {
+			se->class2 = word;
+			if (!(word = readWord( &file, 1 )))
+				continue;
+			se->local = parseDisplayType( word, &se->console );
+			if (se->local < 0) {
+				while (readWord( &file, 1 ));
+				continue;
+			}
+		}
+		word = readWord( &file, 1 );
+		if (word && !strcmp( word, "reserve" )) {
+			se->reserve = True;
+			word = readWord( &file, 1 );
+		}
+		if (se->local != (word != 0))
+			continue;
+		argp = &se->argv;
+		arglp = &se->arglv;
+		while (word) {
+#ifdef HAVE_VTS
+			if (word[0] == 'v' && word[1] == 't')
+				se->vt = atoi( word + 2 );
+			else if (!strcmp( word, "-crt" )) { /* SCO style */
+				if (!(word = readWord( &file, 1 )) ||
+				    memcmp( word, "/dev/tty", 8 ))
+					goto bustd;
+				se->vt = atoi( word + 8 );
+			} else
+#endif
+			if (strcmp( word, se->name )) {
+				ap = mmalloc( sizeof(*ap) );
+				ap->str = word;
+				if (!strcmp( word, "-nolisten" )) {
+					if (!(word2 = readWord( &file, 1 )))
+						break;
+					ap2 = mmalloc( sizeof(*ap2) );
+					ap2->str = word2;
+					ap->next = ap2;
+					if (!strcmp( word2, "unix" )) {
+						*argp = ap;
+						argp = &ap2->next;
+					} else {
+						*arglp = ap;
+						arglp = &ap2->next;
+					}
+				} else {
+					*argp = ap;
+					argp = &ap->next;
+				}
+			}
+			word = readWord( &file, 1 );
+		}
+		*argp = *arglp = 0;
+		if (se->local) {
+			nldpys++;
+			dpymask |= 1 << atoi( se->name + 1 );
+			if (se->reserve)
+				nrdpys++;
+		}
+		*serverPtr = se;
+		serverPtr = &se->next;
+	}
+	*serverPtr = 0;
+
+#ifdef HAVE_VTS
+	/* don't copy only if all local displays are ordered and have a vt */
+	cpvt = False;
+	getInitTab();
+	for (se = serverList, mtty = maxTTY; se; se = se->next)
+		if (se->local) {
+			mtty++;
+			if (se->vt != mtty) {
+				cpvt = True;
+				break;
+			}
+		}
+#endif
+
+	for (se = serverList; se; se = se->next) {
+		se->argvs = joinArgs( se->argv );
+		se->arglvs = joinArgs( se->arglv );
+	}
+
+	se1 = 0, cpcmd = cpcmdl = False;
+	for (se = serverList; se; se = se->next)
+		if (se->local) {
+			if (!se1)
+				se1 = se;
+			else {
+				if (strcmp( se1->argvs, se->argvs ))
+					cpcmd = True;
+				if (strcmp( se1->arglvs, se->arglvs ))
+					cpcmdl = True;
+			}
+		}
+	if (se1) {
+		putFqVal( "X-:*-Core", "ServerCmd", se1->argvs );
+		putFqVal( "X-:*-Core", "ServerArgsLocal", se1->arglvs );
+		for (se = serverList; se; se = se->next)
+			if (se->local) {
+				char sec[32];
+				sprintf( sec, "X-%s-Core", se->name );
+				if (cpcmd)
+					putFqVal( sec, "ServerCmd", se->argvs );
+				if (cpcmdl)
+					putFqVal( sec, "ServerArgsLocal", se->arglvs );
+#ifdef HAVE_VTS
+				if (cpvt && se->vt) {
+					char vt[8];
+					sprintf( vt, "%d", se->vt );
+					putFqVal( sec, "ServerVT", vt );
+				}
+#else
+				if (se->console)
+					putFqVal( sec, "ServerTTY", se->console );
+#endif
+			}
+	}
+
+	sdpys = rdpys = 0;
+	for (se = serverList; se; se = se->next)
+		strCat( se->reserve ? &rdpys : &sdpys,
+		        se->class2 ? ",%s_%s" : ",%s", se->name, se->class2 );
+
+#ifdef HAVE_VTS
+	/* add reserve dpys */
+	if (nldpys < 4 && nldpys && !nrdpys)
+		for (; nldpys < 4; nldpys++) {
+			for (dn = 0; dpymask & (1 << dn); dn++);
+			dpymask |= (1 << dn);
+			strCat( &rdpys, ",:%d", dn );
+		}
+#endif
+
+	putFqVal( "General", "StaticServers", sdpys ? sdpys + 1 : "" );
+	putFqVal( "General", "ReserveServers", rdpys ? rdpys + 1 : "" );
+
+	if (**value == '/' && inNewDir( *value ) && !use_destdir)
+		displace( *value );
+}
+
+#ifdef HAVE_VTS
+static void
+upd_servervts( Entry *ce, Section *cs ATTR_UNUSED )
+{
+	if (!ce->active) { /* there is only the Global one */
+#ifdef __linux__ /* XXX actually, sysvinit */
+		getInitTab();
+		ASPrintf( (char **)&ce->value, "-%d", maxTTY + 1 );
+		ce->active = ce->written = True;
+#endif
+	}
+}
+
+static void
+upd_consolettys( Entry *ce, Section *cs ATTR_UNUSED )
+{
+	if (!ce->active) { /* there is only the Global one */
+#ifdef __linux__ /* XXX actually, sysvinit */
+		char *buf;
+		int i;
+
+		getInitTab();
+		for (i = 0, buf = 0; i < 16; i++)
+			if (TTYmask & (1 << i))
+				strCat( &buf, ",tty%d", i + 1 );
+		if (buf) {
+			ce->value = buf + 1;
+			ce->active = ce->written = True;
+		}
+#endif
+	}
+}
+#endif
+
+static void
+upd_servercmd( Entry *ce, Section *cs ATTR_UNUSED )
+{
+	StrList *sa;
+	FILE *fp;
+	char *svr;
+	char buf[20000];
+
+	if (!ce->active || oldver >= 0x0204)
+		return;
+	if (!(sa = splitArgs( ce->value )))
+		return;
+	ASPrintf( &svr, "%s -help 2>&1", sa->str );
+	if (!(fp = popen( svr, "r" )))
+		return;
+	buf[fread( buf, 1, sizeof(buf) - 1, fp )] = 0;
+	pclose( fp );
+	if (strstr( buf, "\n-br " ))
+		addStr( &sa, "-br" );
+	if (strstr( buf, "\n-novtswitch " ))
+		addStr( &sa, "-novtswitch" );
+	if (strstr( buf, "\n-quiet " ))
+		addStr( &sa, "-quiet" );
+	ce->value = joinArgs( sa );
+	ce->written = True;
+}
+
+#ifdef XDMCP
+static void
+cp_keyfile( Entry *ce, Section *cs ATTR_UNUSED )
+{
+	if (!ce->active) /* there is only the Global one */
+		return;
+	if (old_confs)
+		linkFile( ce );
+	else
+		if (!copyFile( ce, 0600, 0 ))
+			ce->active = False;
+}
+
+static void
+mk_xaccess( Entry *ce, Section *cs ATTR_UNUSED )
+{
+	if (!ce->active) /* there is only the Global one */
+		writeFile( def_Xaccess, 0644, def_xaccess );
+	else if (old_confs)
+		linkFile( ce );
+	else
+		copyFile( ce, 0644, 0 ); /* don't handle error, it will disable Xdmcp automatically */
+}
+
+static void
+mk_willing( Entry *ce, Section *cs ATTR_UNUSED )
+{
+	const char *fname;
+
+	if (!ce->active) /* there is only the Global one */
+		goto dflt;
+	else {
+		if (!(fname = strchr( ce->value, '/' )))
+			return; /* obviously in-line (or empty) */
+		if (old_scripts || inNewDir( fname ))
+			doLinkFile( fname );
+		else {
+		  dflt:
+			ce->value = KDMCONF "/Xwilling";
+			ce->active = ce->written = True;
+			writeFile( ce->value, 0755, def_willing );
+		}
+	}
+}
+#endif
+
+/*
+static int
+edit_resources( File *file )
+{
+	// XXX remove any login*, chooser*, ... resources
+	return False;
+}
+*/
+
+static void
+cp_resources( Entry *ce, Section *cs ATTR_UNUSED )
+{
+	if (!ce->active) /* the X-*-Greeter one */
+		return;
+	if (old_confs)
+		linkFile( ce );
+	else
+		if (!copyFile( ce, 0644, 0/*edit_resources*/ ))
+			ce->active = False;
+}
+
+static int
+delstr( File *fil, const char *pat )
+{
+	char *p, *pp, *bpp;
+	const char *pap, *paap;
+
+	*fil->eof = 0;
+	for (p = fil->buf; *p; p++) {
+		for (pp = p, pap = pat; ; ) {
+			if (!*pap) {
+				*p = '\n';
+				memcpy( p + 1, pp, fil->eof - pp + 1 );
+				fil->eof -= pp - p - 1;
+				return True;
+			} else if (!memcmp( pap, "*/", 2 )) {
+				paap = pap += 2;
+				while (!isspace( *pap ))
+					pap++;
+				if (*pp != '/')
+					break;
+				for (;;)
+					for (bpp = ++pp; *pp != '/'; pp++)
+						if (!*pp || isspace( *pp ))
+							goto wbrk;
+			  wbrk:
+				if ((pp - bpp != pap - paap) || memcmp( bpp, paap, pap - paap ))
+					break;
+			} else if (*pap == '\t') {
+				pap++;
+				while (*pp == ' ' || *pp == '\t')
+					pp++;
+			} else if (*pap == '[') {
+				pap++;
+				for (;;) {
+					if (!*pap) {
+						fprintf( stderr, "Internal error: unterminated char set\n" );
+						exit( 1 );
+					}
+					if (*pap == *pp) {
+						while (*++pap != ']')
+							if (!*pap) {
+								fprintf( stderr, "Internal error: unterminated char set\n" );
+								exit( 1 );
+							}
+						pap++;
+						pp++;
+						break;
+					}
+					if (*++pap == ']')
+						goto no;
+				}
+			} else {
+				if (*pap == '\n')
+					while (*pp == ' ' || *pp == '\t')
+						pp++;
+				if (*pap != *pp)
+					break;
+				pap++;
+				pp++;
+			}
+		}
+	  no: ;
+	}
+	return False;
+}
+
+/* XXX
+   the UseBackground voodoo will horribly fail, if multiple sections link
+   to the same Xsetup file
+*/
+
+static int mod_usebg;
+
+static int
+edit_setup( File *file )
+{
+	int chg =
+		delstr( file, "\n"
+		        "(\n"
+		        "  PIDFILE=/var/run/kdmdesktop-$DISPLAY.pid\n"
+		        "  */kdmdesktop\t&\n"
+		        "  echo $! >$PIDFILE\n"
+		        "  wait $!\n"
+		        "  rm $PIDFILE\n"
+		        ")\t&\n" ) |
+		delstr( file, "\n"
+		        "*/kdmdesktop\t&\n" ) |
+		delstr( file, "\n"
+		        "kdmdesktop\t&\n" ) |
+		delstr( file, "\n"
+		        "kdmdesktop\n" );
+	putVal( "UseBackground", chg ? "true" : "false" );
+	return chg;
+}
+
+static void
+mk_setup( Entry *ce, Section *cs )
+{
+	setSect( reSect( cs->name, "Greeter" ) );
+	if (old_scripts || mixed_scripts) {
+		if (mod_usebg && *ce->value)
+			putVal( "UseBackground", "false" );
+		linkFile( ce );
+	} else {
+		if (ce->active && inNewDir( ce->value )) {
+			if (mod_usebg)
+				copyFile( ce, 0755, edit_setup );
+			else
+				linkFile( ce );
+		} else {
+			ce->value = KDMCONF "/Xsetup";
+			ce->active = ce->written = True;
+			writeFile( ce->value, 0755, def_setup );
+		}
+	}
+}
+
+static int
+edit_startup( File *file )
+{
+	int chg1 = False, chg2 = False;
+
+	if (mod_usebg &&
+	    (delstr( file, "\n"
+	             "PIDFILE=/var/run/kdmdesktop-$DISPLAY.pid\n"
+	             "if [[] -f $PIDFILE ] ; then\n"
+	             "	   kill `cat $PIDFILE`\n"
+	             "fi\n" ) ||
+	     delstr( file, "\n"
+	             "PIDFILE=/var/run/kdmdesktop-$DISPLAY.pid\n"
+	             "test -f $PIDFILE && kill `cat $PIDFILE`\n" )))
+		chg1 = True;
+	if (oldver < 0x0203) {
+		chg2 =
+#ifdef _AIX
+			delstr( file, "\n"
+"# We create a pseudodevice for finger.  (host:0 becomes [kx]dm/host_0)\n" );
+"# Without it, finger errors out with \"Cannot stat /dev/host:0\".\n"
+"#\n"
+"if [[] -f /usr/lib/X11/xdm/sessreg ]; then\n"
+"  devname=`echo $DISPLAY | /usr/bin/sed -e 's/[[]:\\.]/_/g' | /usr/bin/cut -c1-8`\n"
+"  hostname=`echo $DISPLAY | /usr/bin/cut -d':' -f1`\n"
+"\n"
+"  if [[] -z \"$devname\" ]; then\n"
+"    devname=\"unknown\"\n"
+"  fi\n"
+"  if [[] ! -d /dev/[kx]dm ]; then\n"
+"    /usr/bin/mkdir /dev/[kx]dm\n"
+"    /usr/bin/chmod 755 /dev/[kx]dm\n"
+"  fi\n"
+"  /usr/bin/touch /dev/[kx]dm/$devname\n"
+"  /usr/bin/chmod 644 /dev/[kx]dm/$devname\n"
+"\n"
+"  if [[] -z \"$hostname\" ]; then\n"
+"    exec /usr/lib/X11/xdm/sessreg -a -l [kx]dm/$devname $USER\n"
+"  else\n"
+"    exec /usr/lib/X11/xdm/sessreg -a -l [kx]dm/$devname -h $hostname $USER\n"
+"  fi\n"
+"fi\n") |
+#else
+# ifdef BSD
+			delstr( file, "\n"
+"exec sessreg -a -l $DISPLAY -x */Xservers -u " _PATH_UTMP " $USER\n" ) |
+# endif
+#endif /* _AIX */
+			delstr( file, "\n"
+"exec sessreg -a -l $DISPLAY"
+#ifdef BSD
+" -x */Xservers"
+#endif
+" $USER\n" ) |
+			delstr( file, "\n"
+"exec sessreg -a -l $DISPLAY -u /var/run/utmp -x */Xservers $USER\n" );
+		putVal( "UseSessReg", chg2 ? "true" : "false" );
+	}
+	return chg1 | chg2;
+}
+
+static void
+mk_startup( Entry *ce, Section *cs )
+{
+	setSect( cs->name );
+	if (old_scripts || mixed_scripts)
+		linkFile( ce );
+	else {
+		if (ce->active && inNewDir( ce->value )) {
+			if (mod_usebg || oldver < 0x0203)
+				copyFile( ce, 0755, edit_startup );
+			else
+				linkFile( ce );
+		} else {
+			ce->value = KDMCONF "/Xstartup";
+			ce->active = ce->written = True;
+			writeFile( ce->value, 0755, def_startup );
+		}
+	}
+}
+
+static int
+edit_reset( File *file )
+{
+	return
+#ifdef _AIX
+		delstr( file, "\n"
+"if [[] -f /usr/lib/X11/xdm/sessreg ]; then\n"
+"  devname=`echo $DISPLAY | /usr/bin/sed -e 's/[[]:\\.]/_/g' | /usr/bin/cut -c1-8`\n"
+"  exec /usr/lib/X11/xdm/sessreg -d -l [kx]dm/$devname $USER\n"
+"fi\n" ) |
+#else
+# ifdef BSD
+		delstr( file, "\n"
+"exec sessreg -d -l $DISPLAY -x */Xservers -u " _PATH_UTMP " $USER\n" ) |
+# endif
+#endif /* _AIX */
+		delstr( file, "\n"
+"exec sessreg -d -l $DISPLAY"
+# ifdef BSD
+" -x */Xservers"
+# endif
+" $USER\n" ) |
+		delstr( file, "\n"
+"exec sessreg -d -l $DISPLAY -u /var/run/utmp -x */Xservers $USER\n" );
+}
+
+static void
+mk_reset( Entry *ce, Section *cs ATTR_UNUSED )
+{
+	if (old_scripts || mixed_scripts)
+		linkFile( ce );
+	else {
+		if (ce->active && inNewDir( ce->value )) {
+			if (oldver < 0x0203)
+				copyFile( ce, 0755, edit_reset );
+			else
+				linkFile( ce );
+		} else {
+			ce->value = KDMCONF "/Xreset";
+			ce->active = ce->written = True;
+			writeFile( ce->value, 0755, def_reset );
+		}
+	}
+}
+
+static void
+mk_session( Entry *ce, Section *cs ATTR_UNUSED )
+{
+	char *def_session;
+	const char *tmpf;
+
+	if ((old_scripts || (ce->active && inNewDir( ce->value ))) &&
+	    oldver >= 0x202)
+		linkFile( ce );
+	else {
+		tmpf = locate( "mktemp" ) ?
+		           "`mktemp /tmp/xsess-env-XXXXXX`" :
+		           locate( "tempfile" ) ?
+		               "`tempfile`" :
+		               "$HOME/.xsession-env-$DISPLAY";
+		ASPrintf( &def_session, "%s%s%s", def_session1, tmpf, def_session2 );
+		ce->value = KDMCONF "/Xsession";
+		ce->active = ce->written = True;
+		writeFile( ce->value, 0755, def_session );
+	}
+}
+
+static void
+upd_language( Entry *ce, Section *cs ATTR_UNUSED )
+{
+	if (!strcmp( ce->value, "C" ))
+		ce->value = (char *)"en_US";
+}
+
+static void
+upd_guistyle( Entry *ce, Section *cs ATTR_UNUSED )
+{
+	if (!strcmp( ce->value, "Motif+" ))
+		ce->value = (char *)"MotifPlus";
+	else if (!strcmp( ce->value, "KDE" ))
+		ce->value = (char *)"Default";
+}
+
+static void
+upd_showusers( Entry *ce, Section *cs )
+{
+	if (!strcmp( ce->value, "All" ))
+		ce->value = (char *)"NotHidden";
+	else if (!strcmp( ce->value, "None" )) {
+		if (ce->active)
+			putFqVal( cs->name, "UserList", "false" );
+		ce->value = (char *)"Selected";
+		ce->active = False;
+		ce->written = True;
+	}
+}
+
+static const char *defminuid, *defmaxuid;
+
+static void
+upd_minshowuid( Entry *ce, Section *cs ATTR_UNUSED )
+{
+	if (!ce->active) {
+		ce->value = defminuid;
+		ce->active = ce->written = True;
+	}
+}
+
+static void
+upd_maxshowuid( Entry *ce, Section *cs ATTR_UNUSED )
+{
+	if (!ce->active) {
+		ce->value = defmaxuid;
+		ce->active = ce->written = True;
+	}
+}
+
+static void
+upd_hiddenusers( Entry *ce, Section *cs ATTR_UNUSED )
+{
+	char *nv;
+	const char *msu, *pt, *et;
+	struct passwd *pw;
+	unsigned minuid, maxuid;
+	char nbuf[128];
+
+	if (!ce->active)
+		return;
+
+	msu = getFqVal( cs->name, "MinShowUID", "0" );
+	sscanf( msu, "%u", &minuid );
+	msu = getFqVal( cs->name, "MaxShowUID", "65535" );
+	sscanf( msu, "%u", &maxuid );
+
+	nv = 0;
+	pt = ce->value;
+	for (;;) {
+		et = strpbrk( pt, ";," );
+		if (et) {
+			memcpy( nbuf, pt, et - pt );
+			nbuf[et - pt] = 0;
+		} else
+			strcpy( nbuf, pt );
+		if ((pw = getpwnam( nbuf ))) {
+			if (!pw->pw_uid ||
+			    (pw->pw_uid >= minuid && pw->pw_uid <= maxuid))
+			{
+				if (nv)
+					strCat( &nv, ",%s", nbuf );
+				else
+					nv = mstrdup( nbuf );
+			}
+		}
+		if (!et)
+			break;
+		pt = et + 1;
+	}
+	ce->value = nv ? nv : "";
+}
+
+static void
+upd_forgingseed( Entry *ce, Section *cs ATTR_UNUSED )
+{
+	if (!ce->active) {
+		ASPrintf( (char **)&ce->value, "%d", time( 0 ) );
+		ce->active = ce->written = True;
+	}
+}
+
+static void
+upd_fifodir( Entry *ce, Section *cs ATTR_UNUSED )
+{
+	const char *dir;
+	struct stat st;
+
+	if (use_destdir)
+		return;
+	dir = ce->active ? ce->value : def_FifoDir;
+	stat( dir, &st );
+	chmod( dir, st.st_mode | 0755 );
+}
+
+static void
+upd_datadir( Entry *ce, Section *cs ATTR_UNUSED )
+{
+	char *oldsts, *newsts;
+	const char *dir;
+
+	if (use_destdir)
+		return;
+	dir = ce->active ? ce->value : def_DataDir;
+	if (mkdirp( dir, 0755, "data", 0 ) && oldkde) {
+		ASPrintf( &oldsts, "%s/kdm/kdmsts", oldkde );
+		ASPrintf( &newsts, "%s/kdmsts", dir );
+		rename( oldsts, newsts );
+	}
+}
+
+static void
+upd_userlogfile( Entry *ce, Section *cs ATTR_UNUSED )
+{
+	char *p;
+
+	if ((p = strstr( ce->value, "%s" )))
+		ASPrintf( (char **)&ce->value, "%.*s%%d%s", p - ce->value, ce->value, p + 2 );
+}
+
+/*
+ * Copy single file.
+ * Do not overwrite existing target.
+ * Do not complain if source cannot be read.
+ */
+static void
+copyPlainFile( const char *from, const char *to )
+{
+	File file;
+	int fd;
+
+	if (readFile( &file, from )) {
+		if ((fd = open( to, O_WRONLY | O_CREAT | O_EXCL, 0644 )) >= 0) {
+			size_t len = file.eof - file.buf;
+			if (write( fd, file.buf, len ) != (ssize_t)len) {
+				fprintf( stderr, "Warning: cannot write %s (disk full?)\n", to );
+				unlink( to );
+			}
+			if (close( fd ) < 0) {
+				fprintf( stderr, "Warning: cannot write %s (disk full?)\n", to );
+				unlink( to );
+			}
+		} else if (errno != EEXIST)
+			fprintf( stderr, "Warning: cannot create %s\n", to );
+		freeBuf( &file );
+	}
+}
+
+static int
+copyDir( const char *from, const char *to )
+{
+	DIR *dir;
+	struct dirent *ent;
+	struct stat st;
+	char bn[PATH_MAX], bo[PATH_MAX];
+
+	if (!(dir = opendir( from )))
+		return False;
+	while ((ent = readdir( dir ))) {
+		if (!strcmp( ent->d_name, "." ) || !strcmp( ent->d_name, ".." ))
+			continue;
+		sprintf( bo, "%s/%s", from, ent->d_name );
+		if (stat( bo, &st ) || !S_ISREG( st.st_mode ))
+			continue;
+		sprintf( bn, "%s/%s", to, ent->d_name );
+		copyPlainFile( bo, bn );
+	}
+	closedir( dir );
+	return True;
+}
+
+static void
+upd_facedir( Entry *ce, Section *cs ATTR_UNUSED )
+{
+	char *oldpic, *newpic, *olddir;
+	struct passwd *pw;
+
+	if (use_destdir)
+		return;
+	if (oldkdepfx) { /* Do we have a previous install? */
+		/* This would be the prev install's default location */
+		ASPrintf( &olddir, "%s/share/apps/kdm/faces", oldkdepfx );
+		if (ce->active && strcmp( olddir, ce->value ))
+			/* Not default location, so don't touch the setting. */
+			return;
+		/* Default location, so absorb it. */
+		ce->active = False;
+		/* Don't copy if old dir == new new. */
+		if (!strcmp( olddir, def_FaceDir ))
+			olddir = 0;
+	} else
+		olddir = 0;
+	if (mkdirp( def_FaceDir, 0755, "user face", True )) {
+		const char *defpic = def_FaceDir "/.default.face.icon";
+		const char *rootpic = def_FaceDir "/root.face.icon";
+		if (oldkde && (!olddir || !copyDir( olddir, def_FaceDir )) &&
+		    oldver < 0x0201) /* This isn't exact - didn't inc version. */
+		{
+			setpwent();
+			while ((pw = getpwent()))
+				if (strcmp( pw->pw_name, "root" )) {
+					ASPrintf( &oldpic, "%s/share/apps/kdm/pics/users/%s.png",
+					          oldkdepfx, pw->pw_name );
+					ASPrintf( &newpic, def_FaceDir "/%s.face.icon", pw->pw_name );
+					rename( oldpic, newpic );
+					free( newpic );
+					free( oldpic );
+				}
+			endpwent();
+			ASPrintf( &oldpic, "%s/share/apps/kdm/pics/users/default.png", oldkdepfx );
+			if (!rename( oldpic, defpic ))
+				defpic = 0;
+			ASPrintf( &oldpic, "%s/share/apps/kdm/pics/users/root.png", oldkdepfx );
+			if (!rename( oldpic, rootpic ))
+				rootpic = 0;
+		}
+		if (defpic) {
+			ASPrintf( &oldpic, "%s/default1.png", facesrc );
+			copyPlainFile( oldpic, defpic );
+		}
+		if (rootpic) {
+			ASPrintf( &oldpic, "%s/root1.png", facesrc );
+			copyPlainFile( oldpic, rootpic );
+		}
+	}
+}
+
+static void
+upd_sessionsdirs( Entry *ce, Section *cs ATTR_UNUSED )
+{
+	StrList *sl, *sp;
+	int olen;
+	char olddir[PATH_MAX];
+
+	if (ce->written) {
+		sprintf( olddir, "%s/share/apps/kdm/sessions", oldkdepfx );
+		olen = strlen( oldkde );
+		sl = splitList( ce->value );
+		for (sp = sl; sp; sp = sp->next) {
+			if (!strcmp( sp->str, olddir ))
+				sp->str = def_SessionsDirs;
+			else if (!memcmp( sp->str, oldkde, olen ) &&
+			         !memcmp( sp->str + olen, "/kdm/", 5 ))
+			{
+				char nd[PATH_MAX];
+				sprintf( nd, "%s%s", newdir, sp->str + olen + 4 );
+				mkdirp( nd, 0755, "sessions", False );
+				copyDir( sp->str, nd );
+				ASPrintf( (char **)&sp->str, KDMCONF "%s", sp->str + olen + 4 );
+			}
+		}
+		ce->value = joinList( sl );
+	} else {
+		char nd[PATH_MAX];
+		sprintf( nd, "%s/sessions", newdir );
+		mkdirp( nd, 0755, "sessions", False );
+	}
+}
+
+static void
+upd_preloader( Entry *ce, Section *cs ATTR_UNUSED )
+{
+	if (ce->written) { /* implies oldkde != 0 */
+		char *oldpl;
+		ASPrintf( &oldpl, "%s/bin/preloadkde", oldkdepfx );
+		if (!strcmp( ce->value, oldpl ))
+			ce->value = (char *)KDE_BINDIR "/preloadkde";
+		free( oldpl );
+	}
+}
+
+
+CONF_GEN_ENTRIES
+
+static Sect *
+findSect( const char *name )
+{
+	const char *p;
+	int i;
+
+	p = strrchr( name, '-' );
+	if (!p)
+		p = name;
+	for (i = 0; i < as(allSects); i++)
+		if (!strcmp( allSects[i]->name, p ))
+			return allSects[i];
+	fprintf( stderr, "Internal error: unknown section %s\n", name );
+	exit( 1 );
+}
+
+static Ent *
+findEnt( Sect *sect, const char *key )
+{
+	int i;
+
+	for (i = 0; i < sect->nents; i++)
+		if (!strcmp( sect->ents[i].key, key ))
+			return sect->ents + i;
+	fprintf( stderr, "Internal error: unknown key %s in section %s\n",
+	         key, sect->name );
+	exit( 1 );
+}
+
+
+/*
+ * defaults
+ */
+
+typedef struct DEnt {
+	const char *key;
+	const char *value;
+	int active;
+} DEnt;
+
+typedef struct DSect {
+	const char *name;
+	DEnt *ents;
+	int nents;
+	const char *comment;
+} DSect;
+
+CONF_GEN_EXAMPLE
+
+static void
+makeDefaultConfig( void )
+{
+	Section *cs, **csp;
+	Entry *ce, **cep;
+	int sc, ec;
+
+	for (csp = &config, sc = 0; sc < as(dAllSects); csp = &(cs->next), sc++) {
+		cs = mcalloc( sizeof(*cs) );
+		*csp = cs;
+		cs->spec = findSect( dAllSects[sc].name );
+		cs->name = dAllSects[sc].name;
+		cs->comment = dAllSects[sc].comment;
+		for (cep = &(cs->ents), ec = 0; ec < dAllSects[sc].nents;
+		     cep = &(ce->next), ec++)
+		{
+			ce = mcalloc( sizeof(*ce) );
+			*cep = ce;
+			ce->spec = findEnt( cs->spec, dAllSects[sc].ents[ec].key );
+			ce->value = dAllSects[sc].ents[ec].value;
+			ce->active = dAllSects[sc].ents[ec].active;
+		}
+	}
+}
+
+
+/*
+ * read rc file structure
+ */
+
+typedef struct REntry {
+	struct REntry *next;
+	const char *key;
+	char *value;
+} REntry;
+
+typedef struct RSection {
+	struct RSection *next;
+	const char *name;
+	REntry *ents;
+} RSection;
+
+static RSection *
+readConfig( const char *fname )
+{
+	char *nstr;
+	char *s, *e, *st, *en, *ek, *sl;
+	RSection *rootsec = 0, *cursec;
+	REntry *curent;
+	int nlen;
+	int line, sectmoan;
+	File file;
+
+	if (!readFile( &file, fname ))
+		return 0;
+	usedFile( fname );
+
+	for (s = file.buf, line = 0, cursec = 0, sectmoan = 1; s < file.eof; s++) {
+		line++;
+
+		while ((s < file.eof) && isspace( *s ) && (*s != '\n'))
+			s++;
+
+		if ((s < file.eof) && ((*s == '\n') || (*s == '#'))) {
+		  sktoeol:
+			while ((s < file.eof) && (*s != '\n'))
+				s++;
+			continue;
+		}
+		sl = s;
+
+		if (*s == '[') {
+			while ((s < file.eof) && (*s != '\n'))
+				s++;
+			e = s - 1;
+			while ((e > sl) && isspace( *e ))
+				e--;
+			if (*e != ']') {
+				fprintf( stderr, "Invalid section header at %s:%d\n",
+				         fname, line );
+				continue;
+			}
+			sectmoan = False;
+			nstr = sl + 1;
+			nlen = e - nstr;
+			for (cursec = rootsec; cursec; cursec = cursec->next)
+				if (!memcmp( nstr, cursec->name, nlen ) &&
+				    !cursec->name[nlen])
+				{
+#if 0 /* not our business ... */
+					fprintf( stderr, "Warning: Multiple occurrences of section "
+					         "[%.*s] in %s. Consider merging them.\n",
+					         nlen, nstr, fname );
+#endif
+					goto secfnd;
+				}
+			cursec = mmalloc( sizeof(*cursec) );
+			ASPrintf( (char **)&cursec->name, "%.*s", nlen, nstr );
+			cursec->ents = 0;
+			cursec->next = rootsec;
+			rootsec = cursec;
+		  secfnd:
+			continue;
+		}
+
+		if (!cursec) {
+			if (sectmoan) {
+				sectmoan = False;
+				fprintf( stderr, "Entry outside any section at %s:%d",
+				         fname, line );
+			}
+			goto sktoeol;
+		}
+
+		for (; (s < file.eof) && (*s != '\n'); s++)
+			if (*s == '=')
+				goto haveeq;
+		fprintf( stderr, "Invalid entry (missing '=') at %s:%d\n", fname, line );
+		continue;
+
+	  haveeq:
+		for (ek = s - 1;; ek--) {
+			if (ek < sl) {
+				fprintf( stderr, "Invalid entry (empty key) at %s:%d\n",
+				         fname, line );
+				goto sktoeol;
+			}
+			if (!isspace( *ek ))
+				break;
+		}
+
+		s++;
+		while ((s < file.eof) && isspace( *s ) && (*s != '\n'))
+			s++;
+		st = s;
+		while ((s < file.eof) && (*s != '\n'))
+			s++;
+		for (en = s - 1; en >= st && isspace( *en ); en--);
+
+		nstr = sl;
+		nlen = ek - sl + 1;
+		for (curent = cursec->ents; curent; curent = curent->next)
+			if (!memcmp( nstr, curent->key, nlen ) &&
+			    !curent->key[nlen]) {
+				fprintf( stderr, "Multiple occurrences of key '%s' in section "
+				         "[%s] of %s.\n", curent->key, cursec->name, fname );
+				goto keyfnd;
+			}
+		curent = mmalloc( sizeof(*curent) );
+		ASPrintf( (char **)&curent->key, "%.*s", nlen, nstr );
+		ASPrintf( (char **)&curent->value, "%.*s", en - st + 1, st );
+		curent->next = cursec->ents;
+		cursec->ents = curent;
+	  keyfnd:
+		continue;
+	}
+	return rootsec;
+}
+
+
+static int
+mergeKdmRcOld( const char *path )
+{
+	char *p;
+	struct stat st;
+
+	ASPrintf( &p, "%s/kdmrc", path );
+	if (stat( p, &st )) {
+		free( p );
+		return False;
+	}
+	printf( "Information: ignoring pre-existing kdmrc %s from kde < 2.2\n", p );
+	free( p );
+	return True;
+}
+
+typedef struct {
+	const char *sect, *key, *def;
+	int (*cond)( void );
+} FDefs;
+
+/*
+ * The idea is to determine how exactly the pre-existing config would
+ * have been interpreted, so no default configs are created where builtin
+ * defaults were used so far.
+ */
+static void
+applyDefs( FDefs *chgdef, int ndefs, const char *path )
+{
+	char *p;
+	int i;
+
+	for (i = 0; i < ndefs; i++)
+		if (!getFqVal( chgdef[i].sect, chgdef[i].key, 0 ) &&
+		    (!chgdef[i].cond || chgdef[i].cond()))
+		{
+			ASPrintf( &p, chgdef[i].def, path );
+			putFqVal( chgdef[i].sect, chgdef[i].key, p );
+			free( p );
+		}
+}
+
+static int
+if_usebg (void)
+{
+	return isTrue( getFqVal( "X-*-Greeter", "UseBackground", "true" ) );
+}
+
+static FDefs kdmdefs_all[] = {
+#ifdef XDMCP
+{ "Xdmcp", "Xaccess", "%s/kdm/Xaccess", 0 },
+{ "Xdmcp", "Willing", "", 0 },
+#endif
+{ "X-*-Core", "Setup", "", 0 },
+{ "X-*-Core", "Startup", "", 0 },
+{ "X-*-Core", "Reset", "", 0 },
+{ "X-*-Core", "Session", XBINDIR "/xterm -ls -T", 0 },
+{ "X-*-Greeter", "BackgroundCfg", "%s/kdm/backgroundrc", if_usebg },
+};
+
+typedef struct KUpdEnt {
+	const char *okey, *nsec, *nkey;
+	void (*func)( const char *sect, char **value );
+} KUpdEnt;
+
+typedef struct KUpdSec {
+	const char *osec;
+	KUpdEnt *ents;
+	int nents;
+} KUpdSec;
+
+#ifdef XDMCP
+static void
+P_EnableChooser( const char *sect ATTR_UNUSED, char **value )
+{
+	*value = (char *)(isTrue( *value ) ? "DefaultLocal" : "LocalOnly");
+}
+#endif
+
+static void
+P_UseLilo( const char *sect ATTR_UNUSED, char **value )
+{
+	*value = (char *)(isTrue( *value ) ? "Lilo" : "None");
+}
+
+static void
+P_EchoMode( const char *sect ATTR_UNUSED, char **value )
+{
+	*value = (char *)(!strcmp( *value, "NoEcho" ) ? "false" : "true");
+}
+
+CONF_GEN_KMERGE
+
+static int
+mergeKdmRcNewer( const char *path, int obsRet )
+{
+	char *p;
+	const char *cp, *sec, *key;
+	RSection *rootsect, *cs;
+	REntry *ce;
+	int i, j, ma, mi;
+	static char sname[64];
+
+	ASPrintf( &p, "%s/kdm/kdmrc", path );
+	if (!(rootsect = readConfig( p ))) {
+		free( p );
+		return False;
+	}
+	for (cs = rootsect; cs; cs = cs->next)
+		if (!strcmp( cs->name, "General" ))
+			for (ce = cs->ents; ce; ce = ce->next)
+				if (!strcmp( ce->key, "ConfigVersion" ))
+					goto gotcfgv;
+	printf( "Information: ignoring pre-existing kdmrc %s from kde < 3.1\n", p );
+	free( p );
+	return obsRet;
+  gotcfgv:
+	sscanf( ce->value, "%d.%d", &ma, &mi );
+	oldver = (ma << 8) | mi;
+	printf( "Information: reading pre-existing kdmrc %s (config version %d.%d)\n",
+	        p, ma, mi );
+	free( p );
+
+	for (cs = rootsect; cs; cs = cs->next) {
+			cp = strrchr( cs->name, '-' );
+			if (!cp)
+				cp = cs->name;
+			else if (cs->name[0] != 'X' || cs->name[1] != '-')
+				goto dropsec;
+			for (i = 0; i < as(kupsects); i++)
+				if (!strcmp( cp, kupsects[i].osec )) {
+					for (ce = cs->ents; ce; ce = ce->next) {
+						for (j = 0; j < kupsects[i].nents; j++)
+							if (!strcmp( ce->key, kupsects[i].ents[j].okey )) {
+								if (kupsects[i].ents[j].nsec == (char *)-1) {
+									kupsects[i].ents[j].func( 0, &ce->value );
+									goto gotkey;
+								}
+								if (!kupsects[i].ents[j].nsec)
+									sec = cs->name;
+								else {
+									sec = sname;
+									sprintf( sname, "%.*s-%s",
+									         (int)(cp - cs->name), cs->name,
+									         kupsects[i].ents[j].nsec );
+								}
+								if (!kupsects[i].ents[j].nkey)
+									key = ce->key;
+								else
+									key = kupsects[i].ents[j].nkey;
+								if (kupsects[i].ents[j].func)
+									kupsects[i].ents[j].func( sec, &ce->value );
+								putFqVal( sec, key, ce->value );
+								goto gotkey;
+							}
+						printf( "Information: dropping key %s from section [%s]\n",
+						        ce->key, cs->name );
+					  gotkey: ;
+					}
+					goto gotsec;
+				}
+		  dropsec:
+			printf( "Information: dropping section [%s]\n", cs->name );
+		  gotsec: ;
+	}
+
+	applyDefs( kdmdefs_all, as(kdmdefs_all), path );
+
+	return True;
+}
+
+
+typedef struct XResEnt {
+	const char *xname;
+	const char *ksec, *kname;
+	void (*func)( const char *sect, char **value );
+} XResEnt;
+
+static void
+handleXdmVal( const char *dpy, const char *key, char *value,
+              const XResEnt *ents, int nents )
+{
+	const char *kname;
+	int i;
+	char knameb[80], sname[80];
+
+	for (i = 0; i < nents; i++)
+		if (!strcmp( key, ents[i].xname ) ||
+		    (key[0] == toupper( ents[i].xname[0] ) &&
+		     !strcmp( key + 1, ents[i].xname + 1 )))
+		{
+			if (ents[i].ksec == (char *)-1) {
+				ents[i].func( 0, &value );
+				break;
+			}
+			sprintf( sname, ents[i].ksec, dpy );
+			if (ents[i].kname)
+				kname = ents[i].kname;
+			else {
+				kname = knameb;
+				sprintf( knameb, "%c%s",
+				         toupper( ents[i].xname[0] ), ents[i].xname + 1 );
+			}
+			if (ents[i].func)
+				ents[i].func( sname, &value );
+			putFqVal( sname, kname, value );
+			break;
+		}
+}
+
+static void
+P_list( const char *sect ATTR_UNUSED, char **value )
+{
+	int is, d, s;
+	char *st;
+
+	for (st = *value, is = False, d = s = 0; st[s]; s++)
+		if (st[s] == ' ' || st[s] == '\t') {
+			if (!is)
+				st[d++] = ',';
+			is = True;
+		} else {
+			st[d++] = st[s];
+			is = False;
+		}
+	st[d] = 0;
+}
+
+static void
+P_authDir( const char *sect ATTR_UNUSED, char **value )
+{
+	int l;
+
+	l = strlen( *value );
+	if (l < 4) {
+		*value = 0;
+		return;
+	}
+	if ((*value)[l-1] == '/')
+		(*value)[--l] = 0;
+	if (!strncmp( *value, "/tmp/", 5 ) ||
+	    !strncmp( *value, "/var/tmp/", 9 ))
+	{
+		printf( "Warning: Resetting inappropriate value %s for AuthDir to default\n",
+		        *value );
+		*value = 0;
+		return;
+	}
+	if ((l >= 4 && !strcmp( *value + l - 4, "/tmp" )) ||
+	    (l >= 6 && !strcmp( *value + l - 6, "/xauth" )) ||
+	    (l >= 8 && !strcmp( *value + l - 8, "/authdir" )) ||
+	    (l >= 10 && !strcmp( *value + l - 10, "/authfiles" )))
+		return;
+	ASPrintf( value, "%s/authdir", *value );
+}
+
+static void
+P_openDelay( const char *sect, char **value )
+{
+	putFqVal( sect, "ServerTimeout", *value );
+}
+
+static void
+P_noPassUsers( const char *sect, char **value ATTR_UNUSED )
+{
+	putFqVal( sect, "NoPassEnable", "true" );
+}
+
+static void
+P_autoUser( const char *sect, char **value ATTR_UNUSED )
+{
+	putFqVal( sect, "AutoLoginEnable", "true" );
+}
+
+#ifdef XDMCP
+static void
+P_requestPort( const char *sect, char **value )
+{
+	if (!strcmp( *value, "0" )) {
+		*value = 0;
+		putFqVal( sect, "Enable", "false" );
+	} else
+		putFqVal( sect, "Enable", "true" );
+}
+#endif
+
+static int kdmrcmode = 0644;
+
+static void
+P_autoPass( const char *sect ATTR_UNUSED, char **value ATTR_UNUSED )
+{
+	kdmrcmode = 0600;
+}
+
+CONF_GEN_XMERGE
+
+static XrmQuark XrmQString, empty = NULLQUARK;
+
+static Bool
+dumpEntry( XrmDatabase *db ATTR_UNUSED,
+           XrmBindingList bindings,
+           XrmQuarkList quarks,
+           XrmRepresentation *type,
+           XrmValuePtr value,
+           XPointer data ATTR_UNUSED )
+{
+	const char *dpy, *key;
+	int el, hasu;
+	char dpybuf[80];
+
+	if (*type != XrmQString)
+		return False;
+	if (*bindings == XrmBindLoosely ||
+	    strcmp( XrmQuarkToString (*quarks), "DisplayManager" ))
+		return False;
+	bindings++, quarks++;
+	if (!*quarks)
+		return False;
+	if (*bindings != XrmBindLoosely && !quarks[1]) { /* DM.foo */
+		key = XrmQuarkToString (*quarks);
+		handleXdmVal( 0, key, value->addr, globents, as(globents) );
+		return False;
+	} else if (*bindings == XrmBindLoosely && !quarks[1]) { /* DM*bar */
+		dpy = "*";
+		key = XrmQuarkToString (*quarks);
+	} else if (*bindings != XrmBindLoosely && quarks[1] &&
+	           *bindings != XrmBindLoosely && !quarks[2])
+	{ /* DM.foo.bar */
+		dpy = dpybuf + 4;
+		strcpy( dpybuf + 4, XrmQuarkToString (*quarks) );
+		for (hasu = False, el = 4; dpybuf[el]; el++)
+			if (dpybuf[el] == '_')
+				hasu = True;
+		if (!hasu/* && isupper (dpy[0])*/) {
+			dpy = dpybuf;
+			memcpy( dpybuf, "*:*_", 4 );
+		} else {
+			for (; --el >= 0; )
+				if (dpybuf[el] == '_') {
+					dpybuf[el] = ':';
+					for (; --el >= 4; )
+						if (dpybuf[el] == '_')
+							dpybuf[el] = '.';
+					break;
+				}
+		}
+		key = XrmQuarkToString (quarks[1]);
+	} else
+		return False;
+	handleXdmVal( dpy, key, value->addr, dpyents, as(dpyents) );
+	return False;
+}
+
+static FDefs xdmdefs[] = {
+#ifdef XDMCP
+{ "Xdmcp", "Xaccess", "%s/Xaccess", 0 },
+{ "Xdmcp", "Willing", "", 0 },
+#endif
+{ "X-*-Core", "Setup", "", 0 },
+{ "X-*-Core", "Startup", "", 0 },
+{ "X-*-Core", "Reset", "", 0 },
+{ "X-*-Core", "Session", "", 0 },
+};
+
+static int
+mergeXdmCfg( const char *path )
+{
+	char *p;
+	XrmDatabase db;
+
+	ASPrintf( &p, "%s/xdm-config", path );
+	if ((db = XrmGetFileDatabase( p ))) {
+		printf( "Information: reading xdm config file %s\n", p );
+		usedFile( p );
+		free( p );
+		XrmEnumerateDatabase( db, &empty, &empty, XrmEnumAllLevels,
+		                      dumpEntry, (XPointer)0 );
+		applyDefs( xdmdefs, as(xdmdefs), path );
+		mod_usebg = True;
+		return True;
+	}
+	free( p );
+	return False;
+}
+
+static void
+fprintfLineWrap( FILE *f, const char *msg, ... )
+{
+	char *txt, *ftxt, *line;
+	va_list ap;
+	int col, lword, fspace;
+
+	va_start( ap, msg );
+	VASPrintf( &txt, msg, ap );
+	va_end( ap );
+	ftxt = 0;
+	for (line = txt, col = 0, lword = fspace = -1; line[col]; ) {
+		if (line[col] == '\n') {
+			strCat( &ftxt, "%.*s", ++col, line );
+			line += col;
+			col = 0;
+			lword = fspace = -1;
+			continue;
+		} else if (line[col] == ' ') {
+			if (lword >= 0) {
+				fspace = col;
+				lword = -1;
+			}
+		} else {
+			if (lword < 0)
+				lword = col;
+			if (col >= 78 && fspace >= 0) {
+				strCat( &ftxt, "%.*s\n", fspace, line );
+				line += lword;
+				col -= lword;
+				lword = 0;
+				fspace = -1;
+			}
+		}
+		col++;
+	}
+	free( txt );
+	if (ftxt) {
+		fputs_( ftxt, f );
+		free( ftxt );
+	}
+}
+
+
+static const char *oldkdes[] = {
+	KDE_CONFDIR,
+	"/opt/kde4/share/config",
+	"/usr/local/kde4/share/config",
+
+	"/opt/kde/share/config",
+	"/usr/local/kde/share/config",
+	"/usr/local/share/config",
+	"/usr/share/config",
+
+	"/opt/kde3/share/config",
+	"/usr/local/kde3/share/config",
+};
+
+static const char *oldxdms[] = {
+	"/etc/X11/xdm",
+	XLIBDIR "/xdm",
+};
+
+int main( int argc, char **argv )
+{
+	const char **where;
+	FILE *f;
+	StrList *fp;
+	Section *cs;
+	Entry *ce, **cep;
+	int i, ap, locals, foreigns;
+	int no_old_xdm = 0, no_old_kde = 0;
+	struct stat st;
+
+	for (ap = 1; ap < argc; ap++) {
+		if (!strcmp( argv[ap], "--help" )) {
+			printf(
+"genkdmconf - generate configuration files for kdm\n"
+"\n"
+"If an older xdm/kdm configuration is found, its config files are \"absorbed\";\n"
+"if it lives in the new target directory, its scripts are reused (and possibly\n"
+"modified) as well, otherwise the scripts are ignored and default scripts are\n"
+"installed.\n"
+"\n"
+"options:\n"
+"  --in /path/to/new/kdm-config-dir\n"
+"    In which directory to put the new configuration. You can use this\n"
+"    to support a $(DESTDIR), but not to change the final location of\n"
+"    the installation - the paths inside the files are not affected.\n"
+"    Default is " KDMCONF ".\n"
+"  --old-xdm /path/to/old/xdm-dir\n"
+"    Where to look for the config files of an xdm.\n"
+"    Default is to scan /etc/X11/xdm & $XLIBDIR/xdm.\n"
+"    Note that you possibly need to use --no-old-kde to make this take effect.\n"
+"  --old-kde /path/to/old/kde-config-dir\n"
+"    Where to look for the kdmrc of a previously installed kdm.\n"
+"    Default is to scan " KDE_CONFDIR " and\n"
+"    {/usr,/usr/local,{/opt,/usr/local}/{kde4,kde,kde3}}/share/config.\n"
+"  --no-old\n"
+"    Do not look at older xdm/kdm configurations, just create default config.\n"
+"  --no-old-xdm\n"
+"    Do not look at older xdm configurations.\n"
+"  --no-old-kde\n"
+"    Do not look at older kdm configurations.\n"
+"  --old-scripts\n"
+"    Directly use all scripts from the older xdm/kdm configuration.\n"
+"  --no-old-scripts\n"
+"    Do not use scripts from the older xdm/kdm configuration even if it lives\n"
+"    in the new target directory.\n"
+"  --old-confs\n"
+"    Directly use all ancillary config files from the older xdm/kdm\n"
+"    configuration. This is usually a bad idea.\n"
+"  --no-backup\n"
+"    Overwrite/delete old config files instead of backing them up.\n"
+"  --no-in-notice\n"
+"    Do not put the notice about --in being used into the generated README.\n"
+);
+			exit( 0 );
+		}
+		if (!strcmp( argv[ap], "--no-old" )) {
+			no_old = True;
+			continue;
+		}
+		if (!strcmp( argv[ap], "--old-scripts" )) {
+			old_scripts = True;
+			continue;
+		}
+		if (!strcmp( argv[ap], "--no-old-scripts" )) {
+			no_old_scripts = True;
+			continue;
+		}
+		if (!strcmp( argv[ap], "--old-confs" )) {
+			old_confs = True;
+			continue;
+		}
+		if (!strcmp( argv[ap], "--no-old-xdm" )) {
+			no_old_xdm = True;
+			continue;
+		}
+		if (!strcmp( argv[ap], "--no-old-kde" )) {
+			no_old_kde = True;
+			continue;
+		}
+		if (!strcmp( argv[ap], "--no-backup" )) {
+			no_backup = True;
+			continue;
+		}
+		if (!strcmp( argv[ap], "--no-in-notice" )) {
+			no_in_notice = True;
+			continue;
+		}
+		where = 0;
+		if (!strcmp( argv[ap], "--in" ))
+			where = &newdir;
+		else if (!strcmp( argv[ap], "--old-xdm" ))
+			where = &oldxdm;
+		else if (!strcmp( argv[ap], "--old-kde" ))
+			where = &oldkde;
+		else if (!strcmp( argv[ap], "--face-src" ))
+			where = &facesrc;
+		else {
+			fprintf( stderr, "Unknown command line option '%s', try --help\n", argv[ap] );
+			exit( 1 );
+		}
+		if (ap + 1 == argc || argv[ap + 1][0] == '-') {
+			fprintf( stderr, "Missing argument to option '%s', try --help\n", argv[ap] );
+			exit( 1 );
+		}
+		*where = argv[++ap];
+	}
+	if (memcmp( newdir, KDMCONF, sizeof(KDMCONF) ))
+		use_destdir = True;
+
+	if (!mkdirp( newdir, 0755, "target", True ))
+		exit( 1 );
+
+	makeDefaultConfig();
+	if (no_old) {
+		DIR *dir;
+		StrList *bfl = 0;
+		if ((dir = opendir( newdir ))) {
+			struct dirent *ent;
+			char bn[PATH_MAX];
+			while ((ent = readdir( dir ))) {
+				int l;
+				if (!strcmp( ent->d_name, "." ) || !strcmp( ent->d_name, ".." ))
+					continue;
+				l = sprintf( bn, "%s/%s", newdir, ent->d_name ); /* cannot overflow (kernel would not allow the creation of a longer path) */
+				if (!stat( bn, &st ) && !S_ISREG( st.st_mode ))
+					continue;
+				if (no_backup || !memcmp( bn + l - 4, ".bak", 5 ))
+					unlink( bn );
+				else
+					addStr( &bfl, bn );
+			}
+			closedir( dir );
+			for (; bfl; bfl = bfl->next)
+				displace( bfl->str );
+		}
+	} else {
+		if (oldkde) {
+			if (!mergeKdmRcNewer( oldkde, True ) && !mergeKdmRcOld( oldkde )) {
+				fprintf( stderr,
+				         "Cannot read pre-existing kdmrc at specified location\n" );
+				oldkde = 0;
+			}
+		} else if (!no_old_kde) {
+			for (i = 0; i < as(oldkdes); i++) {
+				if (i && !strcmp( oldkdes[0], oldkdes[i] ))
+					continue;
+				if (mergeKdmRcNewer( oldkdes[i], 0 )) {
+					oldkde = oldkdes[i];
+					break;
+				}
+				mergeKdmRcOld( oldkdes[i] ); /* only prints a message */
+			}
+		}
+		if (oldkde) {
+#define SHR_CONF "/share/config"
+			int olen = strlen( oldkde );
+			if (olen < (int)sizeof(SHR_CONF) ||
+				memcmp( oldkde + olen - sizeof(SHR_CONF) + 1,
+						SHR_CONF, sizeof(SHR_CONF) ))
+			{
+				fprintf( stderr,
+				         "Warning: --old-kde does not end with " SHR_CONF ". "
+				         "Might wreak havoc.\n" );
+				oldkdepfx = oldkde;
+			} else
+				ASPrintf( (char **)&oldkdepfx,
+				           "%.*s", olen - sizeof(SHR_CONF) + 1, oldkde );
+			oldxdm = 0;
+		} else if (!no_old_xdm) {
+			XrmInitialize();
+			XrmQString = XrmPermStringToQuark( "String" );
+			if (oldxdm) {
+				if (!mergeXdmCfg( oldxdm )) {
+					fprintf( stderr,
+					         "Cannot read xdm-config at specified location\n" );
+					oldxdm = 0;
+				}
+			} else
+				for (i = 0; i < as(oldxdms); i++)
+					if (mergeXdmCfg( oldxdms[i] )) {
+						oldxdm = oldxdms[i];
+						break;
+					}
+		}
+	}
+	/*
+	 * How to proceed with pre-existing scripts (which are named in the config):
+	 * - old_scripts set or some scripts in new target already => keep 'em
+	 * - no_old_scripts set or all scripts outside new target => pretend that
+	 *   the old config did not reference them in the first place
+	 */
+	if (no_old_scripts)
+		goto no_old_s;
+	if (!old_scripts) {
+		locals = foreigns = False;
+		for (cs = config; cs; cs = cs->next)
+			if (!strcmp( cs->spec->name, "-Core" )) {
+				for (ce = cs->ents; ce; ce = ce->next)
+					if (ce->active &&
+					    (!strcmp( ce->spec->key, "Setup" ) ||
+					     !strcmp( ce->spec->key, "Startup" ) ||
+					     !strcmp( ce->spec->key, "Reset" )))
+					{
+						if (inNewDir( ce->value ))
+							locals = True;
+						else
+							foreigns = True;
+					}
+			}
+		if (foreigns) {
+			if (locals) {
+				fprintf( stderr,
+				         "Warning: both local and foreign scripts referenced. "
+				         "Will not touch any.\n" );
+				mixed_scripts = True;
+			} else {
+			  no_old_s:
+				for (cs = config; cs; cs = cs->next) {
+					if (!strcmp( cs->spec->name, "Xdmcp" )) {
+						for (ce = cs->ents; ce; ce = ce->next)
+							if (!strcmp( ce->spec->key, "Willing" ))
+								ce->active = ce->written = False;
+					} else if (!strcmp( cs->spec->name, "-Core" )) {
+						for (cep = &cs->ents; (ce = *cep); ) {
+							if (ce->active &&
+							    (!strcmp( ce->spec->key, "Setup" ) ||
+							     !strcmp( ce->spec->key, "Startup" ) ||
+							     !strcmp( ce->spec->key, "Reset" ) ||
+							     !strcmp( ce->spec->key, "Session" )))
+							{
+								if (!memcmp( cs->name, "X-*-", 4 ))
+									ce->active = ce->written = False;
+								else {
+									*cep = ce->next;
+									free( ce );
+									continue;
+								}
+							}
+							cep = &ce->next;
+						}
+					}
+				}
+			}
+		}
+	}
+#ifdef __linux__
+	if (!stat( "/etc/debian_version", &st )) { /* debian */
+		defminuid = "1000";
+		defmaxuid = "29999";
+	} else if (!stat( "/usr/portage", &st )) { /* gentoo */
+		defminuid = "1000";
+		defmaxuid = "65000";
+	} else if (!stat( "/etc/mandrake-release", &st )) { /* mandrake - check before redhat! */
+		defminuid = "500";
+		defmaxuid = "65000";
+	} else if (!stat( "/etc/redhat-release", &st )) { /* redhat */
+		defminuid = "100";
+		defmaxuid = "65000";
+	} else /* if (!stat( "/etc/SuSE-release", &st )) */ { /* suse */
+		defminuid = "500";
+		defmaxuid = "65000";
+	}
+#else
+	defminuid = "1000";
+	defmaxuid = "65000";
+#endif
+	for (i = 0; i < CONF_MAX_PRIO; i++)
+		for (cs = config; cs; cs = cs->next)
+			for (ce = cs->ents; ce; ce = ce->next)
+				if (ce->spec->func && i == ce->spec->prio)
+					ce->spec->func( ce, cs );
+	f = createFile( "kdmrc", kdmrcmode );
+	writeKdmrc( f );
+	fclose_( f );
+
+	f = createFile( "README", 0644 );
+	fprintf_( f,
+"This automatically generated configuration consists of the following files:\n" );
+	fprintf_( f, "- " KDMCONF "/kdmrc\n" );
+	for (fp = aflist; fp; fp = fp->next)
+		fprintf_( f, "- %s\n", fp->str );
+	if (use_destdir && !no_in_notice)
+		fprintfLineWrap( f,
+"All files destined for " KDMCONF " were actually saved in %s; "
+"this config will not be workable until moved in place.\n", newdir );
+	if (uflist || eflist || cflist || lflist) {
+		fprintf_( f,
+"\n"
+"This config was derived from existing files. As the used algorithms are\n"
+"pretty dumb, it may be broken.\n" );
+		if (uflist) {
+			fprintf_( f,
+"Information from these files was extracted:\n" );
+			for (fp = uflist; fp; fp = fp->next)
+				fprintf_( f, "- %s\n", fp->str );
+		}
+		if (lflist) {
+			fprintf_( f,
+"These files were directly incorporated:\n" );
+			for (fp = lflist; fp; fp = fp->next)
+				fprintf_( f, "- %s\n", fp->str );
+		}
+		if (cflist) {
+			fprintf_( f,
+"These files were copied verbatim:\n" );
+			for (fp = cflist; fp; fp = fp->next)
+				fprintf_( f, "- %s\n", fp->str );
+		}
+		if (eflist) {
+			fprintf_( f,
+"These files were copied with modifications:\n" );
+			for (fp = eflist; fp; fp = fp->next)
+				fprintf_( f, "- %s\n", fp->str );
+		}
+		if (!no_backup && !use_destdir)
+			fprintf_( f,
+"Old files that would have been overwritten were renamed to <oldname>.bak.\n" );
+	}
+	fprintf_( f,
+"\nTry 'genkdmconf --help' if you want to generate another configuration.\n"
+"\nYou may delete this README.\n" );
+	fclose_( f );
+
+	return 0;
+}
diff -Nru kdebase-workspace-4.3.73svn1040395/kdm/kfrontend/genkdmconf.c.rej kdebase-workspace-4.3.73svn1040395-new/kdm/kfrontend/genkdmconf.c.rej
--- kdebase-workspace-4.3.73svn1040395/kdm/kfrontend/genkdmconf.c.rej	1970-01-01 01:00:00.000000000 +0100
+++ kdebase-workspace-4.3.73svn1040395-new/kdm/kfrontend/genkdmconf.c.rej	2009-10-28 22:58:08.000000000 +0100
@@ -0,0 +1,17 @@
+***************
+*** 3162,3168 ****
+         f = createFile( "README", 0644 );
+         fprintf_( f,
+  "This automatically generated configuration consists of the following files:\n" );
+-        fprintf_( f, "- " KDMCONF "/kdmrc\n" );
+         for (fp = aflist; fp; fp = fp->next)
+                 fprintf_( f, "- %s\n", fp->str );
+         if (use_destdir && !no_in_notice)
+--- 3162,3168 ----
+         f = createFile( "README", 0644 );
+         fprintf_( f,
+  "This automatically generated configuration consists of the following files:\n" );
++        fprintf( f, "- /etc/X11/kdm/kdmrc\n" );
+         for (fp = aflist; fp; fp = fp->next)
+                 fprintf_( f, "- %s\n", fp->str );
+         if (use_destdir && !no_in_notice)
diff -Nru kdebase-workspace-4.3.73svn1040395/kdm/kfrontend/kdm_config.c kdebase-workspace-4.3.73svn1040395-new/kdm/kfrontend/kdm_config.c
--- kdebase-workspace-4.3.73svn1040395/kdm/kfrontend/kdm_config.c	2009-10-26 10:14:48.000000000 +0100
+++ kdebase-workspace-4.3.73svn1040395-new/kdm/kfrontend/kdm_config.c	2009-10-28 22:58:08.000000000 +0100
@@ -390,7 +390,7 @@
 
 CONF_READ_ENTRIES
 
-static const char *kdmrc = KDMCONF "/kdmrc";
+static const char *kdmrc = "/etc/X11/kdm/kdmrc";
 
 static Section *rootsec;
 
diff -Nru kdebase-workspace-4.3.73svn1040395/kdm/kfrontend/kdmctl.c kdebase-workspace-4.3.73svn1040395-new/kdm/kfrontend/kdmctl.c
--- kdebase-workspace-4.3.73svn1040395/kdm/kfrontend/kdmctl.c	2008-01-05 00:55:45.000000000 +0100
+++ kdebase-workspace-4.3.73svn1040395-new/kdm/kfrontend/kdmctl.c	2009-10-28 22:58:08.000000000 +0100
@@ -150,7 +150,7 @@
 {
 	char *dpy = getenv( "DISPLAY" );
 	const char *ctl = getenv( "DM_CONTROL" );
-	const char *cfg = KDE_CONFDIR "/kdm/kdmrc";
+	const char *cfg = "/etc/X11/kdm/kdmrc";
 	char *ptr;
 	int fd;
 
diff -Nru kdebase-workspace-4.3.73svn1040395/kdm/kfrontend/sessions/CMakeLists.txt kdebase-workspace-4.3.73svn1040395-new/kdm/kfrontend/sessions/CMakeLists.txt
--- kdebase-workspace-4.3.73svn1040395/kdm/kfrontend/sessions/CMakeLists.txt	2008-04-30 15:58:40.000000000 +0200
+++ kdebase-workspace-4.3.73svn1040395-new/kdm/kfrontend/sessions/CMakeLists.txt	2009-10-28 22:58:08.000000000 +0100
@@ -51,5 +51,5 @@
 	xfce.desktop
 	xfce4.desktop
 
-	DESTINATION ${DATA_INSTALL_DIR}/kdm/sessions
+	DESTINATION /etc/X11/sessions
 )
